

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpg">
  <link rel="icon" href="/img/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lin Xinjie">
  <meta name="keywords" content="">
  
    <meta name="description" content="排序 sort函数（sort和cmp配合使用） sort函数（c++）可以对数据进行排序和自定义排序（cmp配合使用） 12345从小到大排序可以写成sort(a,a+n,less&lt;要进行排序的数据类型&gt;())&#x2F;&#x2F;a是数组的首地址，a+n是数组的尾地址(也可以是结构体数组)从大到小排序可以写成sort(a,a+n,greater&lt;要进行排序的数据类型&gt;()) sort可以和">
<meta property="og:type" content="article">
<meta property="og:title" content="算法学习">
<meta property="og:url" content="http://www.ooorz.site/2022/10/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Xinjie Lin&#39;s Blog">
<meta property="og:description" content="排序 sort函数（sort和cmp配合使用） sort函数（c++）可以对数据进行排序和自定义排序（cmp配合使用） 12345从小到大排序可以写成sort(a,a+n,less&lt;要进行排序的数据类型&gt;())&#x2F;&#x2F;a是数组的首地址，a+n是数组的尾地址(也可以是结构体数组)从大到小排序可以写成sort(a,a+n,greater&lt;要进行排序的数据类型&gt;()) sort可以和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/01/23/oADHGJ94uVLsKUp.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/16/SfGoOxAmku5Dild.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/16/4i6l5raRcU7zgQX.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/16/B9GnoqSmsPZfFpC.png">
<meta property="og:image" content="https://s2.loli.net/2022/04/16/jdTypKLX8qQ1tbA.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061606450.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061616514.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061618829.gif">
<meta property="og:image" content="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg">
<meta property="article:published_time" content="2022-10-22T17:09:05.000Z">
<meta property="article:modified_time" content="2024-10-21T04:13:32.264Z">
<meta property="article:author" content="Lin Xinjie">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="acwing">
<meta property="article:tag" content="算法学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/01/23/oADHGJ94uVLsKUp.png">
  
  
  
  <title>算法学习 - Xinjie Lin&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.ooorz.site","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Xinjie Lin&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-23 01:09" pubdate>
          2022年10月23日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          全文共有20k字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          预计阅读时间为167分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法学习</h1>
            
            
              <div class="markdown-body">
                
                <h1>排序</h1>
<h2 id="sort函数（sort和cmp配合使用）">sort函数（sort和cmp配合使用）</h2>
<p>sort函数（c++）可以对数据进行排序和自定义排序（cmp配合使用）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">从小到大排序可以写成<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">less</span>&lt;要进行排序的数据类型&gt;())<span class="hljs-comment">//a是数组的首地址，a+n是数组的尾地址(也可以是结构体数组)</span><br>从大到小排序可以写成<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">greater</span>&lt;要进行排序的数据类型&gt;())<br><br></code></pre></td></tr></table></figure>
<p>sort可以和cmp函数配合使用进行自定义的结构体排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">//定义结构体</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">double</span> a,b,c;<br>    <span class="hljs-type">double</span> sum;<br>&#125;student;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> student &amp;a,<span class="hljs-type">const</span> student &amp;b)</span><span class="hljs-comment">//cmp函数原型，其中形参要取地址，因为要变换原数据的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.sum!=b.sum) <span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.a!=b.a) <span class="hljs-keyword">return</span> a.a&gt;b.a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.b!=b.b) <span class="hljs-keyword">return</span> a.b&gt;b.b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.c&gt;b.c;<br>&#125;<br><span class="hljs-comment">//cmp函数返回为true时不会变化位置，当返回false时会变换位置，所以return a.c&gt;b.c就是降序排列，return a.c&lt;b.c就是升序排序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    student a[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">sort</span>(a,a+n,cmp);<span class="hljs-comment">//进行自定义排序</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<p><strong>分析1：为什么从无序数组创建堆要从n/2开始？</strong></p>
<p>因为堆为完全二叉树，完全二叉树中父亲和儿子的地址拥有如下关系：<strong>父亲X2=左儿子，父亲X2+1=右儿子，左儿子/2=右儿子/2=父亲</strong>。</p>
<p><strong>分析2：升序和降序如何选择大根堆或者小根堆？</strong></p>
<p>在升序中通常采用小根堆，在降序中采用大根堆。因为用数组模拟堆时，删除首元素比较麻烦，但是删除最后一个元素非常方便，直接让首元素等于最后一个元素，然后在不断down首元素得到正确的堆</p>
<p><strong>分析3：为什么在down()函数中要不断递归呢？</strong></p>
<p>因为创建堆的时候，当父亲比两个儿子都大的时候，我们找到三个中最小的一个，并交换位置，但是我们并不知道父亲在整个堆的位置，所以我们要不断down来正确找到父亲的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里填你的代码^^</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],tt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x&lt;=tt&amp;&amp;h[<span class="hljs-number">2</span>*x]&lt;h[t]) t=<span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>&lt;=tt&amp;&amp;h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<span class="hljs-comment">//算出自己和自己的儿子谁小</span><br>    <span class="hljs-keyword">if</span>(t!=x)<span class="hljs-comment">//如果自己的儿子比自己小，就交换数值，并且递归让自己到达正确的位置</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[x],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    tt=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;h[i];<span class="hljs-comment">//输入是无序的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">down</span>(i);<span class="hljs-comment">//为啥创建堆时权重是从n/2开始，因为最后一层不用进行堆的排序</span><br>    <span class="hljs-comment">//要从最后一层的上一层开始，而父亲和儿子的权重关系是i(父亲)=i(儿子)*2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cout&lt;&lt;h[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//最小的数，就是堆权重最小的数</span><br>        h[<span class="hljs-number">1</span>]=h[tt--];<span class="hljs-comment">//因为数组删除第一个元素时很困难的，所以直接将堆最后一位赋值到第一位</span><br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//然后再判断该数是否在正确的位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br></code></pre></td></tr></table></figure>
<h2 id="桶排序">桶排序</h2>
<p>桶排序可以解决数据过多导致超时的情况，也可以计算计算得票数量类的题型</p>
<p>整个过程：</p>
<p><img src="https://s2.loli.net/2022/01/23/oADHGJ94uVLsKUp.png" srcset="/img/loading.gif" lazyload alt="image-20220123164040471"></p>
<p>例题：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">为了找出林大2020新生中最擅长编写代码的同学，学校发起了一场投票。通过同学报名、前期遴选等环节，共提名了100名同学作为选举人进行评选，假设他们的编号从1到100。现在学院已经采集到了n名同学的投票结果，请你找出得票最多的程序员获得的票数(注：就是让你找相同数字的个数的最大值)。<br>输入样例1：<br>6<br>1<span class="hljs-number"> 2 </span>4<span class="hljs-number"> 7 </span>7 7<br>4<br>5<span class="hljs-number"> 5 </span>5 5<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,t;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<span class="hljs-comment">//将数组初始化为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//进行桶排序</span><br>            cin&gt;&gt;t;<br>            a[t]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++) ans=<span class="hljs-built_in">max</span>(ans,a[i]);<span class="hljs-comment">//运用了max函数，max(a,b)函数会返回大的数</span><br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="快速排序">快速排序</h2>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">785</span>.快速排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用快速排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-comment">//模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,x=a[l+r&gt;&gt;<span class="hljs-number">1</span>];<span class="hljs-comment">//为什么要-1,因为在循环的时候会先加一</span><br>    <span class="hljs-keyword">while</span>(i&lt;j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(a[i]&lt;x);<span class="hljs-comment">//找到大于中间值的量</span><br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(a[j]&gt;x);<span class="hljs-comment">//找到小于中间值的量</span><br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//如果i&lt;j,就交换两个值</span><br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(a,l,j);<span class="hljs-comment">//进行二分递归</span><br>    <span class="hljs-built_in">quick_sort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">quick_sort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) i==n<span class="hljs-number">-1</span>?cout&lt;&lt;a[i]&lt;&lt;endl:cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">787</span>.归并排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用归并排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l,mid),<span class="hljs-built_in">merge_sort</span>(mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归二分到最小单元</span><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//两个数组部分的第一个元素</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<span class="hljs-comment">//没有超过两个数组部分的最后一个位置</span><br>    &#123;<br>        <span class="hljs-comment">//有序合并两个数组</span><br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];<span class="hljs-comment">//如果还有剩余部分没有合并，就直接接上去</span><br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>,i=l;i&lt;=r;i++,k++) q[i]=tmp[k];<span class="hljs-comment">//将有序的数组还原回原数组的对应位置，注意时对应位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i];<br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) i==n<span class="hljs-number">-1</span>?cout&lt;&lt;q[i]&lt;&lt;endl:cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="选择排序O-N-2">选择排序O(N^2)</h2>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">787</span>.归并排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用归并排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> n;<br>   cin&gt;&gt;n;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>   &#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>     &#123;<br>       <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) <span class="hljs-built_in">swap</span>(a[i],a[j]); <br>     &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;　&quot;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="冒泡排序">冒泡排序</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000;</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(a[j],a[j+<span class="hljs-number">1</span>]);<br>                flag=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!data)&#123;<br>            n--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> a[n++]=data;<br>    &#125;<br>    <span class="hljs-built_in">bubble_sort</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="直接插入算法">直接插入算法</h2>
<p><strong>算法核心</strong></p>
<p>从第二个元素开始，一旦有元素a[j-1]&gt;a[j],那么就需要调整顺序。</p>
<p>先将a[j]存储到a[0],然后将a[j]=a[j-1],接着从j-2后往前比对，如果a[j]&gt;a[0],那么就将a[j+1]=a[j],如果a[j]&lt;=a[0],那么a[j+1]=a[0],结束本轮循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//直接插入排序算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000;</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DirectInsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])<br>        &#123;<br>            a[<span class="hljs-number">0</span>]=a[i];<br>            a[i]=a[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-2</span>;a[<span class="hljs-number">0</span>]&lt;a[j];j--) a[j+<span class="hljs-number">1</span>]=a[j];<br>            a[j+<span class="hljs-number">1</span>]=a[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!data)&#123;<br>            n--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> a[n++]=data;<br>    &#125;<br>    <span class="hljs-built_in">DirectInsertSort</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>二进制枚举</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sugarbliss/article/details/81099340">详细介绍二进制枚举</a></p>
<p>1.含有N个元素的集合的一切子集个数有2^n种，二进制采用0和1来表示数字。于是我们可以利用二进制特性，将含n个元素都用0和1来表示选和不选，于是就可以得到每一种子集的情况。</p>
<p>2.那我们如何找到每个位置是否选和不选？可以采用位运算和与运算结合的方式。&lt;&lt;运算相当于在01串的尾巴处加上0（左移一位相当于乘以2），而与运算的规则是全为1才可以得到1。那么我们就可以通过对1不断进行左移运算和与运算得到每个位置的选择情况</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">1</span>=<span class="hljs-number">2</span>(<span class="hljs-number">10</span>);  <span class="hljs-number">1000</span>&amp;<span class="hljs-number">0010</span>=<span class="hljs-number">0000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">2</span>=<span class="hljs-number">4</span>(<span class="hljs-number">100</span>); <span class="hljs-number">1000</span>&amp;<span class="hljs-number">0100</span>=<span class="hljs-number">0000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">3</span>=<span class="hljs-number">8</span>(<span class="hljs-number">1000</span>); <span class="hljs-number">1000</span>&amp;<span class="hljs-number">1000</span>=<span class="hljs-number">1000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">4</span>=<span class="hljs-number">16</span>(<span class="hljs-number">10000</span>); <span class="hljs-number">01000</span>&amp;<span class="hljs-number">10000</span>=<span class="hljs-number">00000</span><br></code></pre></td></tr></table></figure>
<p>例题：</p>
<h3 id="和为K–二进制枚举">和为K–二进制枚举</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>给出长度为n的数组,求能否从中选出若干个,使他们的和为K.如果可以,输出:Yes,否则输出No<br>Input<br>第一行：输入N,K,为数组的长度和需要判断的和(2&lt;=N&lt;=20,1&lt;=K&lt;=10^9)<br>第二行：N个值，表示数组中元素的值(1&lt;=a[i]&lt;=10^6)<br>Output<br>输出Yes或No<br>Sample Input<br>5 13<br>2 4 6 8 10<br>Sample Output<br>No<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)<br>    &#123;<br>        <span class="hljs-type">int</span> a[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//共有1&lt;&lt;n种子集，遍历每种子集</span><br>        &#123;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//遍历每个位置</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))  sum+=a[j];<span class="hljs-comment">//如果选择该位置，就加上该位置的值</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum==k)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>     &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="陈老师加油-二进制枚举">陈老师加油-二进制枚举</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>陈老师经常开车在哈尔滨的大街上行走，假设刚开始油箱里有T升汽油，每看见加油站陈老师就要把汽油的总量翻倍（就是乘2）；每看见十字路口气油就要减少1升；最后的时候陈老师的车开到一个十字路口，然后车就没油了------就熄火了，陈老师好痛苦啊~~~！<br>然后他就开始回忆，一路上一共遇到5个加油站，10个十字路口，问造成这种惨烈的境遇有多少种可能？<br><br>Input<br>输入一个T ，（1&lt;=T&lt;=100）;<br>Output<br>输出可能的方案数。<br>Sample Input<br>1<br>Sample Output<br>10<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>);i++)<span class="hljs-comment">//遍历每种情况</span><br>        &#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>,tmp=n;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">15</span>;j++)<br>            &#123;<br>              <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))&#123;<span class="hljs-comment">//可以假设选取该位置为加油站</span><br>                  tmp*=<span class="hljs-number">2</span>;<br>                  a++;<br>              &#125;<br>              <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不选取该位置为十字路口</span><br>                  tmp-=<span class="hljs-number">1</span>;<br>                  b++;<br>              &#125;<br>              <span class="hljs-keyword">if</span>(tmp&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp==<span class="hljs-number">0</span>&amp;&amp;a==<span class="hljs-number">5</span>&amp;&amp;b==<span class="hljs-number">10</span>) ans++;<span class="hljs-comment">//满足题目条件的情况就加上1</span><br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="权利指数">权利指数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>在选举问题中，总共有n个小团体，每个小团体拥有一定数量的选票数。如果其中m个小团体的票数和超过总票数的一半，则此组合为“获胜联盟”。n个团体可形成若干个获胜联盟。一个小团体要成为一个“关键加入者”的条件是：在其所在的获胜联盟中，如果缺少了这个小团体的加入，则此联盟不能成为获胜联盟。一个小团体的权利指数是指：一个小团体在所有获胜联盟中成为“关键加入者”的次数。请你计算每个小团体的权利指数。<br>Input<br>输入数据的第一行为一个正整数T，表示有T组测试数据。每一组测试数据的第一行为一个正整数n（0&lt;n&lt;=20）。第二行有n个正整数，分别表示1到n号小团体的票数。<br>Output<br>对每组测试数据，在同一个行按顺序输出1到n号小团体的权利指数。<br>Sample Input<br>2<br>1<br>10<br>7<br>5 7 4 8 6 7 5<br>Sample Output<br>1<br>16 22 16 24 20 22 16<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        <span class="hljs-type">int</span> x,a[<span class="hljs-number">20</span>],sum=<span class="hljs-number">0</span>,flag[<span class="hljs-number">20</span>],b[<span class="hljs-number">20</span>],ans;<span class="hljs-comment">//注意总数再每组数据时要清零，我就栽在这非常久</span><br>        cin&gt;&gt;x;<br>        <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<span class="hljs-comment">//memset下保证上次数据不会影响</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x;i++)&#123;<br>            cin&gt;&gt;a[i];<br>            sum+=a[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;x);i++)<br>        &#123;<br>            <span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(flag));<span class="hljs-comment">//这里是关键，用flag记录每种子集选取了哪些位置，以便下面查找情况</span><br>            ans=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>                &#123; ans+=a[j];flag[j]=<span class="hljs-number">1</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans&lt;=sum/<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//满足题目条件，找本来不满足，多了一个位置后就可以满足的情况。</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">0</span>;z&lt;x;z++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(flag[z]==<span class="hljs-number">0</span>&amp;&amp;ans+a[z]&gt;sum/<span class="hljs-number">2</span>) b[z]++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/*if(ans&gt;=sum/2)&#123;//我原本是顺着题目意思写的，但这里我还不清楚为啥这样写oj过不去</span><br><span class="hljs-comment">                for(int z=0;z&lt;x;z++)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                    if(flag[z]==1&amp;&amp;ans-a[z]&lt;sum/2) b[z]++;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;*/</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">-1</span>;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;b[x<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>二分</h1>
<h2 id="整数二分">整数二分</h2>
<p>二分模板1:（求下标最小的x）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>   <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(a[mid]&gt;=x) r=mid;<br>   <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//l的范围时[l,mid],r的范围时(mid,r]</span><br><span class="hljs-comment">//当l+r&gt;&gt;1时是向下取整，所以不用担心死循环</span><br></code></pre></td></tr></table></figure>
<p>二分模板2：（求下标最大的x）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>   <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(a[mid]&lt;=x) l=mid;<br>   <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//l的范围时[l,mid),r的范围时[mid,r]</span><br><span class="hljs-comment">//当mid=l+r+1&gt;&gt;1 因为在特殊条件下有可能死循环，当只有两个数，且正好按要求排序了的时候，如果选l+r&gt;&gt;1，因为会向下取整导致死循环</span><br></code></pre></td></tr></table></figure>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs subunit">789 数的范围<br><br>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。<br><br>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br><br>如果数组中不存在该元素，则返回 <span class="hljs-string">-1</span> <span class="hljs-string">-1</span>。<br><br>输入格式<br>第一行包含整数 n 和 q，表示数组长度和询问个数。<br><br>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。<br><br>接下来 q 行，每行包含一个整数 k，表示一个询问元素。<br><br>输出格式<br>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br><br>如果数组中不存在该元素，则返回 <span class="hljs-string">-1</span> <span class="hljs-string">-1</span>。<br><br>数据范围<br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000<br>输入样例：<br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br>输出样例：<br>3 4<br>5 5<br><span class="hljs-string">-1</span> <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid]&gt;=k) r=mid;<span class="hljs-comment">//找最早出现的k，那么k后的数都满足大于等于k</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l]!=k) cout&lt;&lt;<span class="hljs-string">&quot;-1 -1&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid]&lt;=k) l=mid;<span class="hljs-comment">//找最后出现的k,那么k前面的数都满足小于等于k</span><br>                <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            cout&lt;&lt;l&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="浮点数二分">浮点数二分</h2>
<p>模板</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-6</span>)<br>&#123;<br>  mid=(l+r)/<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid;<br>  <span class="hljs-keyword">else</span> l=mid;<br>&#125;<br><span class="hljs-comment">//当r-l&lt;1e-8的时候，r和l的值可以近似认为是答案</span><br></code></pre></td></tr></table></figure>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个浮点数 <span class="hljs-built_in">n</span>，求它的三次方根。<br><br>输入格式<br>共一行，包含一个浮点数 <span class="hljs-built_in">n</span>。<br><br>输出格式<br>共一行，包含一个浮点数，表示问题的解。<br><br>注意，结果保留 <span class="hljs-number">6</span> 位小数。<br><br>数据范围<br>−<span class="hljs-number">10000</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">10000</span><br>输入样例：<br><span class="hljs-number">1000.00</span><br>输出样例：<br><span class="hljs-number">10.000000</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-10000</span>,r=<span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((mid*mid*mid)&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>高精度</h1>
<h2 id="高精度加法">高精度加法</h2>
<p>高精度加法关键在于将每一位数字拆解，然后逆向存入数组里（比如输入进来1234，在传入数组中的时候值为4321，然后再利用小学数学加法的知识，每一位数字的值为A[I]+B[I]+t(t为进位的值)，循环进行直到遍历到数组a和b的结束位置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的和。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的和。<br><br>数据范围<br>1≤整数长度≤100000<br>输入样例：<br>12<br>23<br>输出样例：<br>35<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span><span class="hljs-comment">//为啥是传入指针，因为数组A和B的内存过大，如果传入形参会导致内存溢出</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//遍历到数组A或数组B结束位置</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<span class="hljs-comment">//如果没到A结束位置就加上该位置的值</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//传入未进位的部分，比如t=18,在算数中，1进位，然后7传入</span><br>        t/=<span class="hljs-number">10</span>;<span class="hljs-comment">//记录下进位的数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<span class="hljs-comment">//因为数据过大，只能用字符串形式传入</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//a=&quot;1234&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//逆向计入每一位的值 A[]=[4,3,2,1]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="leetcode66题">leetcode66题</h3>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">66.</span> 加一<br>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br><br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br><br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*我的做法,相对麻烦了点，和模板的高精度加法类似*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>          vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>          <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>          &#123;<br>              t+=digits[i];<br>              ans.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>              t/=<span class="hljs-number">10</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span>(t) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>          <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>          <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*题解的做法，就是找到从尾巴开始的最长的9，如果从尾部开始有9就变成0，然后往前移动，如果超出了最开头，就把vector加一*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;digits[i]==<span class="hljs-number">9</span>)<br>        &#123;<br>           digits[i]=<span class="hljs-number">0</span>;<br>           i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">-1</span>) digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> digits[i]+;<br>        <span class="hljs-keyword">return</span> digits;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="leetcode第二题">leetcode第二题</h3>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2</span>. 两数相加<br>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br><br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br><br>你可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数都不会以 <span class="hljs-number">0</span> 开头。<br>示例 <span class="hljs-number">1</span>：<br>输入：l1 = <span class="hljs-selector-attr">[2,4,3]</span>, l2 = <span class="hljs-selector-attr">[5,6,4]</span><br>输出：<span class="hljs-selector-attr">[7,0,8]</span><br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span>.<br>示例 <span class="hljs-number">2</span>：<br><br>输入：l1 = <span class="hljs-selector-attr">[0]</span>, l2 = <span class="hljs-selector-attr">[0]</span><br>输出：<span class="hljs-selector-attr">[0]</span><br>示例 <span class="hljs-number">3</span>：<br><br>输入：l1 = <span class="hljs-selector-attr">[9,9,9,9,9,9,9]</span>, l2 = <span class="hljs-selector-attr">[9,9,9,9]</span><br>输出：<span class="hljs-selector-attr">[8,9,9,9,0,0,0,1]</span><br> <br><br>提示：<br><br>每个链表中的节点数在范围 <span class="hljs-selector-attr">[1, 100]</span> 内<br><span class="hljs-number">0</span> &lt;= Node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">9</span><br>题目数据保证列表表示的数字不含前导零<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*pMove=head;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1||l2||t)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(l1) t+=l1-&gt;val;<br>           <span class="hljs-keyword">if</span>(l2) t+=l2-&gt;val;<br>           pMove-&gt;next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t%<span class="hljs-number">10</span>);<br>           t/=<span class="hljs-number">10</span>;<br>           pMove=pMove-&gt;next;<br>            <span class="hljs-comment">/*这个很重要，因为如果用for语句的话，当l1没有时还想下找就会报错*/</span><br>           <span class="hljs-keyword">if</span>(l1) l1=l1-&gt;next;<br>           <span class="hljs-keyword">if</span>(l2) l2=l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="高精度减法">高精度减法</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的差。<br><br>数据范围<br>1≤整数长度≤105<br>输入样例：<br>32<br>11<br>输出样例：<br>21<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//如果长度不一样就判断A是否长于B</span><br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>();i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//遍历知道找到第一个不一样的数，判断A[i]是否大于B[i]</span><br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果循环到结束说明一样长，成真和成假都可以</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        t=A[i]-t;<span class="hljs-comment">//算上是否有进位</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t-=B[i];<span class="hljs-comment">//如果在B的范围内就减去B[i]</span><br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//如果A[i]-t&gt;B[i]的话,+10取余不会有任何影响，但是如果小于的话加10取余就相当于进位</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;<span class="hljs-comment">//判断石是否需要进位</span><br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//消去前置零 比如003，要消去00，得出3，因为高位在后面，所以只需要判断back时候是零，如果是零的话，就pop出来</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//别忘了传进来的是字符串，转化成数字需要减去&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))<span class="hljs-comment">//进行比较是否A&gt;B，如果大于的话就正常的进行相加减，如果小于的话就转换成B-A，然后加负号</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<span class="hljs-comment">//传入的时候是个位数开始到最高位，所以输出的时候要倒着输出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(B,A);<br>        cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>##　高精度乘法</p>
<h3 id="高精度X低精度">高精度X低精度</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">mul</span>(vector &lt;<span class="hljs-type">int</span>&gt; &amp; A, <span class="hljs-type">int</span> b) &#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>        t += A[i] * b;       <span class="hljs-comment">// t + A[i] * b = 7218</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>); <span class="hljs-comment">// 只取个位 8</span><br>        t /= <span class="hljs-number">10</span>;             <span class="hljs-comment">// 721 看作 进位</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t) &#123;            <span class="hljs-comment">// 处理最后剩余的 t</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    vector &lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        cout &lt;&lt; C[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="高精度X高精度">高精度X高精度</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size() + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始化为 0，C的size可以大一点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j++)<br>            C[i + j] += A[i] * B[j];<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// i = C.size() - 1时 t 一定小于 10</span><br>        t += C[i];<br>        C[i] = t % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 必须要去前导 0，因为最高位很可能是 0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b; <span class="hljs-comment">// a = &quot;1222323&quot;, b = &quot;2323423423&quot;</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        cout &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="acwing例题">acwing例题</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">793</span> 高精度乘法<br><br>给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>输入格式<br>共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共一行，包含 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">0</span>≤<span class="hljs-selector-tag">B</span>≤<span class="hljs-number">10000</span><br>输入样例：<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>输出样例：<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">高精度乘以低精度<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//讲每一位都乘以b，然后去进位</span><br>    &#123;<br>        t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)<span class="hljs-comment">//如果还有进位没去完就一直取，取到结束为止</span><br>    &#123;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//如果有前置零，要去掉前置零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//常规操作</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">mul</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="高精度除法">高精度除法</h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span>，<span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>/<span class="hljs-selector-tag">B</span> 的商和余数。<br><br>输入格式<br>共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共两行，第一行输出所求的商，第二行输出所求余数。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">B</span>≤<span class="hljs-number">10000</span>,<br><span class="hljs-selector-tag">B</span> 一定不为 <span class="hljs-number">0</span><br>输入样例：<br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br>输出样例：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp;r)</span><span class="hljs-comment">//将余数传入，利用余数来求值</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//除法就是上一位的余数*10+这一位然后再除以除数反复得到答案</span><br>    &#123;<br>        r=r*<span class="hljs-number">10</span>+A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r/b);<br>        r%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//因为是正向存储，所以reverse一下</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除前置零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//前面都一样</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b,r=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">divide</span>(A,b,r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="leetcode67题">leetcode67题</h3>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">67</span>. 二进制求和<br>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 <span class="hljs-number">1</span> 和 <span class="hljs-number">0</span>。<br><br>示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出: <span class="hljs-string">&quot;100&quot;</span><br>示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1011&quot;</span><br>输出: <span class="hljs-string">&quot;10101&quot;</span><br><br>提示：<br>每个字符串仅由字符 <span class="hljs-string">&#x27;0&#x27;</span> 或 <span class="hljs-string">&#x27;1&#x27;</span> 组成。<br><span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.length</span>, <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>字符串如果不是 <span class="hljs-string">&quot;0&quot;</span> ，就都不含前导零。<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高精度加法的思想</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>       vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>       string C;<br>       <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>           <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>           C+=(t%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>           t/=<span class="hljs-number">2</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(t) C+=(<span class="hljs-number">1</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>       <span class="hljs-keyword">return</span> C;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h1>前缀和</h1>
<h2 id="一维前缀和">一维前缀和</h2>
<p>将A[1]+…A[n] (n为变量)的值一一单独存入另一个数组中，然后查找区间的前缀和时，只要S[R]-S[L-1]即可得到区间前缀和（为啥是l-1，因为S[R]=A[1]+…A[R]，S[L-1]=A[1]+…+A[L-1],两个相减就可以得到A[L]+…+A[R]</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">795</span> 前缀和<br>输入一个长度为 <span class="hljs-built_in">n</span> 的整数序列。<br><br>接下来再输入 m 个询问，每个询问输入一对 l,r。<br><br>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。<br><br>输入格式<br>第一行包含两个整数 <span class="hljs-built_in">n</span> 和 m。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数，表示整数数列。<br><br>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。<br><br>输出格式<br>共 m 行，每行输出一个询问的结果。<br><br>数据范围<br><span class="hljs-number">1</span>≤l≤r≤<span class="hljs-built_in">n</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">100000</span>,<br>−<span class="hljs-number">1000</span>≤数列中元素的值≤<span class="hljs-number">1000</span><br>输入样例：<br><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;q[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="hljs-number">-1</span>]+q[i];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        cout&lt;&lt;s[r]-s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="leetcode303">leetcode303</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">303.</span> 区域和检索 <span class="hljs-operator">-</span> 数组不可变<br>给定一个整数数组  nums，处理以下类型的多个查询:<br><br>计算索引 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> （包含 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span>）之间的 nums 元素的 和 ，其中 <span class="hljs-keyword">left</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">right</span><br>实现 NumArray 类：<br><br>NumArray(<span class="hljs-type">int</span>[] nums) 使用数组 nums 初始化对象<br><span class="hljs-type">int</span> sumRange(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) 返回数组 nums 中索引 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> 之间的元素的 总和 ，包含 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> 两点（也就是 nums[<span class="hljs-keyword">left</span>] <span class="hljs-operator">+</span> nums[<span class="hljs-keyword">left</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> ... <span class="hljs-operator">+</span> nums[<span class="hljs-keyword">right</span>] )<br> <br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<br>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]<br>[[[<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>]], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>]]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>]<br><br>解释：<br>NumArray numArray <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> NumArray([<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>]);<br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ((<span class="hljs-number">-2</span>) <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-operator">+</span> <span class="hljs-number">3</span>)<br>numArray.sumRange(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> (<span class="hljs-number">3</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-1</span>)) <br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span> ((<span class="hljs-number">-2</span>) <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-operator">+</span> <span class="hljs-number">3</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-1</span>))<br> <br><br>提示：<br><br><span class="hljs-number">1</span> <span class="hljs-operator">&lt;=</span> nums.length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">104</span><br><span class="hljs-number">-105</span> <span class="hljs-operator">&lt;=</span> nums[i] <span class="hljs-operator">&lt;=</span> <span class="hljs-number">105</span><br><span class="hljs-number">0</span> <span class="hljs-operator">&lt;=</span> i <span class="hljs-operator">&lt;=</span> j <span class="hljs-operator">&lt;</span> nums.length<br>最多调用 <span class="hljs-number">104</span> 次 sumRange 方法<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;sum;<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        sum.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();i++)<br>           sum.<span class="hljs-built_in">push_back</span>(sum[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> sum[right+<span class="hljs-number">1</span>]-sum[left];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h2 id="二维前缀和">二维前缀和</h2>
<p>二维前缀和推导<br>
如图：<img src="https://s2.loli.net/2022/04/16/SfGoOxAmku5Dild.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>紫色面积是指(1,1)左上角到(i,j-1)右下角的矩形面积, 绿色面积是指(1,1)左上角到(i-1, j )右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。<img src="https://s2.loli.net/2022/04/16/4i6l5raRcU7zgQX.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>从图中我们很容易看出，整个外围蓝色矩形面积s[i] [j] = 绿色面积s[i-1] [j] + 紫色面积s[i] [j-1] - 重复加的红色的面积s[i-1] [j-1]+小方块的面积a[i] [j];</p>
<p>因此得出二维前缀和预处理公式</p>
<p>s[i] [j] = s[i-1] [j] + s[i] [j-1 ] + a[i] [j] - s[i-1] [ j-1] (是离散的数，不是面积哈)</p>
<p>接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</p>
<p>如图：<img src="https://s2.loli.net/2022/04/16/B9GnoqSmsPZfFpC.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>紫色面积是指 ( 1,1 )左上角到(x1-1,y2)右下角的矩形面积 ，黄色面积是指(1,1)左上角到(x2,y1-1)右下角的矩形面积；</p>
<p>不难推出：<img src="https://s2.loli.net/2022/04/16/jdTypKLX8qQ1tbA.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p>
<p>绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]</p>
<p>因此二维前缀和的结论为：</p>
<p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>
s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tap">796 二维前缀和<br>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。<br><br>对于每个询问输出子矩阵中所有数的和。<br><br>输入格式<br>第一行包含三个整数 n，m，q。<br><br>接下来 n 行，每行包含 m 个整数，表示整数矩阵。<br><br>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。<br><br>输出格式<br>共 q 行，每行输出一个询问的结果。<br><br>数据范围<br>1≤n,m≤1000,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000<br>输入样例：<br>3<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 7 </span>2 4<br>3<span class="hljs-number"> 6 </span>2 8<br>2<span class="hljs-number"> 1 </span>2 3<br>1<span class="hljs-number"> 1 </span>2 2<br>2<span class="hljs-number"> 1 </span>3 4<br>1<span class="hljs-number"> 3 </span>3 4<br>输出样例：<br>17<br>27<br>21<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,x2,y1,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="hljs-number">-1</span>][y2]-s[x2][y1<span class="hljs-number">-1</span>]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="leetcode304">leetcode304</h3>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">304.</span> 二维区域和检索 - 矩阵不可变<br>给定一个二维矩阵 matrix，以下类型的多个请求：<br><br>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 <span class="hljs-symbol">NumMatrix</span> 类：<br><br><span class="hljs-symbol">NumMatrix</span>(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。<br> <br><br>示例 <span class="hljs-number">1</span>：<br>自己取leetcode上看吧<br>输入: <br>[<span class="hljs-string">&quot;NumMatrix&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>]<br>[[[[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]]],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]]<br>输出: <br>[null, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]<br><br>解释:<br><span class="hljs-symbol">NumMatrix</span> numMatrix = new <span class="hljs-symbol">NumMatrix</span>([[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]]);<br>numMatrix.sumRegion(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>); // return <span class="hljs-number">8</span> (红色矩形框的元素总和)<br>numMatrix.sumRegion(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); // return <span class="hljs-number">11</span> (绿色矩形框的元素总和)<br>numMatrix.sumRegion(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); // return <span class="hljs-number">12</span> (蓝色矩形框的元素总和)<br> <br><br>提示：<br><br>m == matrix.length<br>n == matrix[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">200</span><br><span class="hljs-number">-105</span> &lt;= matrix[i][j] &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">0</span> &lt;= row1 &lt;= row2 &lt; m<br><span class="hljs-number">0</span> &lt;= col1 &lt;= col2 &lt; n<br>最多调用 <span class="hljs-number">104</span> 次 sumRegion 方法<br>通过次数<span class="hljs-number">86</span>,<span class="hljs-number">115</span>提交次数<span class="hljs-number">148</span>,<span class="hljs-number">070</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum[<span class="hljs-number">2000</span>][<span class="hljs-number">2000</span>];<br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>       <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>(),m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得vector数组的列数和每行长度</span><br>       <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//最后matrix[i-1][j-1]是因为我们是从i=1,j=1开始，但是原数组是从i=0,j=0开始</span><br>       &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sum[row1][col2+<span class="hljs-number">1</span>]-sum[row2+<span class="hljs-number">1</span>][col1]+sum[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sum;<span class="hljs-comment">//vector数组</span><br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>       <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>(),m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得原数组的列数和每行长度</span><br>       <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        sum.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//多加一行和一列，从第一行和第一列开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//最后matrix[i-1][j-1]是因为我们是从i=1,j=1开始，但是原数组是从i=0,j=0开始</span><br>       &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sum[row1][col2+<span class="hljs-number">1</span>]-sum[row2+<span class="hljs-number">1</span>][col1]+sum[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h1>差分</h1>
<h2 id="一维差分">一维差分</h2>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/26588/">详细知识链接</a></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入一个长度为 n 的整数序列。<br><br>接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。<br><br>请你输出进行完所有操作后的序列。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>第二行包含 n 个整数，表示整数序列。<br><br>接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。<br><br>输出格式<br>共一行，包含 n 个整数，表示最终序列。<br><br>数据范围<br>1≤n,m≤100000,<br>1≤l≤r≤n,<br>−1000≤c≤1000,<br>−1000≤整数序列中元素的值≤1000<br>输入样例：<br>6 3<br>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 1 </span>2 1<br>1<span class="hljs-number"> 3 </span>1<br>3<span class="hljs-number"> 5 </span>1<br>1<span class="hljs-number"> 6 </span>1<br>输出样例：<br>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 3 </span>4 2<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        b[l]+=c;<br>        b[r+<span class="hljs-number">1</span>]-=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i]=a[i<span class="hljs-number">-1</span>]+b[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>y总版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//插入每一个数，并再下一个数后减去该数，在进行b[i]+=b[i-1]时就可以得到b[i]</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二维差分">二维差分</h2>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/27325/">二维差分知识点</a></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tap">798. 差分矩阵<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。<br><br>每个操作都要将选中的子矩阵中的每个元素的值加上 c。<br><br>请你将进行完所有操作后的矩阵输出。<br><br>输入格式<br>第一行包含整数 n,m,q。<br><br>接下来 n 行，每行包含 m 个整数，表示整数矩阵。<br><br>接下来 q 行，每行包含<span class="hljs-number"> 5 </span>个整数 x1,y1,x2,y2,c，表示一个操作。<br><br>输出格式<br>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。<br><br>数据范围<br>1≤n,m≤1000,<br>1≤q≤100000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤c≤1000,<br>−1000≤矩阵内元素的值≤1000<br>输入样例：<br>3<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 2 </span>2 1<br>3<span class="hljs-number"> 2 </span>2 1<br>1<span class="hljs-number"> 1 </span>1 1<br>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>1<br>1<span class="hljs-number"> 3 </span>2<span class="hljs-number"> 3 </span>2<br>3<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 4 </span>1<br>输出样例：<br>2<span class="hljs-number"> 3 </span>4 1<br>4<span class="hljs-number"> 3 </span>4 1<br>2<span class="hljs-number"> 2 </span>2 2<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N],matrix[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         cin&gt;&gt;a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        b[x1][y1]+=c;<span class="hljs-comment">//进行二维差分运算</span><br>        b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>        b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>        b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        matrix[i][j]=matrix[i<span class="hljs-number">-1</span>][j]+matrix[i][j<span class="hljs-number">-1</span>]+b[i][j]-matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">/*算出全部子矩阵加减操作后的前缀和*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>      &#123;<br>            cout&lt;&lt;a[i][j]+matrix[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">/*将操作后的前缀和与原数组相加得到答案*/</span><br>      &#125;<br>      cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>双指针算法</h1>
<p>找双指针算法可以先写一个暴力的o(n^2)，然后找i和j是否满足单调性，如果满足就可以使用双指针算法</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">799</span>. 最长连续不重复子序列<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>给定一个长度为 <span class="hljs-built_in">n</span> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（均在 <span class="hljs-number">0</span>∼<span class="hljs-number">105</span> 范围内），表示整数序列。<br><br>输出格式<br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">105</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        s[a[i]]++;<span class="hljs-comment">//相当于选中当前当前这个数</span><br>        <span class="hljs-comment">//为啥可以只查找A[i]是否重复，因为前面已经是连续不重复了，重复只能在a[i]</span><br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果有重复，j开始查找，直到查找到没有没有数和a[i]重复为止</span><br>        &#123;<br>            s[a[j]]--;<span class="hljs-comment">//右移相当于当前这个选中状态被取消要减去1；</span><br>            j++;<br>        &#125;<br>        res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>链表的定义</h1>
<p>链表是物理存储单元上<strong>非连续</strong>的、<strong>非顺序</strong>的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针。</p>
<p><img src="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061606450.png" srcset="/img/loading.gif" lazyload alt="屏幕截图 2022-01-06 160632"></p>
<p>链表在内存中采用每个结点都分配在<strong>非连续</strong>的位置，结点与结点之间通过指针连在了一起，查找元素时需要遍历查找。</p>
<h1>链表的表示</h1>
<h2 id="定义头节点：">定义头节点：</h2>
<p>由于链表的特点（查询或删除元素都要从头结点开始）,所以我们只要在链表中定义头结点即可(我学习采用的是头节点无数据型的链表表示)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061616514.png" srcset="/img/loading.gif" lazyload alt="1577669607-4eeed00317fbd8a"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;Node;<span class="hljs-comment">//定义结构体，并创建结构体指针用来链接节点</span><br>Node* <span class="hljs-title function_">createList</span><span class="hljs-params">()</span><br>&#123;<br>   Node* headNode;<br>   headNode=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>   headNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>   <span class="hljs-keyword">return</span> headNode;<br>&#125;<span class="hljs-comment">//创建结构体指针需要向内存申请空间，通常来说头节点初始化不指向任何节点</span><br></code></pre></td></tr></table></figure>
<h2 id="创建节点：">创建节点：</h2>
<p>创建完头节点后我们需要创建新的节点用来存储数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    Node* newNode;<br>    newNode=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    newNode-&gt;data=data;<br>    newNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="连接节点：">连接节点：</h2>
<p>链接节点可以采用两种方式：<strong>1. 头插法 2.尾插法</strong></p>
<h3 id="头插法：">头插法：</h3>
<p><img src="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061618829.gif" srcset="/img/loading.gif" lazyload alt="1577669607-2500a8c3aad50ab"></p>
<p><strong>具体步骤如上图所示，将将前一个节点指向插入的节点，将插入的节点指向原下一个节点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertList</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> data)</span><br>&#123;<br>    Node* newNode=createNode(data);<br>    newNode-&gt;next=headNode-&gt;next;<br>    headNode-&gt;next=newNode;<br>&#125;<span class="hljs-comment">//因为头插法需要头节点所以将头节点传入函数</span><br><span class="hljs-comment">//头插法最终输出时数据会逆向输出，因为前面的数据在链接后变到了最尾巴，输出时是顺序输出</span><br></code></pre></td></tr></table></figure>
<h3 id="尾插法（一）：">尾插法（一）：</h3>
<p>观察头插法会发现，插入节点时永远会在头节点插入，导致数据是逆序的。那么只要数据都是在链表的最后插入就不会有这个问题。尾插法在头插法的基础上，设置了一个单独的结构体指针保证结构体在插入时永远是在尾巴插入，这样数据存储就是顺序的。</p>
<p><strong>这种尾插法有一个缺点，就是只能连续插入，不能分开插入，所以我们就有了第二种尾插法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span><br>&#123;<br>    Node* pMove;<br>    Node* headNode;<br>    headNode=pMove=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    pMove-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> data;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入您的数据：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data);<br>        <span class="hljs-keyword">if</span>(data==<span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>;<br>        Node* newNode=createNode(data);<br>        pMove-&gt;next=newNode;<br>        pMove=newNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> headNode;<br>&#125;<span class="hljs-comment">//这里要创建headNode的原因是因为要先让headNode指向下一个节点不未NULL，要不然链表就断掉了。</span><br></code></pre></td></tr></table></figure>
<h3 id="尾插法（二）">尾插法（二）</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   Node* headNode=createList();<span class="hljs-comment">//建立头节点</span><br>   Node* tail=headNode;<span class="hljs-comment">//建立一个指针用来插入节点</span><br>   <span class="hljs-comment">//下面为测试节点</span><br>   LinkList(&amp;tail,<span class="hljs-number">1</span>);<span class="hljs-comment">//结构体不包括地址，所以必须取地址符</span><br>   LinkList(&amp;tail,<span class="hljs-number">2</span>);<br>   LinkList(&amp;tail,<span class="hljs-number">3</span>);<br>   printList(headNode);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>Node* <span class="hljs-title function_">LinkList</span><span class="hljs-params">(Node **ptail,<span class="hljs-type">int</span> data)</span><span class="hljs-comment">//实参引用结构题二级指针，来保证原函数tail能一直指向尾巴</span><br>&#123;<br>    Node* newNode=createNode(data);<br>    (*ptail)-&gt;next=newNode;<span class="hljs-comment">//这里要注意：*号的优先级比-&gt;低，所以必须用括号括起来</span><br>    (*ptail)=newNode;<br>    <span class="hljs-keyword">return</span> (*ptail);<span class="hljs-comment">//返回结构体指针</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="在任意位置插入节点">在任意位置插入节点</h3>
<p>在任意处插入节点的重要点就在于要先找到要插入位置的地址，因为链表只能知道下一个节点，所以必须要遍历查找，并返回节点的地址，然后插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">foundNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> searchdata)</span><br>&#123;<br>    Node* pFound;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(pFound=headNode-&gt;next;pFound;pFound=pFound-&gt;next)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(pFound-&gt;data==searchdata)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了\n&quot;</span>);<br>          isFound=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">return</span> pFound;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没找到\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insertNode</span><span class="hljs-params">(Node** pFound,<span class="hljs-type">int</span> data)</span><br>&#123;<br>   Node* newNode=createNode(data);<br>   newNode-&gt;next=(*pFound)-&gt;next;<br>   (*pFound)-&gt;next=newNode;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    Node* pFound;<br>    Node* headNode=createList();<br>    insertList(headNode,<span class="hljs-number">1</span>);<br>    insertList(headNode,<span class="hljs-number">2</span>);<br>    insertList(headNode,<span class="hljs-number">3</span>);<br>    insertList(headNode,<span class="hljs-number">4</span>);<br>    pFound=foundNode(headNode,<span class="hljs-number">2</span>);<br>    insertNode(&amp;pFound,<span class="hljs-number">6</span>);<br>    printList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="打印链表">打印链表</h3>
<p>链表只能循环打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(Node* headNode)</span><br>&#123;<br>   Node* pMove=headNode-&gt;next;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印链表\n&quot;</span>);<br>   <span class="hljs-keyword">while</span>(pMove)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>,pMove-&gt;data);<br>      pMove=pMove-&gt;next;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="查找链表">查找链表</h3>
<p>查找链表我暂时只学到遍历查找，等后续学到了会更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">searchNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> searchdata)</span><br>&#123;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    Node* pMove=headNode-&gt;next;<br>    <span class="hljs-keyword">while</span>(pMove)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pMove-&gt;data==searchdata)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在此链表中找到了！\n&quot;</span>);<br>            isFound=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pMove=pMove-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;对不起没有找到！\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="删除节点">删除节点</h3>
<p>一样的只会循环查找后删除，后续更新新的方法</p>
<p><strong>删除节点有几个要注意的地方：</strong></p>
<p><strong>一：首先要定义两个指针，因为删除节点需要该节点的前节点链接到该节点的下一个节点，而单链表只能知道下一个节点，所以必须要两个指针来删除</strong></p>
<p><strong>二：就是要注意，当删除的节点是头节点，那么就必须特殊对待，直接将headNode指向删掉节点的下一个节点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> deletenumber)</span><br>&#123;<br>    Node *q,*p;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(q=<span class="hljs-literal">NULL</span>,p=headNode-&gt;next;p;q=p,p=p-&gt;next)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==deletenumber)<span class="hljs-comment">//找到该节点</span><br>        &#123;<br>            isFound=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(!q)<span class="hljs-comment">//如果发现前节点是空，说明是头节点，那么只需要headNode指向p-&gt;next</span><br>                headNode=p-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                q-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未删除成功\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="静态链表">静态链表</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> val[N],ne[N],head[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head=<span class="hljs-number">-1</span>;<br>    idx=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//插头</span><br><span class="hljs-type">void</span> add-to-<span class="hljs-built_in">head</span>(<span class="hljs-type">int</span> x)<br>&#123;<br>    e[idx]=x;<br>    ne[idx]=head;<br>    head=idx;<br>    idx++;<br>&#125;<br><span class="hljs-comment">//插到下标为k的地方</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=x;<br>    ne[idx]=ne[pos];<br>    ne[pos]=idx;<br>    idx++;<br>&#125;<br><span class="hljs-comment">//删除下标为k的后面的结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k]=ne[ne[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="826-单链表">826. 单链表</h2>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个单链表，链表初始为空，支持三种操作：<br><br>向链表头插入一个数；<br>删除第 <span class="hljs-variable">k</span> 个插入的数后面的数；<br>在第 <span class="hljs-variable">k</span> 个插入的数后插入一个数。<br>现在要对该链表进行 <span class="hljs-variable">M</span> 次操作，进行完所有操作后，从头到尾输出整个链表。<br><br>注意<span class="hljs-operator">:</span>题目中第 <span class="hljs-variable">k</span> 个插入的数并不是指当前链表的第 <span class="hljs-variable">k</span> 个数。例如操作过程中一共插入了 <span class="hljs-variable">n</span> 个数，则按照插入的时间顺序，这 <span class="hljs-variable">n</span> 个数依次为：第 <span class="hljs-number">1</span> 个插入的数，第 <span class="hljs-number">2</span> 个插入的数，…第 <span class="hljs-variable">n</span> 个插入的数。<br><br>输入格式<br>第一行包含整数 <span class="hljs-variable">M</span>，表示操作次数。<br><br>接下来 <span class="hljs-variable">M</span> 行，每行包含一个操作命令，操作命令可能为以下几种：<br><br><span class="hljs-variable">H</span> <span class="hljs-variable">x</span>，表示向链表头插入一个数 <span class="hljs-variable">x</span>。<br><span class="hljs-built_in">D</span> <span class="hljs-variable">k</span>，表示删除第 <span class="hljs-variable">k</span> 个插入的数后面的数（当 <span class="hljs-variable">k</span> 为 <span class="hljs-number">0</span> 时，表示删除头结点）。<br><span class="hljs-built_in">I</span> <span class="hljs-variable">k</span> <span class="hljs-variable">x</span>，表示在第 <span class="hljs-variable">k</span> 个插入的数后面插入一个数 <span class="hljs-variable">x</span>（此操作中 <span class="hljs-variable">k</span> 均大于 <span class="hljs-number">0</span>）。<br>输出格式<br>共一行，将整个链表从头到尾输出。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-variable">M</span>≤<span class="hljs-number">100000</span><br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br><span class="hljs-variable">H</span> <span class="hljs-number">9</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">0</span><br><span class="hljs-variable">H</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">6</span><br>输出样例：<br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> val[N],ne[N],head,idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head=<span class="hljs-number">-1</span>;<br>    idx=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    val[idx]=x;<br>    ne[idx]=head;<br>    head=idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletex</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k]=ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=x;<br>    ne[idx]=ne[k];<br>    ne[k]=idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">char</span> oper;<br>    <span class="hljs-type">int</span> n,x,k;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cin&gt;&gt;oper;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">add_to_head</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">add</span>(k<span class="hljs-number">-1</span>,x);<span class="hljs-comment">//减一和上面原理一样</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) head=ne[head];<span class="hljs-comment">//删去首节点也好理解，就是修改head最开始指向为原head指向的下一个指向</span><br>            <span class="hljs-built_in">deletex</span>(x<span class="hljs-number">-1</span>);<span class="hljs-comment">//为什么要减去一，因为idx是从0开始，而k是从1开始，删除第k个插入的数，就相当于</span><br>            <span class="hljs-comment">//在程序中删除第x-1个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> index=head;<br>    <span class="hljs-keyword">while</span>(index!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        cout&lt;&lt;val[index]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        index=ne[index];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>##　双链表</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5052/">双链表具体详解</a></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">827. 双链表<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个双链表，双链表初始为空，支持<span class="hljs-number"> 5 </span>种操作：<br><br>在最左侧插入一个数；<br>在最右侧插入一个数；<br>将第 k 个插入的数删除；<br>在第 k 个插入的数左侧插入一个数；<br>在第 k 个插入的数右侧插入一个数<br>现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。<br><br>注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第<span class="hljs-number"> 1 </span>个插入的数，第<span class="hljs-number"> 2 </span>个插入的数，…第 n 个插入的数。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：<br><br>L x，表示在链表的最左端插入数 x。<br>R x，表示在链表的最右端插入数 x。<br>D k，表示将第 k 个插入的数删除。<br>IL k x，表示在第 k 个插入的数左侧插入一个数。<br>IR k x，表示在第 k 个插入的数右侧插入一个数。<br>输出格式<br>共一行，将整个链表从左到右输出。<br><br>数据范围<br>1≤M≤100000<br>所有操作保证合法。<br><br>输入样例：<br>10<br>R 7<br>D 1<br>L 3<br>IL<span class="hljs-number"> 2 </span>10<br>D 3<br>IL<span class="hljs-number"> 2 </span>7<br>L 8<br>R 9<br>IL<span class="hljs-number"> 4 </span>7<br>IR<span class="hljs-number"> 2 </span>2<br>输出样例：<br>8<span class="hljs-number"> 7 </span>7<span class="hljs-number"> 3 </span>2 9<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里填你的代码^^</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> val[N],l[N],r[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=x;<br>    l[idx]=k;<br>    r[idx]=r[k];<br>    l[r[k]]=idx;<br>    r[k]=idx;<br>    idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//下标为0一定为头指针</span><br>    l[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标为1一定为尾指针</span><br>    idx=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]]=r[k];<br>    l[r[k]]=l[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string oper;<br>        <span class="hljs-type">int</span> k,x;<br>        cin&gt;&gt;oper;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>          cin&gt;&gt;x;<br>          <span class="hljs-built_in">insert</span>(l[<span class="hljs-number">1</span>],x);<span class="hljs-comment">//因为add函数是向右插，所以向左移动一位然后在该地插入，就相当于在原来的左边插入</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(l[k+<span class="hljs-number">1</span>],x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;IR&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(k+<span class="hljs-number">1</span>,x);<span class="hljs-comment">//因为idx从2开始，而k从1开始，所以要加一</span><br>            <span class="hljs-comment">//这里不用r[k+1]的原因是add函数是从k的右边插入，而k下标就对应了插入的k个数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">remove</span>(k+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=r[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">while</span>(cnt!=<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;val[cnt]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cnt=r[cnt];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br><br></code></pre></td></tr></table></figure>
<h1>栈和单调栈</h1>
<h2 id="表达式求值（栈的应用）">表达式求值（栈的应用）</h2>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">828</span>. 模拟栈<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个栈，栈初始为空，支持四种操作：<br><br>push <span class="hljs-keyword">x</span> – 向栈顶插入一个数 <span class="hljs-keyword">x</span>；<br><span class="hljs-keyword">pop</span> – 从栈顶弹出一个数；<br><span class="hljs-built_in">empty</span> – 判断栈是否为空；<br>query – 查询栈顶元素。<br>现在要对栈进行 M 个操作，其中的每个操作 <span class="hljs-number">3</span> 和操作 <span class="hljs-number">4</span> 都要输出相应的结果。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令为 push <span class="hljs-keyword">x</span>，<span class="hljs-keyword">pop</span>，<span class="hljs-built_in">empty</span>，query 中的一种。<br><br>输出格式<br>对于每个 <span class="hljs-built_in">empty</span> 和 query 操作都要输出一个查询结果，每个结果占一行。<br><br>其中，<span class="hljs-built_in">empty</span> 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤M≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-keyword">x</span>≤<span class="hljs-number">109</span><br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br>push <span class="hljs-number">5</span><br>query<br>push <span class="hljs-number">6</span><br><span class="hljs-keyword">pop</span><br>query<br><span class="hljs-keyword">pop</span><br><span class="hljs-built_in">empty</span><br>push <span class="hljs-number">4</span><br>query<br><span class="hljs-built_in">empty</span><br>输出样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br>YES<br><span class="hljs-number">4</span><br>NO<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">int</span>&gt; num;<br>stack&lt;<span class="hljs-type">int</span>&gt; op;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b=num.<span class="hljs-built_in">top</span>();num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a=num.<span class="hljs-built_in">top</span>();num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">char</span> operation=op.<span class="hljs-built_in">top</span>();op.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;+&#x27;</span>) ans=a+b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;-&#x27;</span>) ans=a-b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;*&#x27;</span>) ans=a*b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;/&#x27;</span>) ans=a/b;<br>    num.<span class="hljs-built_in">push</span>(ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; h=&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-number">2</span>&#125;&#125;;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>            <span class="hljs-type">int</span> j=i,a=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;<span class="hljs-built_in">isdigit</span>(s[j]))<br>            &#123;<br>                a=a*<span class="hljs-number">10</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                j++;<br>            &#125;<br>            num.<span class="hljs-built_in">push</span>(a);<br>            i=j<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(s[i]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()&amp;&amp;h[op.<span class="hljs-built_in">top</span>()]&gt;=h[s[i]]) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<br>    cout&lt;&lt;num.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>模拟队列和单调队列</h1>
<h2 id="模拟队列">模拟队列</h2>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade">实现一个队列，队列初始为空，支持四种操作：<br><br><span class="hljs-built_in">push</span> x – 向队尾插入一个数 x；<br><span class="hljs-built_in">pop</span> – 从队头弹出一个数；<br>empty – 判断队列是否为空；<br>query – 查询队头元素。<br>现在要对队列进行 M 个操作，其中的每个操作 <span class="hljs-number">3</span> 和操作 <span class="hljs-number">4</span> 都要输出相应的结果。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令为 <span class="hljs-built_in">push</span> x，<span class="hljs-built_in">pop</span>，empty，query 中的一种。<br><br>输出格式<br>对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。<br><br>其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤M≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤x≤<span class="hljs-number">109</span>,<br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">6</span><br>empty<br>query<br><span class="hljs-built_in">pop</span><br>empty<br><span class="hljs-built_in">push</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">pop</span><br>query<br><span class="hljs-built_in">push</span> <span class="hljs-number">6</span><br>输出样例：<br>NO<br><span class="hljs-number">6</span><br>YES<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> queue[N],head,tt=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化队列尾把为-1，这样插入的时候头和尾就会一样了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue[++tt]=x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head&lt;=tt) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> queue[head];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string operation;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cin&gt;&gt;operation;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>()&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="单调队列">单调队列</h2>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs subunit">154. 滑动窗口<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>给定一个大小为 n≤106 的数组。<br><br>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。<br><br>你只能在窗口中看到 k 个数字。<br><br>每次滑动窗口向右移动一个位置。<br><br>以下是一个例子：<br><br>该数组为 [1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7]，k 为 3。<br><br>窗口位置	最小值	最大值<br>[1 3 <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span> 5 3 6 7	<span class="hljs-string">-1</span>	3<br>1 [3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span>] 5 3 6 7	<span class="hljs-string">-3</span>	3<br>1 3 [<span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5] 3 6 7	<span class="hljs-string">-3</span>	5<br>1 3 <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span> 5 3] 6 7	<span class="hljs-string">-3</span>	5<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> [5 3 6] 7	3	6<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 [3 6 7]	3	7<br>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。<br><br>输入格式<br>输入包含两行。<br><br>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。<br><br>第二行有 n 个整数，代表数组的具体数值。<br><br>同行数据之间用空格隔开。<br><br>输出格式<br>输出包含两个。<br><br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br><br>第二行输出，从左至右，每个位置滑动窗口中的最大值。<br><br>输入样例：<br>8 3<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7<br>输出样例：<br><span class="hljs-string">-1</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> 3 3<br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure>
<p>思路：</p>
<p>最小值和最大值分开来做，两个for循环完全类似，都做以下四步：</p>
<ol>
<li>解决队首已经出窗口的问题;</li>
<li>解决队尾与当前元素a[i]不满足单调性的问题;</li>
<li>将当前元素下标加入队尾;</li>
<li>如果满足条件则输出结果;</li>
</ol>
<p>需要注意的细节：</p>
<ol>
<li>上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素</li>
<li>队列中存的是原数组的下标，取值时要再套一层，a[q[]];</li>
<li>算最大值前注意将hh和tt重置;</li>
<li>此题用cout会超时，只能用printf;</li>
<li>hh从0开始，数组下标也要从0开始。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> hh,tt=<span class="hljs-number">-1</span>,a[N],q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(hh&lt;=tt&amp;&amp;k&lt;i-q[hh]+<span class="hljs-number">1</span>)  hh++;<span class="hljs-comment">//维护窗口长度</span><br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--; <span class="hljs-comment">//使队列单调</span><br>        q[++tt]=i;<span class="hljs-comment">//传入最后一个满足的值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(hh&lt;=tt&amp;&amp;k&lt;i-q[hh]+<span class="hljs-number">1</span>) hh++;<br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;<br>        q[++tt]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>堆</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],hp[N],ph[N],cur_size,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a],hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a],h[b]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(x/<span class="hljs-number">2</span>&amp;&amp;h[x/<span class="hljs-number">2</span>]&gt;h[x])<br>    &#123;<br>       <span class="hljs-built_in">heap_swap</span>(x,x/<span class="hljs-number">2</span>);<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=x;<br>    <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>&lt;=cur_size&amp;&amp;h[<span class="hljs-number">2</span>*x]&lt;h[t]) t=<span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=cur_size&amp;&amp;h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x!=t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(t,x);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string op;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            cur_size++;<br>            m++;<br>            ph[m]=cur_size,hp[cur_size]=m;<br>            h[cur_size]=x;<br>            <span class="hljs-built_in">up</span>(cur_size);<span class="hljs-comment">//最后插入，需要up</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;PM&quot;</span>) cout&lt;&lt;h[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;DM&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>,cur_size);<br>            cur_size--;<br>            <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-type">int</span> k=ph[x];<span class="hljs-comment">//找到第k个插入的数在堆中的位置，因为删除k后，我们就丢失额了原先第k个数的位置</span><br>            <span class="hljs-built_in">heap_swap</span>(ph[x],cur_size);<br>            cur_size--;<br>            <span class="hljs-built_in">down</span>(k);<br>            <span class="hljs-built_in">up</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> k,x;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            h[ph[k]]=x;<br>            <span class="hljs-built_in">down</span>(ph[k]);<br>            <span class="hljs-built_in">up</span>(ph[k]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br></code></pre></td></tr></table></figure>
<h1>KMP</h1>
<p>KMP全称为Knuth Morris Pratt算法，三个单词分别是三个作者的名字。KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置(比如在“hello,world”主串中查找“world”模式串的位置)。</p>
<h2 id="KMP算法的高效体现在哪">KMP算法的高效体现在哪</h2>
<p>高效性是通过和其他字符串搜索算法对比得到的，在这里拿BF(Brute Force)算法做一下对比。BF算法是一种最朴素的暴力搜索算法。它的思想是在主串的[0, n-m]区间内依次截取长度为m的子串，看子串是否和模式串一样(n是主串的长度，m是子串的长度)。<br>
BF的时间复杂度是O(N*N)，存在很大优化空间。当模式串和主串匹配时，遇到模式串中某个字符不能匹配的情况，对于模式串中已经匹配过的那些字符，如果我们能找到一些规律，将模式串多往后移动几位，而不是像BF算法一样，每次把模式串移动一位，就可以提高算法的效率。比如说在“ababaababacd”中查找“ababac”，可以避免一些字符之间的比较。</p>
<p>下面通过一个具体的例子来看看可以跳过的情况。比如主模式串是”ababaeaba”,模式串是”ababacd”,在BF算法中，遇到不匹配的情况是这样处理的:</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">main:</span>    <span class="hljs-string">&quot;ababaeaba&quot;</span> // 例如这两个串，当<span class="hljs-keyword">sub</span>为<span class="hljs-string">&quot;ababaea&quot;</span>时和<span class="hljs-string">&quot;ababacd&quot;</span>进行对<br><span class="hljs-symbol">pattern:</span> <span class="hljs-string">&quot;ababacd&quot;</span>   // 比，当main[i]为e时，发现和pattern[j]的值e不一致，BF<br>                                         // 的做法是去下一个<span class="hljs-keyword">sub</span>,即用<span class="hljs-string">&quot;babaeab&quot;</span>和pattern进行比较。<br></code></pre></td></tr></table></figure>
<p>我没希望找到一些规律，遇到两个字符不匹配的情况时，希望可以多跳几个字符，减少比较次数。KMP算法的思想是：在模式串和主串匹配过程中，当遇到不匹配的字符时，对于主串和模式串中已对比过相同的前缀字符串，找到长度最长的相等前缀串，从而将模式串一次性滑动多位，并省略一些比较过程。在上个例子，KMP算法中，是这样处理的：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">main:    <span class="hljs-string">&quot;ababaeaba&quot;</span> <span class="hljs-regexp">//</span> 比如main中的<span class="hljs-string">&quot;ababa&quot;</span>子串，对标为[<span class="hljs-number">2</span>~<span class="hljs-number">4</span>]的<span class="hljs-string">&quot;aba&quot;</span>和pattern中下<br>pattern: <span class="hljs-string">&quot;ababacd&quot;</span>   <span class="hljs-regexp">//</span> 标为[<span class="hljs-number">0</span>~<span class="hljs-number">2</span>]的<span class="hljs-string">&quot;aba&quot;</span>相同,此时可以滑动j-k位,即j=j-k。(其中j是<br>                                         <span class="hljs-regexp">//</span> pattern中<span class="hljs-string">&quot;c&quot;</span>的下标,k是<span class="hljs-string">&quot;abc&quot;</span>的长度)。<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>      <span class="hljs-regexp">//</span> 比较过程中，main[<span class="hljs-number">5</span>]为<span class="hljs-string">&quot;e&quot;</span>和pattern[<span class="hljs-number">5</span>]为<span class="hljs-string">&quot;c&quot;</span>不匹配，但是两个<br>            <span class="hljs-string">&quot;ababacd&quot;</span>            <span class="hljs-regexp">//</span> 串中都有相同的<span class="hljs-string">&quot;aba&quot;</span>前缀,所以可以滑动j-k位<br>                    |           <br>                    ∨<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>   <br>                <span class="hljs-string">&quot;ababacd&quot;</span><br>                    |               <span class="hljs-regexp">//</span> 滑动j-k位后发现main[<span class="hljs-number">5</span>]和patterb[<span class="hljs-number">3</span>]不相同，需要再次滑动<br>                    ∨<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>   <br>                    <span class="hljs-string">&quot;ababacd&quot;</span> <span class="hljs-regexp">//</span> 滑动过程和上次类似。<br></code></pre></td></tr></table></figure>
<p>通过这个例子可以看出，每次滑动的位数是j-k，滑动位数和主串无关，仅通过模式串就可以求出。在KMP算法中通过next数组来存储当两个字符不相等时模式串应该移动的位数。</p>
<p>如何KMP算法的next数组<br>
再次明确next数组的含义 : next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标。 next[i] = j 表示下标以i-j为起点，i为终点的后缀和下标以0为起点，j为终点的前缀相等，且此字符串的长度最长。用符号表示为p[0~j] == p[i-j~i]。下面以”ababacd”模式串为例，给出这个串的next数组。</p>
<table>
<thead>
<tr>
<th>模式前缀</th>
<th>前缀结尾下标</th>
<th>最长能匹配前缀子串结尾字符的下标</th>
<th>next数组的取值</th>
<th>匹配情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>0</td>
<td>-1</td>
<td>next[0] = -1</td>
<td>无</td>
</tr>
<tr>
<td>ab</td>
<td>1</td>
<td>-1</td>
<td>next[1] = -1</td>
<td>无</td>
</tr>
<tr>
<td>aba</td>
<td>2</td>
<td>0</td>
<td>next[2]=0</td>
<td>pattern[2]==pattern[0]</td>
</tr>
<tr>
<td>abab</td>
<td>3</td>
<td>1</td>
<td>next[3]=1</td>
<td>pattern[2:4]==pattern[0:2]</td>
</tr>
<tr>
<td>ababa</td>
<td>4</td>
<td>2</td>
<td>next[4]=2</td>
<td>pattern[2:5]==pattern[0:3]</td>
</tr>
<tr>
<td>ababac</td>
<td>5</td>
<td>-1</td>
<td>next[5]=-1</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>KMP的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>,M=<span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> n,m,ne[N];<br><span class="hljs-type">char</span> p[N],s[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p+<span class="hljs-number">1</span>&gt;&gt;m&gt;&gt;s+<span class="hljs-number">1</span>;<span class="hljs-comment">//kmp算法通常都是以下标为1开始</span><br><br>    <span class="hljs-comment">//j从下标零开始,是因为我们要判断的是p[j+1]是否等于p[i]，如果是p[j]与p[i]比较，那么当</span><br>    <span class="hljs-comment">//p[j]与p[i]不匹配的时候,就找不到最长的前后缀匹配和了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)<span class="hljs-comment">//因为p的第一个ne[1]=0的，所以从第二个开始</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        ne[i]=j;<br>    &#125;<br><br>    <span class="hljs-comment">//kmp匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span>(j==n)<br>        &#123;<br>            cout&lt;&lt;i-n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>Trie</h1>
<h1>哈希表</h1>
<h2 id="拉链法">拉链法</h2>
<p><img src="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg" srcset="/img/loading.gif" lazyload alt="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> h[N],ne[N],e[N],idx,n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-comment">//为什么x%N后还要加N，因为在c++中-10mod3=-1，所以要把负数映射到正数</span><br>    e[idx]=x;<span class="hljs-comment">//单链表求法</span><br>    ne[idx]=h[k];<br>    h[k]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[k];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(e[i]==x)&#123;<span class="hljs-comment">//找到后就可以返回查询结果</span><br>            flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        string op;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>) <span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(x)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="开放寻址法">开放寻址法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200003</span>,null=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">//通常要比询问次数的范围大2-3倍，同时还是质数</span><br><span class="hljs-comment">//0x3f3f3f3f可以作为无穷大来比较</span><br><span class="hljs-type">int</span> h[N],n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(h[k]!=null&amp;&amp;h[k]!=x)<br>    &#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k==N) k=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string op;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            h[k]=x;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(h[<span class="hljs-built_in">find</span>(x)]==null) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="字符串哈希表">字符串哈希表</h2>
<p>(字符串哈希) O(n)+O(m)<br>
全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。<br>
对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。</p>
<p>映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ<br>
注意点：</p>
<ol>
<li>任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0</li>
<li>冲突问题：通过巧妙设置P (131 或 13331) , Q (264)(264)的值，一般可以理解为不产生冲突。</li>
</ol>
<p>问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。<br>
求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。</p>
<p>前缀和公式 h[i+1]=h[i]×P+s[i]h[i+1]=h[i]×P+s[i] i∈[0,n−1]i∈[0,n−1] h为前缀和数组，s为字符串数组<br>
区间和公式 h[l,r]=h[r]−h[l−1]×Pr−l+1h[l,r]=h[r]−h[l−1]×Pr−l+1<br>
区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，<br>
乘上 P2P2 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,P=<span class="hljs-number">131</span>;<br><span class="hljs-type">char</span> str[N];<br>ull p[N],h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//利用求区间和的思想，但是h[l-1]位次比h[r]低，所以需要将h[l-1]左移</span><br>    <span class="hljs-comment">//比如h[l-1]=AB,h[r]=ABCD,那么h[l-1]*p[r-l+1]就相当于ABCD-AB00=CD</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str+<span class="hljs-number">1</span>);<br>    p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]*P;<span class="hljs-comment">//求出每项的系数是多少</span><br>        h[i]=h[i<span class="hljs-number">-1</span>]*P+str[i];<span class="hljs-comment">//前缀和思想这个可以理解成2*5^n-1+3*5^n-2……</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l1,r1,l2,r2;<br>        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<br>        <span class="hljs-comment">//判断两个字符串的哈希值是否相同，如果相同代表字符串完全相同</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get_val</span>(l1,r1)==<span class="hljs-built_in">get_val</span>(l2,r2)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在计算最短路时，Dijkstra算法不能处理带有负权的图，bellman_ford和spfa可以处理带有负权边的图，spfa是对bellman_ford的优化。</p>
<h1>图论</h1>
<h2 id="Dijkstra算法">Dijkstra算法</h2>
<p><strong>在Dijkstra算法中，稠密图使用邻接矩阵，稀疏图使用邻接表</strong></p>
<h3 id="朴素Dijkstra算法">朴素Dijkstra算法</h3>
<p><strong>在使用Dijkstra算法时，如果有向图中出现重边或者是有环的话，只采用代价最小的边</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 −<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">500</span>,<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">105</span>,<br>图中涉及边长均不超过<span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m,g[N][N],dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))<br>                t=j;<br>        st[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆优化Dijkstra算法">堆优化Dijkstra算法</h3>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。如果路径不存在，则输出 −<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">1.5</span>×<span class="hljs-number">105</span>,<br>图中涉及边长均不小于 <span class="hljs-number">0</span>，且不超过 <span class="hljs-number">10000</span>。数据保证：如果最短路存在，则最短路的长度不超过 <span class="hljs-number">109</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<br><span class="hljs-type">int</span> h[N],n,m,ne[N],val[N],idx,w[N],dist[N];<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//默认将dist置为最大</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将第一个点置为0</span><br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;<span class="hljs-comment">//设置堆</span><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//堆不为空就循环</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取出堆首元素</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ver = t.second,distance = t.first;<br>        <span class="hljs-keyword">if</span>(state[ver]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果访问到已经最优的结点就进行下次循环</span><br>        state[ver]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])<span class="hljs-comment">//循环每一条可以访问的边</span><br>        &#123;<br>            <span class="hljs-type">int</span> j=val[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[ver]+w[i])&#123; <span class="hljs-comment">// 如果满足更新条件就更新</span><br>                dist[j]=dist[ver]+w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dist[j],j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> t=<span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="bellman-ford">bellman_ford</h2>
<p>Bellman-ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，输出 impossible。<br>注意：图中可能 存在负权回路 。<br><br>输入格式<br>第一行包含三个整数 <span class="hljs-built_in">n</span>,m,k。<br>接下来 m行，每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br>点的编号为 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span>。<br><br>输出格式<br>输出一个整数，表示从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离。<br>如果不存在满足条件的路径，则输出 impossible。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,k≤<span class="hljs-number">500</span>,<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">10000</span>,<br><span class="hljs-number">1</span>≤x,y≤<span class="hljs-built_in">n</span>，<br>任意边长的绝对值不超过 <span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,M=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dist[N],backup[N],n,m,k;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;edge[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(backup,dist,<span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a=edge[j].a,b=edge[j].b,w=edge[j].w;<br>            <span class="hljs-keyword">if</span>(dist[b]&gt;backup[a]+w)<br>                dist[b]=backup[a]+w;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        edge[i]=&#123;a,b,w&#125;;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//为啥是0x3f3f3f3f/2，因为当存在负权边的时候，每次更新dist都会变小，但我们还是认为他是正无穷</span><br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="spfa算法">spfa算法</h2>
<p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 impossible。<br>数据保证不存在负权回路。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 impossible。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">105</span>,<br>图中涉及边长绝对值均不超过 <span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> -<span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<br><span class="hljs-type">int</span> head[N],val[N],ne[N],w[N],idx,dist[N],n,m;<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=head[a];<br>    head[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    state[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//用来判断是否入队列</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        state[t]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//从队列取出后标记为假</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = val[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+w[i]) <span class="hljs-comment">// 如果边的权重更新，就将更新的点入栈</span><br>            &#123;<br>                dist[j]=dist[t]+w[i];<br>                <span class="hljs-keyword">if</span>(!state[j])&#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    state[j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> head);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>树</h1>
<h2 id="先序创建二叉树">先序创建二叉树</h2>
<p><strong>算法思想</strong></p>
<p>先序创建二叉树采用递归的方式实现，先传入二叉树的根节点指针的地址，然后依次递归读入二叉树节点，当读入的是’@‘时，将递归得到的根节点赋予NULL，当读入的不为’@'时，将该值赋值到根节点值，并依此递归左儿子和右儿子。</p>
<p><strong>关键问题1:为什么要传入根节点的地址?</strong></p>
<p>因为我们已知的是根节点指针，它指向malloc开辟的BiTree空间的首地址，当传入的是根节点指针而不是根节点指针的地址时，在函数中会copy一个该根节点指针指向的空间。但我们如果传入的是根节点指针的地址，函数内部不会重新copy一个空间。</p>
<p><strong>其思想与函数传入实参和形参相似</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Traverser.cpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree* root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    <span class="hljs-built_in">PreOrderTraverser</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="遍历二叉树">遍历二叉树</h2>
<h3 id="代码部分">代码部分</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//递归实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">InOrderTraverser</span>(T-&gt;lchild);<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">InOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">PostOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PostOrderTraverser</span>(T-&gt;rchild);<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//非递归实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverser_2</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;BiTree*&gt; op;<br>    BiTree* p=T;<br>    <span class="hljs-keyword">while</span>(p||op.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            op.<span class="hljs-built_in">push</span>(p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p=op.<span class="hljs-built_in">top</span>();    <br>            op.<span class="hljs-built_in">pop</span>();<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;                                           <br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser_2</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;BiTree*&gt;op;<br>    BiTree* p=T;<br>    <span class="hljs-keyword">while</span>(p||op.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            op.<span class="hljs-built_in">push</span>(p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p=op.<span class="hljs-built_in">top</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree* root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    <span class="hljs-built_in">PreOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">PreOrderTraverser_2</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrderTraverser_2</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">PostOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="计算二叉树">计算二叉树</h2>
<h3 id="代码部分-2">代码部分</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BiTreeDepth</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;lchild);<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;rchild);<br>        <span class="hljs-keyword">return</span> m&gt;n?(m+<span class="hljs-number">1</span>):(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountNode</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">CountNode</span>(T-&gt;lchild)+<span class="hljs-built_in">CountNode</span>(T-&gt;rchild)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountLeaves</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>((!T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))  cnt++;;<br>    <span class="hljs-type">int</span> lcnt=<span class="hljs-built_in">CountLeaves</span>(T-&gt;lchild);<br>    <span class="hljs-type">int</span> rcnt=<span class="hljs-built_in">CountLeaves</span>(T-&gt;rchild);<br>    cnt+=lcnt+rcnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree *root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    cout&lt;&lt;<span class="hljs-built_in">BiTreeDepth</span>(root)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a>
      
        <a href="/tags/acwing/" class="print-no-link">#acwing</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="print-no-link">#算法学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法学习</div>
      <div>http://www.ooorz.site/2022/10/23/算法学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lin Xinjie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月23日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2024年10月21日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/04/02/%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/" title="保研机试复习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">保研机试复习</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/04/27/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%952/" title="ctf做题记录2">
                        <span class="hidden-mobile">ctf做题记录2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'OOOOOORAN/OOOOOORAN.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      闽ICP备2024047719号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
